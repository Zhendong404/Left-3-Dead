###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        12/Mar/2016  23:02:58
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Sirius V2.5\src\Sources\C\Function_C\RunControl.c
#    Command line =  
#        "E:\Sirius V2.5\src\Sources\C\Function_C\RunControl.c" -D IAR -D
#        TWR_K60N512 -lCN "E:\Sirius V2.5\bin\Flash\List\" -lB "E:\Sirius
#        V2.5\bin\Flash\List\" -o "E:\Sirius V2.5\bin\Flash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "E:\Sirius V2.5\src\Sources\H\"
#        -I "E:\Sirius V2.5\src\Sources\H\Component_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Frame_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Function_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\SD_H\" -Ol --use_c++_inline
#    List file    =  E:\Sirius V2.5\bin\Flash\List\RunControl.lst
#    Object file  =  E:\Sirius V2.5\bin\Flash\Obj\RunControl.o
#
###############################################################################

E:\Sirius V2.5\src\Sources\C\Function_C\RunControl.c
      1          /******************************************************************************/
      2          /*******************************************************************************
      3            文件名：运动控制C文件RunControl.c
      4            功  能：偏差求取，PID反馈，控制电机，控制舵机。
      5            日  期：2014.11.15
      6            作  者：HJZ & YCR
      7            备  注：
      8          *******************************************************************************/
      9          /******************************************************************************/
     10          #include "RunControl.h"
     11          
     12          //偏差选取行对应的权重

   \                                 In section .rodata, align 4
     13          uint8 const DeviSelRowWeight[CameraHight] = 
   \                     DeviSelRowWeight:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
     14          {
     15          0
     16          };
     17          

   \                                 In section .bss, align 2
     18          int16 DeviNow = 0;                  //当前偏差, 可以考虑换成float型
   \                     DeviNow:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     19          int16 DeviPre = 0;                  //先前偏差, 可以考虑换成float型
   \                     DeviPre:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     20          uint8 DeviFlag = 0;                //偏差求取标志位，告诉程序这次应该写入第几个偏差。
   \                     DeviFlag:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     21          uint8 DeviSelRowStart = 30;                //偏差求取时，选择的起始行。
   \                     DeviSelRowStart:
   \   00000000   0x1E               DC8 30

   \                                 In section .data, align 1
     22          uint8 DeviSelRowEnd = 45;                //偏差求取时，选择的终止行。。
   \                     DeviSelRowEnd:
   \   00000000   0x2D               DC8 45

   \                                 In section .bss, align 1
     23          uint8 DeviSelRow02 = 0;                //偏差求取时，选中的行号。
   \                     DeviSelRow02:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     24          uint8 DeviRowChosen = 0;               //求取偏差时选取的行，若指定范围没选取到或者偏差过小，则置无效值。
   \                     DeviRowChosen:
   \   00000000                      DS8 1

   \                                 In section .data, align 2
     25          int16 DeviGoStraightLim = 3;          //偏差小于该值时，直走。
   \                     DeviGoStraightLim:
   \   00000000   0x0003             DC16 3
     26          

   \                                 In section .data, align 4
     27          float ServoKp = 4;                 //舵机PID的P参数
   \                     ServoKp:
   \   00000000   0x40800000         DC32 40800000H

   \                                 In section .data, align 4
     28          float ServoKd = 2;                 //舵机PID的D参数
   \                     ServoKd:
   \   00000000   0x40000000         DC32 40000000H

   \                                 In section .data, align 4
     29          float ServoK1 = 150;                 //舵机PID跟P参数有关的系数
   \                     ServoK1:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .data, align 2
     30          uint16 ServoPIDMax = 2086;             //舵机PID控制的最大值，右转
   \                     ServoPIDMax:
   \   00000000   0x0826             DC16 2086

   \                                 In section .data, align 2
     31          uint16 ServoPIDMin = 1617;             //舵机PID控制的最小值，左转
   \                     ServoPIDMin:
   \   00000000   0x0651             DC16 1617

   \                                 In section .data, align 2
     32          uint16 ServoPIDCen = 1851;             //舵机PID控制的中心值，直走。
   \                     ServoPIDCen:
   \   00000000   0x073B             DC16 1851
     33          
     34          

   \                                 In section .data, align 4
     35          float MotorLeftKp = 1;             //左电机PID的P参数    
   \                     MotorLeftKp:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .data, align 4
     36          float MotorLeftKd = 1;             //左电机PID的D参数
   \                     MotorLeftKd:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .bss, align 2
     37          uint16 MotorLeftPIDMax;         //左电机PID控制的最大值
   \                     MotorLeftPIDMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     38          uint16 MotorLeftPIDMin;         //左电机PID控制的最小值
   \                     MotorLeftPIDMin:
   \   00000000                      DS8 2
     39          

   \                                 In section .data, align 4
     40          float MotorRightKp = 1;            //右电机PID的P参数     
   \                     MotorRightKp:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .data, align 4
     41          float MotorRightKd = 1;            //右电机PID的D参数
   \                     MotorRightKd:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .bss, align 2
     42          uint16 MotorRightPIDMax;        //右电机PID控制的最大值
   \                     MotorRightPIDMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     43          uint16 MotorRightPIDMin;        //右电机PID控制的最小值
   \                     MotorRightPIDMin:
   \   00000000                      DS8 2
     44          
     45          
     46          
     47          /*
     48          //------------------------------------------------------------------------------
     49          //函数名：MotorControl
     50          //功  能：左右电机PWM驱动
     51          //参  数：motor_left为左电机PWM，motor_right为右电机PWM
     52          //返  回：无
     53          //说  明：PWM占空比计算方法CnV/MOD
     54          //------------------------------------------------------------------------------
     55          void MotorControl(int32 motor_left,int32 motor_right)
     56          {
     57          	//电机开关||摔倒，则关闭电机
     58          	if((!switch4) || fall_flag)
     59            {
     60          		FTM0_C4V=0;
     61          		FTM0_C5V=0;
     62          		FTM0_C6V=0;
     63          		FTM0_C7V=0;
     64          	}
     65            else
     66            {
     67              //电机死区消除
     68              if(motor_left>0)
     69                motor_left+=MOTOR_DEATH;
     70              else
     71                motor_left-=MOTOR_DEATH;
     72              if(motor_right>0)
     73                motor_right+=MOTOR_DEATH;
     74              else
     75                motor_right-=MOTOR_DEATH;
     76          
     77              //左电机PWM驱动
     78              if(motor_left>=0)
     79              {
     80                FTM0_C4V=0;
     81                FTM0_C5V=motor_left;
     82              }
     83              else
     84              {
     85          			FTM0_C5V=0;
     86                FTM0_C4V=-motor_left;
     87              }
     88              //右电机PWM驱动
     89              if(motor_right>=0)
     90              {
     91          			FTM0_C6V=motor_right;
     92                FTM0_C7V=0;
     93              }
     94              else
     95              {
     96          			FTM0_C7V=-motor_right;
     97                FTM0_C6V=0;
     98              }
     99          	}
    100          }
    101          
    102          */
    103          
    104          //======================================================================
    105          //函数名：DeviationGet
    106          //功  能：偏差、偏差变化率的计算
    107          //参  数：
    108          //返  回：1成功 0失败
    109          //影  响：
    110          //说  明：
    111          //      
    112          //             
    113          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    114          uint8 DeviationGet(void)
    115          {
    116            uint8 row;
    117            int16 tempDevi;
    118            
    119            for(row = DeviSelRowStart; row < DeviSelRowEnd; row++)
   \                     DeviationGet: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0xE000             B.N      ??DeviationGet_0
   \                     ??DeviationGet_1: (+1)
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \                     ??DeviationGet_0: (+1)
   \   00000008   0x....             LDR.N    R2,??DataTable2_1
   \   0000000A   0x7812             LDRB     R2,[R2, #+0]
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4290             CMP      R0,R2
   \   00000010   0xD21C             BCS.N    ??DeviationGet_2
    120            {
    121              if(CenterLineLoc[row] != MaxValUint8)
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x....             LDR.N    R2,??DataTable2_2
   \   00000016   0x5C82             LDRB     R2,[R0, R2]
   \   00000018   0x2AFF             CMP      R2,#+255
   \   0000001A   0xD0F4             BEQ.N    ??DeviationGet_1
    122              { //指定范围内找到了有效行.
    123                tempDevi = CenterLineLoc[row] - PhyCenterCol;
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x....             LDR.N    R1,??DataTable2_2
   \   00000020   0x5C41             LDRB     R1,[R0, R1]
   \   00000022   0x398C             SUBS     R1,R1,#+140
    124                //若偏差过小，则将偏差置为0，选取行置0(选取范围不能包括0)。
    125                if((tempDevi < DeviGoStraightLim)&&(tempDevi > -DeviGoStraightLim))
   \   00000024   0x....             LDR.N    R2,??DataTable2_3
   \   00000026   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   0000002A   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xDA0B             BGE.N    ??DeviationGet_3
   \   00000030   0x....             LDR.N    R2,??DataTable2_3
   \   00000032   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   00000036   0x4252             RSBS     R2,R2,#+0
   \   00000038   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000003A   0x428A             CMP      R2,R1
   \   0000003C   0xDA04             BGE.N    ??DeviationGet_3
    126                {
    127                  tempDevi = 0;
   \   0000003E   0x2100             MOVS     R1,#+0
    128                  DeviRowChosen = 0;
   \   00000040   0x2200             MOVS     R2,#+0
   \   00000042   0x....             LDR.N    R3,??DataTable2_4
   \   00000044   0x701A             STRB     R2,[R3, #+0]
   \   00000046   0xE001             B.N      ??DeviationGet_4
    129                }
    130                //偏差够大，则偏差置更新，选取行更新。
    131                else
    132                {
    133                  DeviRowChosen = row;  
   \                     ??DeviationGet_3: (+1)
   \   00000048   0x....             LDR.N    R2,??DataTable2_4
   \   0000004A   0x7010             STRB     R0,[R2, #+0]
    134                }
    135                    
    136                break;
    137              }
    138            }
    139            if(row >= DeviSelRowEnd)
   \                     ??DeviationGet_4: (+1)
   \                     ??DeviationGet_2: (+1)
   \   0000004C   0x....             LDR.N    R2,??DataTable2_1
   \   0000004E   0x7812             LDRB     R2,[R2, #+0]
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x4290             CMP      R0,R2
   \   00000054   0xD305             BCC.N    ??DeviationGet_5
    140            { //指定范围里没有选取到有效行，则偏差保持原状，选取行置无效值。
    141              tempDevi = DeviPre;
   \   00000056   0x....             LDR.N    R0,??DataTable2_5
   \   00000058   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
    142              DeviRowChosen = MaxValUint8;    
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0x....             LDR.N    R2,??DataTable2_4
   \   00000060   0x7010             STRB     R0,[R2, #+0]
    143            }
    144            
    145            DeviPre = DeviNow;
   \                     ??DeviationGet_5: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable2_6
   \   00000064   0x8800             LDRH     R0,[R0, #+0]
   \   00000066   0x....             LDR.N    R2,??DataTable2_5
   \   00000068   0x8010             STRH     R0,[R2, #+0]
    146            DeviNow = tempDevi;
   \   0000006A   0x....             LDR.N    R0,??DataTable2_6
   \   0000006C   0x8001             STRH     R1,[R0, #+0]
    147            
    148            return 1;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0x4770             BX       LR               ;; return
    149          }
    150          
    151          //舵机PID控制函数。

   \                                 In section .text, align 2, keep-with-next
    152          uint8 ServoPID(void)
    153          {
   \                     ServoPID: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    154            float temp;
    155            int16 temp1;
    156            
    157            temp1 = DeviNow - DeviPre;
   \   00000002   0x....             LDR.N    R0,??DataTable2_6
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable2_5
   \   00000008   0x8809             LDRH     R1,[R1, #+0]
   \   0000000A   0x1A44             SUBS     R4,R0,R1
    158            /*
    159            if(temp1 > 50) 
    160            {
    161              temp1 = 50;
    162            }
    163            else if(temp1 < -50)
    164            {
    165              temp1 = -50;
    166            }
    167            else
    168            {
    169            }
    170            */
    171            //ServoKp = DeviNow * DeviNow / ServoK1;
    172            
    173            temp = (ServoPIDMax + ServoPIDMin) / 2 - ServoKp * DeviNow - ServoKd * temp1;
   \   0000000C   0x....             LDR.N    R0,??DataTable2_7
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable2_8
   \   00000012   0x8809             LDRH     R1,[R1, #+0]
   \   00000014   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001E   0x.... 0x....      BL       __aeabi_i2f
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0x....             LDR.N    R0,??DataTable2_6
   \   00000026   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       __aeabi_i2f
   \   0000002E   0x....             LDR.N    R1,??DataTable2_9
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       __aeabi_fsub
   \   0000003E   0x0005             MOVS     R5,R0
   \   00000040   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       __aeabi_i2f
   \   00000048   0x....             LDR.N    R1,??DataTable2_10
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x.... 0x....      BL       __aeabi_fmul
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       __aeabi_fsub
   \   00000058   0x0004             MOVS     R4,R0
    174            if(temp > ServoPIDMax)
   \   0000005A   0x....             LDR.N    R0,??DataTable2_7
   \   0000005C   0x8800             LDRH     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000068   0xD205             BCS.N    ??ServoPID_0
    175            {
    176              temp = ServoPIDMax;  
   \   0000006A   0x....             LDR.N    R0,??DataTable2_7
   \   0000006C   0x8800             LDRH     R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000072   0x0004             MOVS     R4,R0
   \   00000074   0xE00D             B.N      ??ServoPID_1
    177            }
    178            else if(temp < ServoPIDMin)
   \                     ??ServoPID_0: (+1)
   \   00000076   0x....             LDR.N    R0,??DataTable2_8
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000007E   0x0001             MOVS     R1,R0
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000086   0xD204             BCS.N    ??ServoPID_1
    179            {
    180              temp = ServoPIDMin;
   \   00000088   0x....             LDR.N    R0,??DataTable2_8
   \   0000008A   0x8800             LDRH     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000090   0x0004             MOVS     R4,R0
    181            }
    182            else
    183            {    
    184            }
    185            
    186            FTM1_C0V = (uint16)temp;
   \                     ??ServoPID_1: (+1)
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       __aeabi_f2iz
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x....             LDR.N    R1,??DataTable2_11  ;; 0x40039010
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    187            
    188            
    189          
    190              
    191            return 1;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    192          }
    193          
    194          
    195          //======================================================================
    196          //函数名：SportControl
    197          //功  能：运动控制。
    198          //参  数：无
    199          //返  回：无
    200          //影  响：
    201          //说  明：1. 若图像处理不成功，则延用上一次的控制数据。否则将更新。
    202          //      
    203          //             
    204          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    205          void SportControl(uint8 ImageProFlag)
    206          {
   \                     SportControl: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    207            uint8 tempD;
    208              if(ImageProFlag) 
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??SportControl_0
    209              {
    210                //偏差求取
    211                tempD = DeviationGet();
   \   00000008   0x.... 0x....      BL       DeviationGet
   \   0000000C   0x0004             MOVS     R4,R0
    212                if(!tempD)
    213                {
    214                  //uart_sendN(UART0, (uint8 *)"\nDeviationGet Failed!", 21);  
    215                }
    216                
    217                //舵机PID控制
    218                if(!ServoPID())
   \   0000000E   0x.... 0x....      BL       ServoPID
    219                {
    220                  //uart_sendN(UART0, (uint8 *)"\nServoPID Failed!", 17);
    221                }
    222              }
    223              
    224              
    225              VirtualOutData[0] = DeviPre;
   \                     ??SportControl_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable2_5
   \   00000014   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       __aeabi_i2f
   \   0000001C   0x....             LDR.N    R1,??DataTable2_12
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    226              VirtualOutData[1] = DeviNow;
   \   00000020   0x....             LDR.N    R0,??DataTable2_6
   \   00000022   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       __aeabi_i2f
   \   0000002A   0x....             LDR.N    R1,??DataTable2_12
   \   0000002C   0x6048             STR      R0,[R1, #+4]
    227              VirtualOutData[2] = CenterLineLoc[25];   //BlackRightLoc[25][0]; //FTM1_C0V - ServoPIDMin;
   \   0000002E   0x....             LDR.N    R0,??DataTable2_2
   \   00000030   0x7E40             LDRB     R0,[R0, #+25]
   \   00000032   0x.... 0x....      BL       __aeabi_ui2f
   \   00000036   0x....             LDR.N    R1,??DataTable2_12
   \   00000038   0x6088             STR      R0,[R1, #+8]
    228              VirtualOutData[3] = DeviRowChosen;
   \   0000003A   0x....             LDR.N    R0,??DataTable2_4
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000042   0x....             LDR.N    R1,??DataTable2_12
   \   00000044   0x60C8             STR      R0,[R1, #+12]
    229              VirtualOutPut_Data();
   \   00000046   0x.... 0x....      BL       VirtualOutPut_Data
    230              
    231               
    232          }
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     DeviSelRowStart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     DeviSelRowEnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     DeviGoStraightLim

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     DeviRowChosen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     DeviPre

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     DeviNow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     ServoPIDMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     ServoPIDMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     ServoKp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x........         DC32     ServoKd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40039010         DC32     0x40039010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x........         DC32     VirtualOutData
    233          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DeviationGet
      16   ServoPID
        16   -> __aeabi_cfcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_fmul
        16   -> __aeabi_fsub
        16   -> __aeabi_i2f
        16   -> __aeabi_ui2f
       8   SportControl
         8   -> DeviationGet
         8   -> ServoPID
         8   -> VirtualOutPut_Data
         8   -> __aeabi_i2f
         8   -> __aeabi_ui2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       1  DeviFlag
       2  DeviGoStraightLim
       2  DeviNow
       2  DeviPre
       1  DeviRowChosen
       1  DeviSelRow02
       1  DeviSelRowEnd
       1  DeviSelRowStart
      52  DeviSelRowWeight
     114  DeviationGet
       4  MotorLeftKd
       4  MotorLeftKp
       2  MotorLeftPIDMax
       2  MotorLeftPIDMin
       4  MotorRightKd
       4  MotorRightKp
       2  MotorRightPIDMax
       2  MotorRightPIDMin
       4  ServoK1
       4  ServoKd
       4  ServoKp
     162  ServoPID
       2  ServoPIDCen
       2  ServoPIDMax
       2  ServoPIDMin
      76  SportControl

 
  15 bytes in section .bss
  38 bytes in section .data
  52 bytes in section .rodata
 404 bytes in section .text
 
 404 bytes of CODE  memory
  52 bytes of CONST memory
  53 bytes of DATA  memory

Errors: none
Warnings: none
