###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        12/Mar/2016  23:02:55
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Sirius V2.5\src\Sources\C\Component_C\DMA.c
#    Command line =  
#        "E:\Sirius V2.5\src\Sources\C\Component_C\DMA.c" -D IAR -D TWR_K60N512
#        -lCN "E:\Sirius V2.5\bin\Flash\List\" -lB "E:\Sirius
#        V2.5\bin\Flash\List\" -o "E:\Sirius V2.5\bin\Flash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "E:\Sirius V2.5\src\Sources\H\"
#        -I "E:\Sirius V2.5\src\Sources\H\Component_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Frame_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Function_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\SD_H\" -Ol --use_c++_inline
#    List file    =  E:\Sirius V2.5\bin\Flash\List\DMA.lst
#    Object file  =  E:\Sirius V2.5\bin\Flash\Obj\DMA.o
#
###############################################################################

E:\Sirius V2.5\src\Sources\C\Component_C\DMA.c
      1          //==============================================================================
      2          //文件名称：DMA.c
      3          //功能概要：K60 DMA底层驱动程序文件
      4          //版权所有：HJZ
      5          //端口使用：
      6          //==============================================================================
      7          #include "DMA.h"
      8          
      9          
     10          

   \                                 In section .bss, align 1
     11          volatile uint8 DMAFlag = 0;
   \                     DMAFlag:
   \   00000000                      DS8 1
     12          
     13          /*
     14          
     15          // 这是给OV7725准备的DMA初始化函数
     16          uint8 DMAInit(uint8 DMA_CHn, uint8 DMA_Source, uint32 DMA_Count, uint32 S_Addr, uint32 D_Addr)
     17          {
     18              //输入变量初步检查
     19          	if (DMA_CHn > 15) return 0;                
     20          	if (DMA_Source > 52) return 0; 
     21          
     22          	//DMA通道配置
     23          	SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;    //打开DMA多路复用时钟
     24          	SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;       //打开DMA模块时钟
     25          	DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR, DMA_CHn) = (0
     26          		                                   | DMAMUX_CHCFG_ENBL_MASK			        // 使能DMA通道 
     27                                                             //| DMAMUX_CHCFG_TRIG_MASK				// 打开周期性触发模式，注意只有0~3通道支持
     28                                                             | DMAMUX_CHCFG_SOURCE(DMA_Source)      // 指定DMA触发源 
     29          		                                   );
     30              
     31          	DMA_CR = 0;												  // 默认配置，需要在DMA被激活之前配置此寄存器
     32          	//DMA_DCHPRIn										      // 默认优先级配置，这里不另更改
     33          	DMA_BASE_PTR->TCD[DMA_CHn].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(DMA_Count); // 主循环计数器，1个major loop, 即一次传输量=major_loop*minor_loop，最大为2^15=32767 
     34          	DMA_BASE_PTR->TCD[DMA_CHn].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(DMA_Count); // 主循环计数器复位值，BITER应该等于CITER 
     35          	DMA_BASE_PTR->TCD[DMA_CHn].NBYTES_MLNO = 1;				  // 每次minor loop传送1个字节
     36          
     37          	//源地址操作
     38          	DMA_BASE_PTR->TCD[DMA_CHn].SADDR = S_Addr;				  // DMA源地址
     39          	DMA_BASE_PTR->TCD[DMA_CHn].SOFF  = 0x0000;				  // 每次读源地址后，增加的字节数
     40          	DMA_BASE_PTR->TCD[DMA_CHn].SLAST = 0x00;			      // DMA所有主循环完成后，源地址的增量
     41          
     42          	//目的地址操作
     43          	DMA_BASE_PTR->TCD[DMA_CHn].DADDR = D_Addr;				  // DMA目标地址 
     44          	DMA_BASE_PTR->TCD[DMA_CHn].DOFF  = 0x0001;				  // 每次写目的地址后，增加的字节数
     45          	DMA_BASE_PTR->TCD[DMA_CHn].DLAST_SGA = 0x00;		      // DMA所有主循环完成后，目的地址的增量
     46          	
     47          	DMA_BASE_PTR->TCD[DMA_CHn].ATTR  =(0 
     48          		                              |DMA_ATTR_SMOD(0)		  // Source modulo feature disabled 
     49          		                              | DMA_ATTR_SSIZE(0)	  // 源数据宽度，   8位传送 
     50          		                              | DMA_ATTR_DMOD(0) 	  // Destination modulo feature disabled 
     51          		                              | DMA_ATTR_DSIZE(0)	  // 目的数据宽度， 8位传送 
     52          		                              );
     53          
     54          	//CSR寄存器操作
     55          	DMA_BASE_PTR->TCD[DMA_CHn].CSR = 0;						  // 先清零CSR，之后再设置 
     56                  DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_BWC(3);    //每读1次，eDMA引擎停止8个周期
     57          	DMA_INT |= (1<<DMA_CHn);	                        // 1次主循环传输完成后的中断标志位，清零 
     58          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_INTMAJOR_MASK; // 1次主循环传输完成后的中断使能位，使能 
     59          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_DREQ_MASK;      // 1次DMA传输完成后，自动清REQ位，停止工作 
     60          
     61          	//DMA启停位
     62          	DMA_ERQ &= ~(1 << DMA_CHn);						      // 关闭相应通道的DMA请求，在配置阶段先关闭，再调用myDMA_Start函数开启DMA 
     63                                                                        
     64          	return 1;
     65          
     66          }// end of DMAInit()
     67          
     68          
     69          */
     70          
     71          
     72          
     73          
     74          //------------------------------------------------------------------------------
     75          //函数名：DMAInit
     76          //功  能：DMA初始化
     77          //参  数：
     78          //        DMA_CHn--指定的DMA通道号，范围0~15；
     79          //        DMA_Source--DMA触发源，在DMA.h文件里有枚举定义
     80          //        S_Addr--DMA传送源地址
     81          //        D_Addr--DMA传送目的地址
     82          //返  回：无
     83          //说  明：对应OV7620，不是7725。7725用不到行中断。
     84          //
     85          //        
     86          
     87          //------------------------------------------------------------------------------
     88          
     89          
     90          //这是给OV7620准备的DMA初始化函数，暂时先不要动

   \                                 In section .text, align 2, keep-with-next
     91          uint8 DMAInit(uint8 DMA_CHn, uint8 DMA_Source, uint16 DMA_Count, uint32 S_Addr, uint32 D_Addr)
     92          {
   \                     DMAInit: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
     93              //输入变量初步检查
     94          	if (DMA_CHn > 15) return 0;                
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2810             CMP      R0,#+16
   \   00000006   0xDB01             BLT.N    ??DMAInit_0
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE0A1             B.N      ??DMAInit_1
     95          	if (DMA_Source > 52) return 0; 
   \                     ??DMAInit_0: (+1)
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0x2935             CMP      R1,#+53
   \   00000010   0xDB01             BLT.N    ??DMAInit_2
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE09C             B.N      ??DMAInit_1
     96          
     97          	//DMA通道配置
     98          	SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;    //打开DMA多路复用时钟
   \                     ??DMAInit_2: (+1)
   \   00000016   0x....             LDR.N    R4,??DataTable0  ;; 0x4004803c
   \   00000018   0x6824             LDR      R4,[R4, #+0]
   \   0000001A   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   0000001E   0x....             LDR.N    R5,??DataTable0  ;; 0x4004803c
   \   00000020   0x602C             STR      R4,[R5, #+0]
     99          	SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;       //打开DMA模块时钟
   \   00000022   0x....             LDR.N    R4,??DataTable0_1  ;; 0x40048040
   \   00000024   0x6824             LDR      R4,[R4, #+0]
   \   00000026   0xF054 0x0402      ORRS     R4,R4,#0x2
   \   0000002A   0x....             LDR.N    R5,??DataTable0_1  ;; 0x40048040
   \   0000002C   0x602C             STR      R4,[R5, #+0]
    100          	DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR, DMA_CHn) = (0
    101          	                                           | DMAMUX_CHCFG_ENBL_MASK		// 使能DMA通道 
    102                                                           //| DMAMUX_CHCFG_TRIG_MASK		// 打开周期性触发模式，注意只有0~3通道支持
    103                                                             | DMAMUX_CHCFG_SOURCE(DMA_Source) // 指定DMA触发源 
    104                                                              );
   \   0000002E   0xF011 0x013F      ANDS     R1,R1,#0x3F
   \   00000032   0xF051 0x0180      ORRS     R1,R1,#0x80
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x....             LDR.N    R4,??DataTable0_2  ;; 0x40021000
   \   0000003A   0x5501             STRB     R1,[R0, R4]
    105              
    106          	DMA_CR = 0;												  // 默认配置，需要在DMA被激活之前配置此寄存器
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R4,??DataTable0_3  ;; 0x40008000
   \   00000040   0x6021             STR      R1,[R4, #+0]
    107          	//DMA_DCHPRIn										      // 默认优先级配置，这里不另更改
    108          	DMA_BASE_PTR->TCD[DMA_CHn].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(DMA_Count); // 主循环计数器，1个major loop, 即一次传输量=major_loop*minor_loop，最大为2^15=32767 
   \   00000042   0x0451             LSLS     R1,R2,#+17       ;; ZeroExtS R1,R2,#+17,#+17
   \   00000044   0x0C49             LSRS     R1,R1,#+17
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0x0144             LSLS     R4,R0,#+5
   \   0000004A   0xF104 0x4480      ADD      R4,R4,#+1073741824
   \   0000004E   0xF514 0x4410      ADDS     R4,R4,#+36864
   \   00000052   0x82E1             STRH     R1,[R4, #+22]
    109          	DMA_BASE_PTR->TCD[DMA_CHn].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(DMA_Count); // 主循环计数器复位值，BITER应该等于CITER 
   \   00000054   0x0451             LSLS     R1,R2,#+17       ;; ZeroExtS R1,R2,#+17,#+17
   \   00000056   0x0C49             LSRS     R1,R1,#+17
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x0142             LSLS     R2,R0,#+5
   \   0000005C   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000060   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000064   0x83D1             STRH     R1,[R2, #+30]
    110          	DMA_BASE_PTR->TCD[DMA_CHn].NBYTES_MLNO = 1;				  // 每次minor loop传送1个字节
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x0142             LSLS     R2,R0,#+5
   \   0000006C   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000070   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   00000074   0x6091             STR      R1,[R2, #+8]
    111          
    112          	//源地址操作
    113          	DMA_BASE_PTR->TCD[DMA_CHn].SADDR = S_Addr;				  // DMA源地址
   \   00000076   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000078   0x0141             LSLS     R1,R0,#+5
   \   0000007A   0x....             LDR.N    R2,??DataTable0_4  ;; 0x40009000
   \   0000007C   0x508B             STR      R3,[R1, R2]
    114          	DMA_BASE_PTR->TCD[DMA_CHn].SOFF  = 0x0000;				  // 每次读源地址后，增加的字节数
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x0142             LSLS     R2,R0,#+5
   \   00000084   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000088   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   0000008C   0x8091             STRH     R1,[R2, #+4]
    115          	DMA_BASE_PTR->TCD[DMA_CHn].SLAST = 0x00;			      // DMA所有主循环完成后，源地址的增量
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000092   0x0142             LSLS     R2,R0,#+5
   \   00000094   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000098   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   0000009C   0x60D1             STR      R1,[R2, #+12]
    116          
    117          	//目的地址操作
    118          	DMA_BASE_PTR->TCD[DMA_CHn].DADDR = D_Addr;				  // DMA目标地址 
   \   0000009E   0x9902             LDR      R1,[SP, #+8]
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0x0142             LSLS     R2,R0,#+5
   \   000000A4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000A8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000AC   0x6111             STR      R1,[R2, #+16]
    119          	DMA_BASE_PTR->TCD[DMA_CHn].DOFF  = 0x0001;				  // 每次写目的地址后，增加的字节数
   \   000000AE   0x2101             MOVS     R1,#+1
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x0142             LSLS     R2,R0,#+5
   \   000000B4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000B8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000BC   0x8291             STRH     R1,[R2, #+20]
    120          	//DMA_BASE_PTR->TCD[DMA_CHn].DLAST_SGA = CameraWidth;		      // DMA所有主循环完成后，目的地址的增量
    121          	DMA_BASE_PTR->TCD[DMA_CHn].DLAST_SGA = 0;      /////////////////////////两个数字不知道哪个是对的
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C2   0x0142             LSLS     R2,R0,#+5
   \   000000C4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000C8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000CC   0x6191             STR      R1,[R2, #+24]
    122                  
    123          	DMA_BASE_PTR->TCD[DMA_CHn].ATTR  =(0 
    124          		                              |DMA_ATTR_SMOD(0)		  // Source modulo feature disabled 
    125          		                              | DMA_ATTR_SSIZE(0)	  // 源数据宽度，   8位传送 
    126          		                              | DMA_ATTR_DMOD(0) 	  // Destination modulo feature disabled 
    127          		                              | DMA_ATTR_DSIZE(0)	  // 目的数据宽度， 8位传送 
    128          		                              );
   \   000000CE   0x2100             MOVS     R1,#+0
   \   000000D0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D2   0x0142             LSLS     R2,R0,#+5
   \   000000D4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000D8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000DC   0x80D1             STRH     R1,[R2, #+6]
    129          
    130          	//CSR寄存器操作
    131          	DMA_BASE_PTR->TCD[DMA_CHn].CSR = 0;				// 先清零CSR，之后再设置 
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x0142             LSLS     R2,R0,#+5
   \   000000E4   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   000000E8   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   000000EC   0x8391             STRH     R1,[R2, #+28]
    132          	DMA_INT |= (1<<DMA_CHn);					// 1次主循环传输完成后的中断标志位，清零 
   \   000000EE   0x....             LDR.N    R1,??DataTable0_5  ;; 0x40008024
   \   000000F0   0x6809             LDR      R1,[R1, #+0]
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x4082             LSLS     R2,R2,R0
   \   000000F6   0x4311             ORRS     R1,R2,R1
   \   000000F8   0x....             LDR.N    R2,??DataTable0_5  ;; 0x40008024
   \   000000FA   0x6011             STR      R1,[R2, #+0]
    133          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_INTMAJOR_MASK; // 1次主循环传输完成后的中断使能位，使能 
   \   000000FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FE   0x0141             LSLS     R1,R0,#+5
   \   00000100   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000104   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000108   0x8B89             LDRH     R1,[R1, #+28]
   \   0000010A   0xF051 0x0102      ORRS     R1,R1,#0x2
   \   0000010E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000110   0x0142             LSLS     R2,R0,#+5
   \   00000112   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000116   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   0000011A   0x8391             STRH     R1,[R2, #+28]
    134          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_DREQ_MASK;      // 1次DMA传输完成后，自动清REQ位，停止工作 
   \   0000011C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011E   0x0141             LSLS     R1,R0,#+5
   \   00000120   0xF101 0x4180      ADD      R1,R1,#+1073741824
   \   00000124   0xF511 0x4110      ADDS     R1,R1,#+36864
   \   00000128   0x8B89             LDRH     R1,[R1, #+28]
   \   0000012A   0xF051 0x0108      ORRS     R1,R1,#0x8
   \   0000012E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000130   0x0142             LSLS     R2,R0,#+5
   \   00000132   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   00000136   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   0000013A   0x8391             STRH     R1,[R2, #+28]
    135          
    136          	//DMA启停位
    137          	DMA_ERQ &= ~(1 << DMA_CHn);		// 关闭相应通道的DMA请求，在配置阶段先关闭
   \   0000013C   0x....             LDR.N    R1,??DataTable0_6  ;; 0x4000800c
   \   0000013E   0x6809             LDR      R1,[R1, #+0]
   \   00000140   0x2201             MOVS     R2,#+1
   \   00000142   0xFA12 0xF000      LSLS     R0,R2,R0
   \   00000146   0xEA31 0x0000      BICS     R0,R1,R0
   \   0000014A   0x....             LDR.N    R1,??DataTable0_6  ;; 0x4000800c
   \   0000014C   0x6008             STR      R0,[R1, #+0]
    138                                                                        // 所有主循环(不是1次主循环)完成后，ERQ会被自动清零，需要行中断中再次手动开启。
    139          	return 1;
   \   0000014E   0x2001             MOVS     R0,#+1
   \                     ??DMAInit_1: (+1)
   \   00000150   0xBC30             POP      {R4,R5}
   \   00000152   0x4770             BX       LR               ;; return
    140          
    141          }// end of DMAInit()
    142          
    143          
    144          /*  这是给DMA测试专用的DMA初始化函数，暂时不用动
    145          uint8 DMAInit(uint8 DMA_CHn, uint8 DMA_Source, uint32 S_Addr, uint32 D_Addr)
    146          {
    147              //输入变量初步检查
    148          	if (DMA_CHn > 15) return 0;                
    149          	if (DMA_Source > 52) return 0; 
    150          
    151          	//DMA通道配置
    152          	SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;    //打开DMA多路复用时钟
    153          	SIM_SCGC7 |= SIM_SCGC7_DMA_MASK;       //打开DMA模块时钟
    154          	DMAMUX_CHCFG_REG(DMAMUX_BASE_PTR, DMA_CHn) = (0
    155          												  | DMAMUX_CHCFG_ENBL_MASK			        // 使能DMA通道 
    156          												  //| DMAMUX_CHCFG_TRIG_MASK				// 打开周期性触发模式，注意只有0~3通道支持
    157          												  | DMAMUX_CHCFG_SOURCE(DMA_Source)      // 指定DMA触发源 
    158          												  );
    159              
    160          	DMA_CR = 0;												  // 默认配置，需要在DMA被激活之前配置此寄存器
    161          	//DMA_DCHPRIn										      // 默认优先级配置，这里不另更改
    162          	DMA_BASE_PTR->TCD[DMA_CHn].CITER_ELINKNO = DMA_CITER_ELINKNO_CITER(10); // 主循环计数器，1个major loop, 即一次传输量=major_loop*minor_loop，最大为2^15=32767 
    163          	DMA_BASE_PTR->TCD[DMA_CHn].BITER_ELINKNO = DMA_CITER_ELINKNO_CITER(10); // 主循环计数器复位值，BITER应该等于CITER 
    164          	DMA_BASE_PTR->TCD[DMA_CHn].NBYTES_MLNO = 1;				  // 每次minor loop传送1个字节
    165          
    166          	//源地址操作
    167          	DMA_BASE_PTR->TCD[DMA_CHn].SADDR = S_Addr;				  // DMA源地址
    168          	DMA_BASE_PTR->TCD[DMA_CHn].SOFF  = 0x0000;				  // 每次读源地址后，增加的字节数
    169          	DMA_BASE_PTR->TCD[DMA_CHn].SLAST = 0x00;			      // DMA所有主循环完成后，源地址的增量
    170          
    171          	//目的地址操作
    172          	DMA_BASE_PTR->TCD[DMA_CHn].DADDR = D_Addr;				  // DMA目标地址 
    173          	DMA_BASE_PTR->TCD[DMA_CHn].DOFF  = 0x0001;				  // 每次写目的地址后，增加的字节数
    174          	DMA_BASE_PTR->TCD[DMA_CHn].DLAST_SGA = -10;		      // DMA所有主循环完成后，目的地址的增量
    175          	
    176          	DMA_BASE_PTR->TCD[DMA_CHn].ATTR  =(0 
    177          		                              |DMA_ATTR_SMOD(0)		  // Source modulo feature disabled 
    178          		                              | DMA_ATTR_SSIZE(0)	  // 源数据宽度，   8位传送 
    179          		                              | DMA_ATTR_DMOD(0) 	  // Destination modulo feature disabled 
    180          		                              | DMA_ATTR_DSIZE(0)	  // 目的数据宽度， 8位传送 
    181          		                              );
    182          
    183          	//CSR寄存器操作
    184          	DMA_BASE_PTR->TCD[DMA_CHn].CSR = 0;						  // 先清零CSR，之后再设置 
    185          	DMA_INT |= (1<<DMA_CHn);						// 1次主循环传输完成后的中断标志位，清零 
    186          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_INTMAJOR_MASK; // 1次主循环传输完成后的中断使能位，使能 
    187          	DMA_BASE_PTR->TCD[DMA_CHn].CSR |= DMA_CSR_DREQ_MASK;      // 1次DMA传输完成后，自动清REQ位，停止工作 
    188          
    189          	//DMA启停位
    190          	DMA_ERQ &= ~(1 << DMA_CHn);						      // 关闭相应通道的DMA请求，在配置阶段先关闭，再调用myDMA_Start函数开启DMA 
    191                                                                        // 所有主循环(不是1次主循环)完成后，ERQ会被自动清零，需要行中断中再次手动开启。
    192          	return 1;
    193          
    194          }// end of DMAInit()
    195          
    196          */
    197          
    198          //下面几个函数应该放在isr.c 中，只是暂存于此
    199          /*
    200          void DMA_CHO_ISR(void)
    201          {
    202          		DMA_INT|=DMA_INT_INT0_MASK;//清除通道0中断
    203          			//putstr("DMA complete！");
    204          				row_F[imagerow]=1;//采集完成标志
    205          					imagerow++;	
    206          }
    207          
    208          
    209          
    210          
    211          
    212          
    213          
    214          
    215          
    216          void portb_isr(void)//行中断，B10，上升沿中断
    217          {
    218          	PORTB_PCR10|=PORT_PCR_ISF_MASK;//清除中断标志位
    219          	row++; //行计数
    220          	if(row==data_table[imagerow])//如果当前行数据应该采集 
    221          		{
    222          		DMA_ERQ|=DMA_ERQ_ERQ0_MASK;//使能通道0硬件DMA请求  
    223          		}
    224          	  else if(row>=ENDROW) //一场完成，关闭行中断
    225          	  	{
    226          		  disable_irq (88);
    227          		  	 displaypara(row,6,60);
    228          
    229          	  	}
    230          }
    231          */
    232          
    233          

   \                                 In section .text, align 2, keep-with-next
    234          void enable_DMA_irq(uint8 DMAno)
    235          {
   \                     enable_DMA_irq: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    236            switch(DMAno)
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD017             BEQ.N    ??enable_DMA_irq_0
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD01D             BEQ.N    ??enable_DMA_irq_1
   \   0000000C   0xD318             BCC.N    ??enable_DMA_irq_2
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD022             BEQ.N    ??enable_DMA_irq_3
   \   00000012   0xD31D             BCC.N    ??enable_DMA_irq_4
   \   00000014   0x2806             CMP      R0,#+6
   \   00000016   0xD027             BEQ.N    ??enable_DMA_irq_5
   \   00000018   0xD322             BCC.N    ??enable_DMA_irq_6
   \   0000001A   0x2808             CMP      R0,#+8
   \   0000001C   0xD02C             BEQ.N    ??enable_DMA_irq_7
   \   0000001E   0xD327             BCC.N    ??enable_DMA_irq_8
   \   00000020   0x280A             CMP      R0,#+10
   \   00000022   0xD031             BEQ.N    ??enable_DMA_irq_9
   \   00000024   0xD32C             BCC.N    ??enable_DMA_irq_10
   \   00000026   0x280C             CMP      R0,#+12
   \   00000028   0xD036             BEQ.N    ??enable_DMA_irq_11
   \   0000002A   0xD331             BCC.N    ??enable_DMA_irq_12
   \   0000002C   0x280E             CMP      R0,#+14
   \   0000002E   0xD03B             BEQ.N    ??enable_DMA_irq_13
   \   00000030   0xD336             BCC.N    ??enable_DMA_irq_14
   \   00000032   0x280F             CMP      R0,#+15
   \   00000034   0xD03C             BEQ.N    ??enable_DMA_irq_15
   \   00000036   0xE03F             B.N      ??enable_DMA_irq_16
    237            {
    238              case 0:
    239              enable_irq(0);			      //开DMA通道0的IRQ中断
   \                     ??enable_DMA_irq_0: (+1)
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       enable_irq
    240              break;
   \   0000003E   0xE03B             B.N      ??enable_DMA_irq_17
    241              case 1:
    242              enable_irq(1);			      //开DMA通道1的IRQ中断
   \                     ??enable_DMA_irq_2: (+1)
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       enable_irq
    243              break;
   \   00000046   0xE037             B.N      ??enable_DMA_irq_17
    244              case 2:
    245              enable_irq(2);			     //开DMA通道2的IRQ中断
   \                     ??enable_DMA_irq_1: (+1)
   \   00000048   0x2002             MOVS     R0,#+2
   \   0000004A   0x.... 0x....      BL       enable_irq
    246              break;
   \   0000004E   0xE033             B.N      ??enable_DMA_irq_17
    247              case 3:
    248              enable_irq(3);			      //开DMA通道3的IRQ中断
   \                     ??enable_DMA_irq_4: (+1)
   \   00000050   0x2003             MOVS     R0,#+3
   \   00000052   0x.... 0x....      BL       enable_irq
    249              break;
   \   00000056   0xE02F             B.N      ??enable_DMA_irq_17
    250              case 4:
    251              enable_irq(4);			      //开DMA通道4的IRQ中断
   \                     ??enable_DMA_irq_3: (+1)
   \   00000058   0x2004             MOVS     R0,#+4
   \   0000005A   0x.... 0x....      BL       enable_irq
    252              break;
   \   0000005E   0xE02B             B.N      ??enable_DMA_irq_17
    253              case 5:
    254              enable_irq(5);			      //开DMA通道5的IRQ中断
   \                     ??enable_DMA_irq_6: (+1)
   \   00000060   0x2005             MOVS     R0,#+5
   \   00000062   0x.... 0x....      BL       enable_irq
    255              break;
   \   00000066   0xE027             B.N      ??enable_DMA_irq_17
    256              case 6:
    257              enable_irq(6);			     //开DMA通道6的IRQ中断
   \                     ??enable_DMA_irq_5: (+1)
   \   00000068   0x2006             MOVS     R0,#+6
   \   0000006A   0x.... 0x....      BL       enable_irq
    258              break;
   \   0000006E   0xE023             B.N      ??enable_DMA_irq_17
    259              case 7:
    260              enable_irq(7);			      //开DMA通道7的IRQ中断
   \                     ??enable_DMA_irq_8: (+1)
   \   00000070   0x2007             MOVS     R0,#+7
   \   00000072   0x.... 0x....      BL       enable_irq
    261              break;
   \   00000076   0xE01F             B.N      ??enable_DMA_irq_17
    262              case 8:
    263              enable_irq(8);			      //开DMA通道8的IRQ中断
   \                     ??enable_DMA_irq_7: (+1)
   \   00000078   0x2008             MOVS     R0,#+8
   \   0000007A   0x.... 0x....      BL       enable_irq
    264              break;
   \   0000007E   0xE01B             B.N      ??enable_DMA_irq_17
    265              case 9:
    266              enable_irq(9);			      //开DMA通道9的IRQ中断
   \                     ??enable_DMA_irq_10: (+1)
   \   00000080   0x2009             MOVS     R0,#+9
   \   00000082   0x.... 0x....      BL       enable_irq
    267              break;
   \   00000086   0xE017             B.N      ??enable_DMA_irq_17
    268              case 10:
    269              enable_irq(10);			     //开DMA通道10的IRQ中断
   \                     ??enable_DMA_irq_9: (+1)
   \   00000088   0x200A             MOVS     R0,#+10
   \   0000008A   0x.... 0x....      BL       enable_irq
    270              break;
   \   0000008E   0xE013             B.N      ??enable_DMA_irq_17
    271              case 11:
    272              enable_irq(11);			      //开DMA通道11的IRQ中断
   \                     ??enable_DMA_irq_12: (+1)
   \   00000090   0x200B             MOVS     R0,#+11
   \   00000092   0x.... 0x....      BL       enable_irq
    273              break;
   \   00000096   0xE00F             B.N      ??enable_DMA_irq_17
    274              case 12:
    275              enable_irq(12);			      //开DMA通道12的IRQ中断
   \                     ??enable_DMA_irq_11: (+1)
   \   00000098   0x200C             MOVS     R0,#+12
   \   0000009A   0x.... 0x....      BL       enable_irq
    276              break;
   \   0000009E   0xE00B             B.N      ??enable_DMA_irq_17
    277              case 13:
    278              enable_irq(13);			      //开DMA通道13的IRQ中断
   \                     ??enable_DMA_irq_14: (+1)
   \   000000A0   0x200D             MOVS     R0,#+13
   \   000000A2   0x.... 0x....      BL       enable_irq
    279              break;
   \   000000A6   0xE007             B.N      ??enable_DMA_irq_17
    280              case 14:
    281              enable_irq(14);			     //开DMA通道14的IRQ中断
   \                     ??enable_DMA_irq_13: (+1)
   \   000000A8   0x200E             MOVS     R0,#+14
   \   000000AA   0x.... 0x....      BL       enable_irq
    282              break;
   \   000000AE   0xE003             B.N      ??enable_DMA_irq_17
    283              case 15:
    284              enable_irq(15);			      //开DMA通道15的IRQ中断
   \                     ??enable_DMA_irq_15: (+1)
   \   000000B0   0x200F             MOVS     R0,#+15
   \   000000B2   0x.... 0x....      BL       enable_irq
    285              break;
   \   000000B6   0xE7FF             B.N      ??enable_DMA_irq_17
    286              
    287              default:
    288              break;
    289            }    
    290          }
   \                     ??enable_DMA_irq_16: (+1)
   \                     ??enable_DMA_irq_17: (+1)
   \   000000B8   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40048040         DC32     0x40048040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40009000         DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40008024         DC32     0x40008024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x4000800C         DC32     0x4000800c
    291          
    292          
    293          
    294          
    295          
    296          
    297          
    298          
    299          
    300          
    301          
    302          
    303          
    304          
    305          
    306          
    307          
    308          
    309          
    310          
    311          
    312          
    313          
    314          
    315          
    316          
    317          
    318          
    319          
    320          
    321          
    322          
    323          
    324          
    325          
    326          
    327          
    328          
    329          
    330          
    331          
    332          
    333          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMAInit
       8   enable_DMA_irq
         8   -> enable_irq


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       1  DMAFlag
     340  DMAInit
     186  enable_DMA_irq

 
   1 byte  in section .bss
 554 bytes in section .text
 
 554 bytes of CODE memory
   1 byte  of DATA memory

Errors: none
Warnings: none
