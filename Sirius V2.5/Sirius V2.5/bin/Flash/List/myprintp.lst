###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     16/Nov/2014  15:25:33 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\myprin #
#                    tp.c                                                     #
#    Command line =  "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\mypri #
#                    ntp.c" -D IAR -D TWR_K60N512 -lCN                        #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\" -lB     #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\" -o      #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\Obj\"          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.3\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "D:\IAR_TEST\Sirius\Sirius                     #
#                    V2.2\src\Sources\H\" -I "D:\IAR_TEST\Sirius\Sirius       #
#                    V2.2\src\Sources\H\Component_H\" -I                      #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\Frame_H\"  #
#                    -I "D:\IAR_TEST\Sirius\Sirius                            #
#                    V2.2\src\Sources\H\Function_H\" -I                       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\SD_H\"     #
#                    -Ol --use_c++_inline                                     #
#    List file    =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\myprintp.l #
#                    st                                                       #
#    Object file  =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\Obj\myprintp.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\myprintp.c
      1          #include	"myprintp.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int _LocaleC_isupper(int)
   \                     _LocaleC_isupper:
   \   00000000   0x3841             SUBS     R0,R0,#+65
   \   00000002   0x281A             CMP      R0,#+26
   \   00000004   0xD201             BCS.N    ??_LocaleC_isupper_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??_LocaleC_isupper_1
   \                     ??_LocaleC_isupper_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??_LocaleC_isupper_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int _LocaleC_tolower(int)
   \                     _LocaleC_tolower:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       _LocaleC_isupper
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??_LocaleC_tolower_0
   \   0000000E   0x3420             ADDS     R4,R4,#+32
   \   00000010   0xE7FF             B.N      ??_LocaleC_tolower_1
   \                     ??_LocaleC_tolower_0:
   \                     ??_LocaleC_tolower_1:
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int isdigit(int)
   \                     isdigit:
   \   00000000   0x3830             SUBS     R0,R0,#+48
   \   00000002   0x280A             CMP      R0,#+10
   \   00000004   0xD201             BCS.N    ??isdigit_0
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xE000             B.N      ??isdigit_1
   \                     ??isdigit_0:
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??isdigit_1:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp int tolower(int)
   \                     tolower:
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _LocaleC_tolower
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
      2          

   \                                 In section .bss, align 4
      3          PRINT_T PortToOut;
   \                     PortToOut:
   \   00000000                      DS8 4
      4          
      5          #ifdef	TRUE
      6          #define	TRUE	1
      7          #endif
      8          
      9          #ifdef	FALSE
     10          #define	FALSE	0
     11          #endif
     12          
     13          #define	CR_as_CRLF	TRUE        //true，可以使用"\n"表示回车，换行(CR/LF)
     14                                          //false,要使用"\n\r"表示回车，换行

   \                                 In section .bss, align 4
     15          static	int	do_padding;         //当需要输出填充字符时设置该标记
   \                     do_padding:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     16          static	int	left_flag;          //当输出数据左对齐时设置该标记
   \                     left_flag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     17          static	int	len;                //保存按格式输出的字符串的长度
   \                     len:
   \   00000000                      DS8 4
     18          /******************************************************************************
     19          当你不指定宽度的时候，程序自动根据数据库的大小来
     20          控制宽度。当你输出许多数据需要对齐的时候，可以使
     21          用指定宽度的办法，其余一般都不指定宽度的
     22          ******************************************************************************/

   \                                 In section .bss, align 4
     23          static	int	num1;               //保存格式控制符中点前的数字，
   \                     num1:
   \   00000000                      DS8 4
     24                                          //用作输出字段宽度

   \                                 In section .bss, align 4
     25          static	int	num2;               //保存格式控制符中点后的数字，
   \                     num2:
   \   00000000                      DS8 4
     26                                          //在输出字符串时作为
     27                                          //输出字符个数
     28          

   \                                 In section .bss, align 1
     29          static	char	pad_character;  //保存填充字符
   \                     pad_character:
   \   00000000                      DS8 1
     30          
     31          /******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     32          void Print_Init(PRINT_T *pPrint)
     33          {
     34          	PortToOut.m_printf =  pPrint->m_printf;
   \                     Print_Init:
   \   00000000   0x....             LDR.N    R1,??DataTable4
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6008             STR      R0,[R1, #+0]
     35          }
   \   00000006   0x4770             BX       LR               ;; return
     36          /******************************************************************************/
     37          /******************************************************************************
     38          以下函数输出填充字符:
     39          当输出数字时使用左对齐时，在数字右边输出填充字符；
     40          当输出数字时使用右对齐时，在数字左边输出填充字符。
     41          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     42          static	void	padding( const int l_flag)
     43          {
   \                     padding:
   \   00000000   0xB510             PUSH     {R4,LR}
     44          	int	i;
     45          
     46              if(do_padding && l_flag && (len < num1))
   \   00000002   0x....             LDR.N    R1,??DataTable4_1
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD014             BEQ.N    ??padding_0
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD012             BEQ.N    ??padding_0
   \   0000000E   0x....             LDR.N    R0,??DataTable4_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x....             LDR.N    R1,??DataTable4_3
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xDA0C             BGE.N    ??padding_0
     47              {
     48          		for(i = len; i < num1; i ++)
   \   0000001A   0x....             LDR.N    R0,??DataTable4_2
   \   0000001C   0x6804             LDR      R4,[R0, #+0]
   \   0000001E   0xE005             B.N      ??padding_1
     49                  {
     50          			PortToOut.m_printf(pad_character);
   \                     ??padding_2:
   \   00000020   0x....             LDR.N    R0,??DataTable4_4
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0x....             LDR.N    R1,??DataTable4
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x4788             BLX      R1
     51                  }
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \                     ??padding_1:
   \   0000002C   0x....             LDR.N    R0,??DataTable4_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x4284             CMP      R4,R0
   \   00000032   0xDBF5             BLT.N    ??padding_2
     52              }
     53          }
   \                     ??padding_0:
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
     54          
     55          /******************************************************************************
     56          根据填充标记do_padding,和填充标记位置标记l_flag,
     57          按照格式符指定的格式向输出端口输出字符串和填充字符
     58          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     59          static	void	outs(char *lp)
     60          {
   \                     outs:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     61          	len = strlen(lp);
   \   00000004   0x0020             MOVS     R0,R4
   \   00000006   0x.... 0x....      BL       strlen
   \   0000000A   0x....             LDR.N    R1,??DataTable4_2
   \   0000000C   0x6008             STR      R0,[R1, #+0]
     62          	padding(!left_flag);
   \   0000000E   0x....             LDR.N    R0,??DataTable4_5
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??outs_0
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE000             B.N      ??outs_1
   \                     ??outs_0:
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??outs_1:
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       padding
   \   00000022   0xE004             B.N      ??outs_2
     63          
     64          	while (*lp && num2 --)
     65          	{
     66          		PortToOut.m_printf(*lp ++);
   \                     ??outs_3:
   \   00000024   0x7820             LDRB     R0,[R4, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable4
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x4788             BLX      R1
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
     67          	}
   \                     ??outs_2:
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD006             BEQ.N    ??outs_4
   \   00000034   0x....             LDR.N    R0,??DataTable4_6
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x1E41             SUBS     R1,R0,#+1
   \   0000003A   0x....             LDR.N    R2,??DataTable4_6
   \   0000003C   0x6011             STR      R1,[R2, #+0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1F0             BNE.N    ??outs_3
     68          	
     69          	len = strlen(lp);
   \                     ??outs_4:
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       strlen
   \   00000048   0x....             LDR.N    R1,??DataTable4_2
   \   0000004A   0x6008             STR      R0,[R1, #+0]
     70          	padding(left_flag);
   \   0000004C   0x....             LDR.N    R0,??DataTable4_5
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x.... 0x....      BL       padding
     71          }
   \   00000054   0xBD10             POP      {R4,PC}          ;; return
     72          
     73          
     74          /******************************************************************************
     75          根据填充标记do_padding,和填充标记位置标记l_flag,
     76          按照格式符指定的格式（进制、有无符号、字段宽度、
     77          左右对齐等）向输出端口输出字符串和填充字符
     78          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     79          static void reoutnum(unsigned	long num, 
     80          					 unsigned	int negative, 
     81          					 const	long	base)
     82          
     83          {
   \                     reoutnum:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08D             SUB      SP,SP,#+52
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
     84          	char	*cp;
     85              char	outbuf[32];
     86          	const	char	digits[] = "0123456789ABCDEF";
   \   0000000A   0xA800             ADD      R0,SP,#+0
   \   0000000C   0x....             LDR.N    R1,??DataTable4_7
   \   0000000E   0x2214             MOVS     R2,#+20
   \   00000010   0x.... 0x....      BL       __aeabi_memcpy4
     87          
     88          	/*************************************************************
     89          	将需要输出的数字按照进制转换成ASCII码，
     90          	以倒序保存在outbuf数组中
     91          	*************************************************************/
     92          	cp = outbuf;
   \   00000014   0xAC05             ADD      R4,SP,#+20
     93          	do
     94          		{
     95          			*cp ++ = digits[(int)(num % base)];
   \                     ??reoutnum_0:
   \   00000016   0xFBB5 0xF0F7      UDIV     R0,R5,R7
   \   0000001A   0xFB07 0x5010      MLS      R0,R7,R0,R5
   \   0000001E   0xA900             ADD      R1,SP,#+0
   \   00000020   0x5C40             LDRB     R0,[R0, R1]
   \   00000022   0x7020             STRB     R0,[R4, #+0]
   \   00000024   0x1C64             ADDS     R4,R4,#+1
     96          		}while((num /= base) != 0);
   \   00000026   0xFBB5 0xF5F7      UDIV     R5,R5,R7
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD1F3             BNE.N    ??reoutnum_0
     97          
     98          	if(negative)
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD002             BEQ.N    ??reoutnum_1
     99          	{
    100          		*cp ++ = '-';			//如果是负数，在数组尾添加负号
   \   00000032   0x202D             MOVS     R0,#+45
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x1C64             ADDS     R4,R4,#+1
    101          	}
    102          
    103          	*cp -- = 0;					//为了使用strlen函数，数组尾部添加\0
   \                     ??reoutnum_1:
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
   \   0000003C   0x1E64             SUBS     R4,R4,#+1
    104          
    105          	
    106          	/************************************************************************
    107          	根据输出数字的对齐方式，在适当地方输出填充字符
    108          	，且保存在outbuf中的字符
    109          	*************************************************************************/
    110          	len = strlen(outbuf);
   \   0000003E   0xA805             ADD      R0,SP,#+20
   \   00000040   0x.... 0x....      BL       strlen
   \   00000044   0x....             LDR.N    R1,??DataTable4_2
   \   00000046   0x6008             STR      R0,[R1, #+0]
    111          	padding(!left_flag);
   \   00000048   0x....             LDR.N    R0,??DataTable4_5
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD101             BNE.N    ??reoutnum_2
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0xE000             B.N      ??reoutnum_3
   \                     ??reoutnum_2:
   \   00000054   0x2000             MOVS     R0,#+0
   \                     ??reoutnum_3:
   \   00000056   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000058   0x.... 0x....      BL       padding
   \   0000005C   0xE004             B.N      ??reoutnum_4
    112          
    113          	while(cp >= outbuf)
    114          	{
    115          		PortToOut.m_printf(*cp --);
   \                     ??reoutnum_5:
   \   0000005E   0x7820             LDRB     R0,[R4, #+0]
   \   00000060   0x....             LDR.N    R1,??DataTable4
   \   00000062   0x6809             LDR      R1,[R1, #+0]
   \   00000064   0x4788             BLX      R1
   \   00000066   0x1E64             SUBS     R4,R4,#+1
    116          	}
   \                     ??reoutnum_4:
   \   00000068   0xA805             ADD      R0,SP,#+20
   \   0000006A   0x4284             CMP      R4,R0
   \   0000006C   0xD2F7             BCS.N    ??reoutnum_5
    117          
    118          	padding(left_flag);  
   \   0000006E   0x....             LDR.N    R0,??DataTable4_5
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x.... 0x....      BL       padding
    119          }
   \   00000076   0xB00D             ADD      SP,SP,#+52
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
    120          
    121          
    122          /******************************************************************************
    123          主要先处理符号位，然后调用reoutnum函数
    124          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    125          static	void	outnum(long num,
    126          					   const long base, 
    127          					   unsigned char sign)
    128          {
   \                     outnum:
   \   00000000   0xB580             PUSH     {R7,LR}
    129          	unsigned	int	negative;
    130          
    131          	if((num < 0L) && sign)
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD505             BPL.N    ??outnum_0
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD002             BEQ.N    ??outnum_0
    132          	{
    133          		negative = 1;
   \   0000000C   0x2301             MOVS     R3,#+1
    134          		num = - num;
   \   0000000E   0x4240             RSBS     R0,R0,#+0
   \   00000010   0xE000             B.N      ??outnum_1
    135          	}
    136          	else negative = 0;
   \                     ??outnum_0:
   \   00000012   0x2300             MOVS     R3,#+0
    137          
    138          	reoutnum(num, negative, base);
   \                     ??outnum_1:
   \   00000014   0x000A             MOVS     R2,R1
   \   00000016   0x0019             MOVS     R1,R3
   \   00000018   0x.... 0x....      BL       reoutnum
    139          }
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    140          
    141          
    142          /******************************************************************************
    143          从格式字符串中取出数字（这些数字用来表示字段宽度等）
    144          ，而且将连续的ASCII码的数字作为十进制数字。
    145          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    146          static	int	getnum(char** linep)
    147          {
   \                     getnum:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    148          	int	n;
    149          	char*	cp;
    150          	
    151          	n = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    152          	cp = *linep;
   \   00000006   0x6826             LDR      R6,[R4, #+0]
   \   00000008   0xE006             B.N      ??getnum_0
    153          	while(isdigit(*cp))
    154          	{
    155          		n = n * 10 + ((*cp ++) - '0');
   \                     ??getnum_1:
   \   0000000A   0x200A             MOVS     R0,#+10
   \   0000000C   0x7831             LDRB     R1,[R6, #+0]
   \   0000000E   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000012   0xF1B0 0x0530      SUBS     R5,R0,#+48
   \   00000016   0x1C76             ADDS     R6,R6,#+1
    156          	}
   \                     ??getnum_0:
   \   00000018   0x7830             LDRB     R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       isdigit
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD1F3             BNE.N    ??getnum_1
    157          
    158          	*linep = cp;
   \   00000022   0x6026             STR      R6,[R4, #+0]
    159          	return(n);
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0xBD70             POP      {R4-R6,PC}       ;; return
    160          }
    161          
    162          
    163          /******************************************************************************
    164          按照格式字符串制定的要求，向端口输出数据,
    165          不是支持所有的标准C数据格式，它只支持嵌入式系统
    166          经常用到的格式,省略了浮点数据格式，
    167          按照已经支持的格式，别的格式可以很容易的被增加进去。
    168          ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          void	printp(char* ctrl, ...)
    170          {
   \                     printp:
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB5F8             PUSH     {R3-R7,LR}
    171          	int	long_flag;
    172          	int	dot_flag;
    173          
    174          	char	ch;			
    175          	va_list	argp;		//由于为可变参数函数，需要进行参数提取，
    176          						//argp依次只想各可变参数
    177          	va_start(argp, ctrl);
   \   00000004   0xAC07             ADD      R4,SP,#+28
   \   00000006   0xE00F             B.N      ??printp_0
    178          						//初始化argp,使它指向第一个可变参数
    179          	/*******************************************************************
    180          	ctrl将存在于堆栈中，作为遍历格式字符串的指针，
    181          	利用ctrl作为指针遍历格式字符串，
    182          	如果不是格式控制标记%，就进入下面的if结构，
    183          	将字符输出，然后跳出本次循环，
    184          	开始下次循环，即检查下一个字符；
    185          	如果是%，跳过if进行格式判断与数据输出
    186          	********************************************************************/
    187          	for( ; *ctrl; ctrl ++)
    188          	{
    189          		if (*ctrl != '%')
    190          		{
    191          		    PortToOut.m_printf(*ctrl);
   \                     ??printp_1:
   \   00000008   0x9806             LDR      R0,[SP, #+24]
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x....             LDR.N    R1,??DataTable4
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x4788             BLX      R1
    192          #if CR_as_CRLF == TRUE
    193          			if(*ctrl == '\n') PortToOut.m_printf('\r');
   \   00000012   0x9806             LDR      R0,[SP, #+24]
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x280A             CMP      R0,#+10
   \   00000018   0xD103             BNE.N    ??printp_2
   \   0000001A   0x200D             MOVS     R0,#+13
   \   0000001C   0x....             LDR.N    R1,??DataTable4
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x4788             BLX      R1
    194          #endif
    195          			continue;
    196          		}
   \                     ??printp_2:
   \                     ??printp_3:
   \   00000022   0x9806             LDR      R0,[SP, #+24]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x9006             STR      R0,[SP, #+24]
   \                     ??printp_0:
   \   00000028   0x9806             LDR      R0,[SP, #+24]
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xF000 0x80B6      BEQ.W    ??printp_4
   \   00000032   0x9806             LDR      R0,[SP, #+24]
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0x2825             CMP      R0,#+37
   \   00000038   0xD1E6             BNE.N    ??printp_1
    197          		/************************************************************
    198          		当遇到格式控制标记%时，程序将执行下面
    199          		的代码，先初始化所有的标记量
    200          		************************************************************/
    201          		dot_flag = 
    202          		long_flag =
    203                	left_flag  =
    204                	do_padding = 0;
   \   0000003A   0x2500             MOVS     R5,#+0
   \   0000003C   0x....             LDR.N    R0,??DataTable4_1
   \   0000003E   0x6005             STR      R5,[R0, #+0]
   \   00000040   0x....             LDR.N    R0,??DataTable4_5
   \   00000042   0x6005             STR      R5,[R0, #+0]
   \   00000044   0x002E             MOVS     R6,R5
    205                	pad_character = ' ';
   \   00000046   0x....             LDR.N    R0,??DataTable4_4
   \   00000048   0x2120             MOVS     R1,#+32
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
    206          		num2 = 32767;
   \   0000004C   0x....             LDR.N    R0,??DataTable4_6
   \   0000004E   0xF647 0x71FF      MOVW     R1,#+32767
   \   00000052   0x6001             STR      R1,[R0, #+0]
   \   00000054   0xE010             B.N      ??printp_5
    207          
    208          	try_next:
    209          		ch = *( ++ctrl);	//取得格式控制标记%或者数字、点、
    210          		                    //'-'、‘l’后的字符
    211          
    212          		if(isdigit(ch))		//判断是否为数字
    213          		{
    214          			if(dot_flag)	//判断数字是在点钱还是在点后，
    215          			                //若是在点前，该数字存入
    216          							//num1，点后存入num2
    217          			{
    218          				num2 = getnum(&ctrl);
    219          			}
    220          			else
    221          			{
    222          				if(ch == '0')
   \                     ??printp_6:
   \   00000056   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000058   0x2F30             CMP      R7,#+48
   \   0000005A   0xD102             BNE.N    ??printp_7
    223          				{
    224          					pad_character = '0';
   \   0000005C   0x....             LDR.N    R0,??DataTable4_4
   \   0000005E   0x2130             MOVS     R1,#+48
   \   00000060   0x7001             STRB     R1,[R0, #+0]
    225          				}
    226          
    227          				num1 = getnum(&ctrl);
   \                     ??printp_7:
   \   00000062   0xA806             ADD      R0,SP,#+24
   \   00000064   0x.... 0x....      BL       getnum
   \   00000068   0x....             LDR.N    R1,??DataTable4_3
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    228          				do_padding = 1;
   \   0000006C   0x....             LDR.N    R0,??DataTable4_1
   \   0000006E   0x2101             MOVS     R1,#+1
   \   00000070   0x6001             STR      R1,[R0, #+0]
    229          			}
    230          
    231          			ctrl --;
   \                     ??printp_8:
   \   00000072   0x9806             LDR      R0,[SP, #+24]
   \   00000074   0x1E40             SUBS     R0,R0,#+1
   \   00000076   0x9006             STR      R0,[SP, #+24]
    232          			goto try_next;
   \                     ??printp_5:
   \   00000078   0x9806             LDR      R0,[SP, #+24]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x9006             STR      R0,[SP, #+24]
   \   0000007E   0x7807             LDRB     R7,[R0, #+0]
   \   00000080   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000082   0x0038             MOVS     R0,R7
   \   00000084   0x.... 0x....      BL       isdigit
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD007             BEQ.N    ??printp_9
   \   0000008C   0x2E00             CMP      R6,#+0
   \   0000008E   0xD0E2             BEQ.N    ??printp_6
   \   00000090   0xA806             ADD      R0,SP,#+24
   \   00000092   0x.... 0x....      BL       getnum
   \   00000096   0x....             LDR.N    R1,??DataTable4_6
   \   00000098   0x6008             STR      R0,[R1, #+0]
   \   0000009A   0xE7EA             B.N      ??printp_8
    233          		}
    234          
    235          		switch(tolower(ch))	//判断格式控制字符，按照指定格式输出
   \                     ??printp_9:
   \   0000009C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009E   0x0038             MOVS     R0,R7
   \   000000A0   0x.... 0x....      BL       tolower
   \   000000A4   0x2825             CMP      R0,#+37
   \   000000A6   0xD00E             BEQ.N    ??printp_10
   \   000000A8   0x282D             CMP      R0,#+45
   \   000000AA   0xD011             BEQ.N    ??printp_11
   \   000000AC   0x282E             CMP      R0,#+46
   \   000000AE   0xD013             BEQ.N    ??printp_12
   \   000000B0   0x2858             CMP      R0,#+88
   \   000000B2   0xD03D             BEQ.N    ??printp_13
   \   000000B4   0x2863             CMP      R0,#+99
   \   000000B6   0xD069             BEQ.N    ??printp_14
   \   000000B8   0x2864             CMP      R0,#+100
   \   000000BA   0xD011             BEQ.N    ??printp_15
   \   000000BC   0x286C             CMP      R0,#+108
   \   000000BE   0xD00D             BEQ.N    ??printp_16
   \   000000C0   0x2873             CMP      R0,#+115
   \   000000C2   0xD05D             BEQ.N    ??printp_17
   \   000000C4   0xE06A             B.N      ??printp_18
    236          		                    //数据或者进一步判断输出格式
    237          		{
    238          			case	'%':	PortToOut.m_printf('%');
   \                     ??printp_10:
   \   000000C6   0x2025             MOVS     R0,#+37
   \   000000C8   0x....             LDR.N    R1,??DataTable4
   \   000000CA   0x6809             LDR      R1,[R1, #+0]
   \   000000CC   0x4788             BLX      R1
    239          			continue;
   \   000000CE   0xE7A8             B.N      ??printp_3
    240          			case	'-':	left_flag = 1;
   \                     ??printp_11:
   \   000000D0   0x....             LDR.N    R0,??DataTable4_5
   \   000000D2   0x2101             MOVS     R1,#+1
   \   000000D4   0x6001             STR      R1,[R0, #+0]
    241          			break;
    242          			case	'.':	dot_flag = 1;
    243          			break;
    244          			case	'l':	long_flag = 1;
    245          			break;
    246          			case	'd':	
    247          				if ( long_flag == 1)
    248          				{
    249          					if( ch == 'D')		//长整形、无符号
    250          					{
    251          						outnum(va_arg(argp, unsigned long), 10L, 0);
    252          						continue;
    253          					}
    254          					else				//长整形、有符号
    255          					{
    256          						outnum(va_arg(argp, long), 10L, 1);
    257          						continue;
    258          					}
    259          				}
    260          				else
    261          				{
    262          					if( ch == 'D')		//整形、无符号
    263          					{
    264          						outnum(va_arg(argp, unsigned int), 10L, 0);
    265          						continue;
    266          					}
    267          					else				//整形、有符号
    268          					{
    269          						outnum(va_arg(argp, int), 10L, 1);
    270          						continue;
    271          					}
    272          				}
    273          			case	'X':	
    274          				if ( long_flag == 1)
    275          				{
    276          					if ( ch == 'X')		//长16进制、无符号
    277          					{
    278          						outnum(va_arg(argp, unsigned long), 16L, 0);
    279          						continue;
    280          					}
    281          					else				//长16进制、有符号
    282          					{
    283          						outnum(va_arg(argp, long), 16L, 1);
    284          						continue;
    285          					}
    286          				} 
    287          				else
    288          				{
    289          					if ( ch == 'X')		//短16进制、无符号
    290          					{
    291          						outnum(va_arg(argp, unsigned int), 16L, 0);
    292          						continue;
    293          					} 
    294          					else				//短16进制、有符号
    295          					{
    296          						outnum(va_arg(argp,	int), 16L, 1);
    297          						continue;
    298          					}
    299          				}
    300          
    301          			case	's':				//输出字符串
    302          				outs(va_arg(argp, char*));
    303          				continue;
    304          
    305          			case	'c':				//输出字符
    306          				PortToOut.m_printf(va_arg(argp , int));
    307          				continue;
    308          		
    309          			default:
    310          				continue;
    311          		}
    312          		goto	try_next;				//当多个字符控制格式时，
   \                     ??printp_19:
   \   000000D6   0xE7CF             B.N      ??printp_5
   \                     ??printp_12:
   \   000000D8   0x2601             MOVS     R6,#+1
   \   000000DA   0xE7FC             B.N      ??printp_19
   \                     ??printp_16:
   \   000000DC   0x2501             MOVS     R5,#+1
   \   000000DE   0xE7FA             B.N      ??printp_19
   \                     ??printp_15:
   \   000000E0   0x2D01             CMP      R5,#+1
   \   000000E2   0xD112             BNE.N    ??printp_20
   \   000000E4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E6   0x2F44             CMP      R7,#+68
   \   000000E8   0xD107             BNE.N    ??printp_21
   \   000000EA   0x0020             MOVS     R0,R4
   \   000000EC   0x1D04             ADDS     R4,R0,#+4
   \   000000EE   0x2200             MOVS     R2,#+0
   \   000000F0   0x210A             MOVS     R1,#+10
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x.... 0x....      BL       outnum
   \   000000F8   0xE793             B.N      ??printp_3
   \                     ??printp_21:
   \   000000FA   0x0020             MOVS     R0,R4
   \   000000FC   0x1D04             ADDS     R4,R0,#+4
   \   000000FE   0x2201             MOVS     R2,#+1
   \   00000100   0x210A             MOVS     R1,#+10
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x.... 0x....      BL       outnum
   \   00000108   0xE78B             B.N      ??printp_3
   \                     ??printp_20:
   \   0000010A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000010C   0x2F44             CMP      R7,#+68
   \   0000010E   0xD107             BNE.N    ??printp_22
   \   00000110   0x0020             MOVS     R0,R4
   \   00000112   0x1D04             ADDS     R4,R0,#+4
   \   00000114   0x2200             MOVS     R2,#+0
   \   00000116   0x210A             MOVS     R1,#+10
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x.... 0x....      BL       outnum
   \   0000011E   0xE780             B.N      ??printp_3
   \                     ??printp_22:
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x1D04             ADDS     R4,R0,#+4
   \   00000124   0x2201             MOVS     R2,#+1
   \   00000126   0x210A             MOVS     R1,#+10
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x.... 0x....      BL       outnum
   \   0000012E   0xE778             B.N      ??printp_3
   \                     ??printp_13:
   \   00000130   0x2D01             CMP      R5,#+1
   \   00000132   0xD112             BNE.N    ??printp_23
   \   00000134   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000136   0x2F58             CMP      R7,#+88
   \   00000138   0xD107             BNE.N    ??printp_24
   \   0000013A   0x0020             MOVS     R0,R4
   \   0000013C   0x1D04             ADDS     R4,R0,#+4
   \   0000013E   0x2200             MOVS     R2,#+0
   \   00000140   0x2110             MOVS     R1,#+16
   \   00000142   0x6800             LDR      R0,[R0, #+0]
   \   00000144   0x.... 0x....      BL       outnum
   \   00000148   0xE76B             B.N      ??printp_3
   \                     ??printp_24:
   \   0000014A   0x0020             MOVS     R0,R4
   \   0000014C   0x1D04             ADDS     R4,R0,#+4
   \   0000014E   0x2201             MOVS     R2,#+1
   \   00000150   0x2110             MOVS     R1,#+16
   \   00000152   0x6800             LDR      R0,[R0, #+0]
   \   00000154   0x.... 0x....      BL       outnum
   \   00000158   0xE763             B.N      ??printp_3
   \                     ??printp_23:
   \   0000015A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000015C   0x2F58             CMP      R7,#+88
   \   0000015E   0xD107             BNE.N    ??printp_25
   \   00000160   0x0020             MOVS     R0,R4
   \   00000162   0x1D04             ADDS     R4,R0,#+4
   \   00000164   0x2200             MOVS     R2,#+0
   \   00000166   0x2110             MOVS     R1,#+16
   \   00000168   0x6800             LDR      R0,[R0, #+0]
   \   0000016A   0x.... 0x....      BL       outnum
   \   0000016E   0xE758             B.N      ??printp_3
   \                     ??printp_25:
   \   00000170   0x0020             MOVS     R0,R4
   \   00000172   0x1D04             ADDS     R4,R0,#+4
   \   00000174   0x2201             MOVS     R2,#+1
   \   00000176   0x2110             MOVS     R1,#+16
   \   00000178   0x6800             LDR      R0,[R0, #+0]
   \   0000017A   0x.... 0x....      BL       outnum
   \   0000017E   0xE750             B.N      ??printp_3
   \                     ??printp_17:
   \   00000180   0x0020             MOVS     R0,R4
   \   00000182   0x1D04             ADDS     R4,R0,#+4
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0x.... 0x....      BL       outs
   \   0000018A   0xE74A             B.N      ??printp_3
   \                     ??printp_14:
   \   0000018C   0x0020             MOVS     R0,R4
   \   0000018E   0x1D04             ADDS     R4,R0,#+4
   \   00000190   0x6800             LDR      R0,[R0, #+0]
   \   00000192   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000194   0x....             LDR.N    R1,??DataTable4
   \   00000196   0x6809             LDR      R1,[R1, #+0]
   \   00000198   0x4788             BLX      R1
   \   0000019A   0xE742             B.N      ??printp_3
   \                     ??printp_18:
   \   0000019C   0xE741             B.N      ??printp_3
    313          		                                //能执行到这个语句
    314          
    315          	}				//for循环结束
    316          
    317          	va_end( argp);						//结束可变参数提取
    318          }
   \                     ??printp_4:
   \   0000019E   0xBCF1             POP      {R0,R4-R7}
   \   000001A0   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     PortToOut

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     do_padding

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     len

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     num1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     pad_character

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     left_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     num2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     `?<Constant "0123456789ABCDEF">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "0123456789ABCDEF">`:
   \   00000000   0x30 0x31          DC8 "0123456789ABCDEF"
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  Print_Init
        0  _LocaleC_isupper
        8  _LocaleC_tolower
              8 -> _LocaleC_isupper
       16  getnum
             16 -> isdigit
        0  isdigit
        8  outnum
              8 -> reoutnum
        8  outs
              8 -- Indirect call
              8 -> padding
              8 -> strlen
        8  padding
              8 -- Indirect call
       40  printp
             40 -- Indirect call
             40 -> getnum
             40 -> isdigit
             40 -> outnum
             40 -> outs
             40 -> tolower
       72  reoutnum
             72 -- Indirect call
             72 -> __aeabi_memcpy4
             72 -> padding
             72 -> strlen
        8  tolower
              8 -> _LocaleC_tolower


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      20  ?<Constant "0123456789ABCDEF">
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  PortToOut
       8  Print_Init
      16  _LocaleC_isupper
      22  _LocaleC_tolower
       4  do_padding
      40  getnum
      16  isdigit
       4  left_flag
       4  len
       4  num1
       4  num2
      30  outnum
      86  outs
       1  pad_character
      54  padding
     420  printp
     122  reoutnum
       8  tolower

 
  25 bytes in section .bss
  20 bytes in section .rodata
 854 bytes in section .text
 
 792 bytes of CODE  memory (+ 62 bytes shared)
  20 bytes of CONST memory
  25 bytes of DATA  memory

Errors: none
Warnings: none
