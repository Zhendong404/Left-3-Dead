###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     16/Nov/2014  15:25:34 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\spi.c  #
#    Command line =  "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\spi.c #
#                    " -D IAR -D TWR_K60N512 -lCN "D:\IAR_TEST\Sirius\Sirius  #
#                    V2.2\bin\Flash\List\" -lB "D:\IAR_TEST\Sirius\Sirius     #
#                    V2.2\bin\Flash\List\" -o "D:\IAR_TEST\Sirius\Sirius      #
#                    V2.2\bin\Flash\Obj\" --no_cse --no_unroll --no_inline    #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.3\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "D:\IAR_TEST\Sirius\Sirius                     #
#                    V2.2\src\Sources\H\" -I "D:\IAR_TEST\Sirius\Sirius       #
#                    V2.2\src\Sources\H\Component_H\" -I                      #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\Frame_H\"  #
#                    -I "D:\IAR_TEST\Sirius\Sirius                            #
#                    V2.2\src\Sources\H\Function_H\" -I                       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\SD_H\"     #
#                    -Ol --use_c++_inline                                     #
#    List file    =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\spi.lst    #
#    Object file  =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\Obj\spi.o       #
#                                                                             #
#                                                                             #
###############################################################################

D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\spi.c
      1          #include "spi.h"
      2          
      3          
      4          //=================内部函数声明=============================================
      5          
      6          //=========================================================================
      7          //函数名称：hw_spi_get_base_address                                                        
      8          //功能概要：获取SPI寄存器的基址                                                
      9          //参数说明：spiNo:SPI号      
     10          //函数返回：SPI的基址值                                                                  
     11          //=========================================================================
     12          SPI_MemMapPtr hw_spi_get_base_address(uint8 spiNo);
     13          
     14          //=================接口函数实现=============================================
     15          
     16          //=========================================================================
     17          //函数名称：hw_spi_init
     18          //函数参数：spiNo：SPI通道号。
     19          //          Master:是否是主机。
     20          //函数返回：无
     21          //功能概要：SPI初始化。
     22          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
     23          void hw_spi_init(uint8 spiNo,uint8 master)
     24          {
   \                     hw_spi_init:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
     25              SPI_MemMapPtr BaseAdd = hw_spi_get_base_address(spiNo);
   \   00000006   0x0028             MOVS     R0,R5
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x.... 0x....      BL       hw_spi_get_base_address
     26              
     27              //使能SPI模块时钟，配置SPI引脚功能
     28              if(spiNo == 0)
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD116             BNE.N    ??hw_spi_init_0
     29              {
     30                  SIM_SCGC6 |= SIM_SCGC6_DSPI0_MASK;
   \   00000014   0x....             LDR.N    R1,??DataTable5  ;; 0x4004803c
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   0000001C   0x....             LDR.N    R2,??DataTable5  ;; 0x4004803c
   \   0000001E   0x6011             STR      R1,[R2, #+0]
     31                  PORTA_PCR14 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//PCS0
   \   00000020   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40049038
   \   00000022   0xF44F 0x7210      MOV      R2,#+576
   \   00000026   0x600A             STR      R2,[R1, #+0]
     32                  PORTA_PCR15 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SCK
   \   00000028   0x....             LDR.N    R1,??DataTable5_2  ;; 0x4004903c
   \   0000002A   0xF44F 0x7210      MOV      R2,#+576
   \   0000002E   0x600A             STR      R2,[R1, #+0]
     33                  PORTA_PCR16 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SOUT
   \   00000030   0x....             LDR.N    R1,??DataTable5_3  ;; 0x40049040
   \   00000032   0xF44F 0x7210      MOV      R2,#+576
   \   00000036   0x600A             STR      R2,[R1, #+0]
     34                  PORTA_PCR17 = 0 | PORT_PCR_MUX(0x2);//SIN
   \   00000038   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40049044
   \   0000003A   0xF44F 0x7200      MOV      R2,#+512
   \   0000003E   0x600A             STR      R2,[R1, #+0]
   \   00000040   0xE01F             B.N      ??hw_spi_init_1
     35              }
     36              else if(spiNo == 1)
   \                     ??hw_spi_init_0:
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x2D01             CMP      R5,#+1
   \   00000046   0xD116             BNE.N    ??hw_spi_init_2
     37              {
     38                  SIM_SCGC6 |= SIM_SCGC6_SPI1_MASK;
   \   00000048   0x....             LDR.N    R1,??DataTable5  ;; 0x4004803c
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0xF451 0x5100      ORRS     R1,R1,#0x2000
   \   00000050   0x....             LDR.N    R2,??DataTable5  ;; 0x4004803c
   \   00000052   0x6011             STR      R1,[R2, #+0]
     39                  PORTE_PCR1 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SOUT
   \   00000054   0x....             LDR.N    R1,??DataTable5_5  ;; 0x4004d004
   \   00000056   0xF44F 0x7210      MOV      R2,#+576
   \   0000005A   0x600A             STR      R2,[R1, #+0]
     40                  PORTE_PCR2 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SCK
   \   0000005C   0x....             LDR.N    R1,??DataTable5_6  ;; 0x4004d008
   \   0000005E   0xF44F 0x7210      MOV      R2,#+576
   \   00000062   0x600A             STR      R2,[R1, #+0]
     41                  PORTE_PCR3 = 0 | PORT_PCR_MUX(0x2);//SIN
   \   00000064   0x....             LDR.N    R1,??DataTable5_7  ;; 0x4004d00c
   \   00000066   0xF44F 0x7200      MOV      R2,#+512
   \   0000006A   0x600A             STR      R2,[R1, #+0]
     42                  PORTE_PCR4 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//PCS0
   \   0000006C   0x....             LDR.N    R1,??DataTable5_8  ;; 0x4004d010
   \   0000006E   0xF44F 0x7210      MOV      R2,#+576
   \   00000072   0x600A             STR      R2,[R1, #+0]
   \   00000074   0xE005             B.N      ??hw_spi_init_1
     43              }
     44              else 
     45              {
     46                  SIM_SCGC3 |= SIM_SCGC3_SPI2_MASK;
   \                     ??hw_spi_init_2:
   \   00000076   0x....             LDR.N    R1,??DataTable5_9  ;; 0x40048030
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0xF451 0x5180      ORRS     R1,R1,#0x1000
   \   0000007E   0x....             LDR.N    R2,??DataTable5_9  ;; 0x40048030
   \   00000080   0x6011             STR      R1,[R2, #+0]
     47              }
     48              
     49              SPI_MCR_REG(BaseAdd) = 0 
     50                           | SPI_MCR_CLR_TXF_MASK     //Clear the Tx FIFO counter.
     51                           | SPI_MCR_CLR_RXF_MASK     //Clear the Rx FIFO counter.
     52                           | SPI_MCR_PCSIS_MASK
     53                           | SPI_MCR_HALT_MASK;
   \                     ??hw_spi_init_1:
   \   00000082   0x....             LDR.N    R1,??DataTable5_10  ;; 0x3f0c01
   \   00000084   0x6001             STR      R1,[R0, #+0]
     54          
     55              //根据主从机模式设置工作模式
     56              if(master == MASTER)
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD106             BNE.N    ??hw_spi_init_3
     57              {
     58                  SPI_MCR_REG(BaseAdd) |= SPI_MCR_MSTR_MASK;//在开始要先停止传输
   \   0000008C   0x6801             LDR      R1,[R0, #+0]
   \   0000008E   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \   00000092   0x6001             STR      R1,[R0, #+0]
     59                  SPI_CTAR_REG(BaseAdd,0) = 0
     60                                 | SPI_CTAR_DBR_MASK
     61                                 | SPI_CTAR_FMSZ(0x08)
     62                                 | SPI_CTAR_PDT_MASK//延时因子为7  可以改小点 就是每次传输完成之后立马下一次
     63                                 | SPI_CTAR_BR(0)//2分频
     64                                 | SPI_CTAR_CPOL_MASK 
     65                                 | SPI_CTAR_CPHA_MASK;
   \   00000094   0x....             LDR.N    R1,??DataTable5_11  ;; 0xc60c0000
   \   00000096   0x60C1             STR      R1,[R0, #+12]
   \   00000098   0xE002             B.N      ??hw_spi_init_4
     66              }
     67              else
     68              {
     69                  SPI_CTAR_SLAVE_REG(BaseAdd,0) = 0 
     70                                      | SPI_CTAR_SLAVE_FMSZ(0x08)
     71                                      | SPI_CTAR_SLAVE_CPOL_MASK 
     72                                      | SPI_CTAR_SLAVE_CPHA_MASK; 
   \                     ??hw_spi_init_3:
   \   0000009A   0xF05F 0x418C      MOVS     R1,#+1174405120
   \   0000009E   0x60C1             STR      R1,[R0, #+12]
     73              }
     74           
     75              SPI_SR_REG(BaseAdd) = (SPI_SR_EOQF_MASK
     76                                   | SPI_SR_TFUF_MASK
     77                                   | SPI_SR_TFFF_MASK
     78                                   | SPI_SR_RFOF_MASK
     79                                   | SPI_SR_RFDF_MASK);
   \                     ??hw_spi_init_4:
   \   000000A0   0x....             LDR.N    R1,??DataTable5_12  ;; 0x1a0a0000
   \   000000A2   0x62C1             STR      R1,[R0, #+44]
     80              
     81              SPI_MCR_REG(BaseAdd) &= ~SPI_MCR_HALT_MASK;
   \   000000A4   0x6801             LDR      R1,[R0, #+0]
   \   000000A6   0x0849             LSRS     R1,R1,#+1
   \   000000A8   0x0049             LSLS     R1,R1,#+1
   \   000000AA   0x6001             STR      R1,[R0, #+0]
     82          }
   \   000000AC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
     83          
     84          
     85          //=========================================================================
     86          //函数名称：hw_spi_send
     87          //函数参数：spiNo：SPI通道号。
     88          //          data[]：需要发送的数据。
     89          //          len：数据长度。
     90          //函数返回：无
     91          //功能概要：SPI发送数据。
     92          //=========================================================================
     93          //uint32 hw_spi_send(uint8 spiNo,uint8 data[],uint32 len)

   \                                 In section .text, align 2, keep-with-next
     94          uint32 SPI_ReadWriteByte(uint8 spiNo,unsigned char buffer)
     95          {
   \                     SPI_ReadWriteByte:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
     96              //uint32 i = 0;
     97              uint32 RX_Data;
     98              SPI_MemMapPtr BaseAdd = hw_spi_get_base_address(spiNo);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       hw_spi_get_base_address
     99              
    100              SPI_SR_REG(BaseAdd) = (SPI_SR_EOQF_MASK
    101                   | SPI_SR_TFUF_MASK
    102                   | SPI_SR_TFFF_MASK
    103                   | SPI_SR_RFOF_MASK
    104                   | SPI_SR_RFDF_MASK)
    105                ;
   \   0000000A   0x....             LDR.N    R1,??DataTable5_12  ;; 0x1a0a0000
   \   0000000C   0x62C1             STR      R1,[R0, #+44]
    106              SPI_MCR_REG(BaseAdd) |= SPI_MCR_CLR_TXF_MASK | SPI_MCR_CLR_RXF_MASK  ;
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF451 0x6140      ORRS     R1,R1,#0xC00
   \   00000014   0x6001             STR      R1,[R0, #+0]
    107          #if 0              
    108              for(i = 0;i < len;i++)
    109              {
    110                  if(i == (len - 1))
    111                  {
    112                          SPI_PUSHR_REG(BaseAdd) = 0 
    113                                         | SPI_PUSHR_CTAS(0)
    114                                         | SPI_PUSHR_EOQ_MASK
    115                                         | SPI_PUSHR_PCS(1)
    116                                         | SPI_PUSHR_TXDATA(data[i]);
    117                  }
    118                  else
    119                  {
    120                          SPI_PUSHR_REG(BaseAdd) = 0 | SPI_PUSHR_CONT_MASK 
    121                                         | SPI_PUSHR_CTAS(0)
    122                                         | SPI_PUSHR_PCS(1)
    123                                         | SPI_PUSHR_TXDATA(data[i]);
    124                  }
    125              }
    126          #endif
    127              
    128          #if 1
    129              SPI_SR_REG(BaseAdd) |= SPI_SR_TCF_MASK;                         //清除发送完成标志
   \   00000016   0x6AC1             LDR      R1,[R0, #+44]
   \   00000018   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \   0000001C   0x62C1             STR      R1,[R0, #+44]
    130              
    131              SPI_PUSHR_REG(BaseAdd) = (SPI_PUSHR_CTAS(0)                     //选择CTAR0寄存器定义传输特性
    132                                    | SPI_PUSHR_EOQ_MASK                      //该帧SPI数据是最后一帧数据
    133                                    | SPI_PUSHR_TXDATA(buffer));              //写入数据
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0xF054 0x6100      ORRS     R1,R4,#0x8000000
   \   00000024   0x6341             STR      R1,[R0, #+52]
    134              
    135              SPI_MCR_REG(BaseAdd) &= ~SPI_MCR_HALT_MASK;                     //启动SPI数据传输
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x0849             LSRS     R1,R1,#+1
   \   0000002A   0x0049             LSLS     R1,R1,#+1
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    136              
    137              while((SPI_SR_REG(BaseAdd) & SPI_SR_TCF_MASK) == 0);            //等待发送完成
   \                     ??SPI_ReadWriteByte_0:
   \   0000002E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000030   0x2900             CMP      R1,#+0
   \   00000032   0xD5FC             BPL.N    ??SPI_ReadWriteByte_0
    138          
    139          #endif
    140            
    141              SPI_SR_REG(BaseAdd) |= SPI_SR_TCF_MASK;                         //清除传送完成标志
   \   00000034   0x6AC1             LDR      R1,[R0, #+44]
   \   00000036   0xF051 0x4100      ORRS     R1,R1,#0x80000000
   \   0000003A   0x62C1             STR      R1,[R0, #+44]
    142              
    143              while((SPI_SR_REG(BaseAdd) & SPI_SR_RFDF_MASK) == 0);           //等待接收缓冲区有有效数据，即等待RX FIFO不为空为止
   \                     ??SPI_ReadWriteByte_1:
   \   0000003C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000003E   0x0389             LSLS     R1,R1,#+14
   \   00000040   0xD5FC             BPL.N    ??SPI_ReadWriteByte_1
    144              
    145              RX_Data = (uint8)SPI_POPR_REG(BaseAdd);                         //读取RX FIFO内部数据
   \   00000042   0x6B81             LDR      R1,[R0, #+56]
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
    146              
    147              SPI_SR_REG(BaseAdd) |= SPI_SR_RFDF_MASK;                        //清除RX FIFO不为空标志
   \   00000046   0x6AC2             LDR      R2,[R0, #+44]
   \   00000048   0xF452 0x3200      ORRS     R2,R2,#0x20000
   \   0000004C   0x62C2             STR      R2,[R0, #+44]
    148              
    149              SPI_MCR_REG(BaseAdd) |= SPI_MCR_HALT_MASK;                      //停止SPI数据传输
   \   0000004E   0x6802             LDR      R2,[R0, #+0]
   \   00000050   0xF052 0x0201      ORRS     R2,R2,#0x1
   \   00000054   0x6002             STR      R2,[R0, #+0]
    150              
    151              return (RX_Data);
   \   00000056   0x0008             MOVS     R0,R1
   \   00000058   0xBD10             POP      {R4,PC}          ;; return
    152          
    153          }
    154          
    155          //=========================================================================
    156          //函数名称：hw_spi_re
    157          //函数参数：spiNo：SPI通道号。
    158          //          data[]：需要接收的数据。
    159          //函数返回：0：成功 1：失败
    160          //功能概要：SPI接收数据。
    161          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    162          uint8 hw_spi_re(uint8 spiNo,uint8 data[])
    163          {
   \                     hw_spi_re:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x000C             MOVS     R4,R1
    164                SPI_MemMapPtr BaseAdd = hw_spi_get_base_address(spiNo);
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x.... 0x....      BL       hw_spi_get_base_address
    165          
    166                if(SPI_SR_REG(BaseAdd) & SPI_SR_RFDF_MASK)
   \   0000000A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000000C   0x0389             LSLS     R1,R1,#+14
   \   0000000E   0xD507             BPL.N    ??hw_spi_re_0
    167                {
    168              	      data[0] = (uint8)SPI_POPR_REG(BaseAdd);                
   \   00000010   0x6B81             LDR      R1,[R0, #+56]
   \   00000012   0x7021             STRB     R1,[R4, #+0]
    169                        SPI_SR_REG(BaseAdd) |= SPI_SR_RFDF_MASK;
   \   00000014   0x6AC1             LDR      R1,[R0, #+44]
   \   00000016   0xF451 0x3100      ORRS     R1,R1,#0x20000
   \   0000001A   0x62C1             STR      R1,[R0, #+44]
    170                        return 1;
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE006             B.N      ??hw_spi_re_1
    171                }
    172                  SPI_SR_REG(BaseAdd) = (SPI_SR_EOQF_MASK
    173                                        | SPI_SR_TFUF_MASK
    174                                        | SPI_SR_TFFF_MASK
    175                                        | SPI_SR_RFOF_MASK
    176                                        | SPI_SR_RFDF_MASK);
   \                     ??hw_spi_re_0:
   \   00000020   0x....             LDR.N    R1,??DataTable5_12  ;; 0x1a0a0000
   \   00000022   0x62C1             STR      R1,[R0, #+44]
    177          
    178                SPI_MCR_REG(BaseAdd) |= SPI_MCR_CLR_TXF_MASK      //Clear the Tx FIFO counter.
    179                          | SPI_MCR_CLR_RXF_MASK;                 //Clear the Rx FIFO counter.
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0xF451 0x6140      ORRS     R1,R1,#0xC00
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    180                return 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??hw_spi_re_1:
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    181          }
    182          
    183          /*
    184          //=========================================================================
    185          //函数名称：hw_spi_enable_re_int
    186          //参数说明：spiNo: SPI号
    187          //函数返回： 无
    188          //功能概要：开SPI接收中断
    189          //=========================================================================
    190          void hw_spi_enable_re_int(uint8 spiNo)
    191          {
    192              SPI_MemMapPtr BaseAdd = hw_spi_get_base_address(spiNo);
    193              BSET(SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_REG(BaseAdd));//开放SPI接收中断
    194              enable_irq(spiNo + SPI0IRQ);			 //开接收引脚的IRQ中断
    195          }
    196          
    197          //=========================================================================
    198          //函数名称：hw_spi_disable_re_int
    199          //参数说明：spiNo: SPI号
    200          //函数返回： 无
    201          //功能概要：关SPI接收中断
    202          //=========================================================================
    203          void hw_spi_disable_re_int(uint8 spiNo)
    204          {
    205              SPI_MemMapPtr BaseAdd = hw_spi_get_base_address(spiNo);
    206              BCLR(SPI_RSER_RFDF_RE_SHIFT, SPI_RSER_REG(BaseAdd));//关闭SPI接收中断
    207              disable_irq(spiNo + SPI0IRQ);			 //开接收引脚的IRQ中断
    208          }
    209          */
    210          
    211          
    212          
    213          
    214          //=================内部函数实现=============================================
    215          //=========================================================================
    216          //函数名称：hw_spi_get_base_address
    217          //函数参数：spiNo：SPI通道号
    218          //函数返回：无
    219          //功能概要：将SPI通道号转换成对应基指针。
    220          //=========================================================================

   \                                 In section .text, align 2, keep-with-next
    221          SPI_MemMapPtr hw_spi_get_base_address(uint8 spiNo)
    222          {
    223              switch(spiNo)
   \                     hw_spi_get_base_address:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD003             BEQ.N    ??hw_spi_get_base_address_0
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD005             BEQ.N    ??hw_spi_get_base_address_1
   \   0000000A   0xD302             BCC.N    ??hw_spi_get_base_address_2
   \   0000000C   0xE005             B.N      ??hw_spi_get_base_address_3
    224              {
    225              case 0:
    226                return SPI0_BASE_PTR;
   \                     ??hw_spi_get_base_address_0:
   \   0000000E   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4002c000
   \   00000010   0xE004             B.N      ??hw_spi_get_base_address_4
    227              case 1:
    228                return SPI1_BASE_PTR;
   \                     ??hw_spi_get_base_address_2:
   \   00000012   0x....             LDR.N    R0,??DataTable5_14  ;; 0x4002d000
   \   00000014   0xE002             B.N      ??hw_spi_get_base_address_4
    229              case 2:
    230                return SPI2_BASE_PTR;
   \                     ??hw_spi_get_base_address_1:
   \   00000016   0x....             LDR.N    R0,??DataTable5_15  ;; 0x400ac000
   \   00000018   0xE000             B.N      ??hw_spi_get_base_address_4
    231              default:
    232                return 0;
   \                     ??hw_spi_get_base_address_3:
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??hw_spi_get_base_address_4:
   \   0000001C   0x4770             BX       LR               ;; return
    233              }
    234          }
    235          //void lqspiinit(void)

   \                                 In section .text, align 2, keep-with-next
    236          void SPI_Configuration(void)
    237          {
   \                     SPI_Configuration:
   \   00000000   0xB580             PUSH     {R7,LR}
    238            ///先把时钟引脚打开
    239                  SIM_SCGC6 |= SIM_SCGC6_DSPI0_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable5  ;; 0x4004803c
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   0000000A   0x....             LDR.N    R1,??DataTable5  ;; 0x4004803c
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    240               //   PORTA_PCR14 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//PCS0
    241                  gpio_init(PTA_BASE_PTR,13,1,0);
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2201             MOVS     R2,#+1
   \   00000012   0x210D             MOVS     R1,#+13
   \   00000014   0x....             LDR.N    R0,??DataTable5_16  ;; 0x400ff000
   \   00000016   0x.... 0x....      BL       gpio_init
    242                  PORTA_PCR15 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SCK
   \   0000001A   0x....             LDR.N    R0,??DataTable5_2  ;; 0x4004903c
   \   0000001C   0xF44F 0x7110      MOV      R1,#+576
   \   00000020   0x6001             STR      R1,[R0, #+0]
    243                  PORTA_PCR16 = 0 | PORT_PCR_MUX(0x2) | PORT_PCR_DSE_MASK;//SOUT
   \   00000022   0x....             LDR.N    R0,??DataTable5_3  ;; 0x40049040
   \   00000024   0xF44F 0x7110      MOV      R1,#+576
   \   00000028   0x6001             STR      R1,[R0, #+0]
    244                  PORTA_PCR17 = 0 | PORT_PCR_MUX(0x2);                    //SIN
   \   0000002A   0x....             LDR.N    R0,??DataTable5_4  ;; 0x40049044
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x6001             STR      R1,[R0, #+0]
    245                  SPI0_MCR|=SPI_MCR_MSTR_MASK;                            //主机模式
   \   00000032   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4002c000
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000003A   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4002c000
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    246          	    SPI0_MCR|=SPI_MCR_PCSIS(1);                             //PCS0低电平有效
   \   0000003E   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4002c000
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000046   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4002c000
   \   00000048   0x6008             STR      R0,[R1, #+0]
    247                  SPI0_MCR&=~SPI_MCR_MDIS_MASK;                           //使能DSPI时钟
   \   0000004A   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4002c000
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0xF430 0x4080      BICS     R0,R0,#0x4000
   \   00000052   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4002c000
   \   00000054   0x6008             STR      R0,[R1, #+0]
    248          	    SPI0_MCR&=~SPI_MCR_HALT_MASK;                           //启动SPI模块
   \   00000056   0x....             LDR.N    R0,??DataTable5_13  ;; 0x4002c000
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x0840             LSRS     R0,R0,#+1
   \   0000005C   0x0040             LSLS     R0,R0,#+1
   \   0000005E   0x....             LDR.N    R1,??DataTable5_13  ;; 0x4002c000
   \   00000060   0x6008             STR      R0,[R1, #+0]
    249                  SPI0_CTAR0|=SPI_CTAR_DBR_MASK;                          //两倍波特率 SCK Duty Cycle
   \   00000062   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000006A   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   0000006C   0x6008             STR      R0,[R1, #+0]
    250          	    SPI0_CTAR0=SPI_CTAR_FMSZ(7);                            //帧大小为8bit
   \   0000006E   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000070   0xF05F 0x5160      MOVS     R1,#+939524096
   \   00000074   0x6001             STR      R1,[R0, #+0]
    251          	    SPI0_CTAR0|=SPI_CTAR_PBR(0);//预分频30M//
   \   00000076   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000078   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    252                                              //00 Baud Rate Prescaler value is 2
    253                                              //01 Baud Rate Prescaler value is 3.
    254                                              //10 Baud Rate Prescaler value is 5.
    255                                              //11 Baud Rate Prescaler value is 7.
    256          	    SPI0_CTAR0|=SPI_CTAR_BR(0x0100); //最终分频180/4=45MHz
   \   0000007E   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000080   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x6001             STR      R1,[R0, #+0]
    257                                              //0000 2
    258                                              //0001 4
    259                                              //0010 6
    260                                              //0011 8
    261                                              //0100 16
    262                                              //0101 32
    263                                              //0110 64
    264                                              //0111 128
    265                                              //SCK baud rate = (fSYS/PBR) x [(1+DBR)/BR]    
    266            
    267          }
   \   00000086   0xBD01             POP      {R0,PC}          ;; return
    268          

   \                                 In section .text, align 2, keep-with-next
    269          void SPI_SetSpeed(unsigned char SpeedSet)
    270          {
    271              if(SpeedSet == SPI_SPEED_LOW)
   \                     SPI_SetSpeed:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD112             BNE.N    ??SPI_SetSpeed_0
    272              {
    273                  SPI0_CTAR0|=SPI_CTAR_DBR_MASK;                          //两倍波特率 SCK Duty Cycle
   \   00000006   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000E   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   00000010   0x6008             STR      R0,[R1, #+0]
    274          	    SPI0_CTAR0=SPI_CTAR_FMSZ(7);                            //帧大小为8bit
   \   00000012   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000014   0xF05F 0x5160      MOVS     R1,#+939524096
   \   00000018   0x6001             STR      R1,[R0, #+0]
    275          	    SPI0_CTAR0|=SPI_CTAR_PBR(0);//预分频30M//
   \   0000001A   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   0000001C   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x6001             STR      R1,[R0, #+0]
    276                                              //00 Baud Rate Prescaler value is 2
    277                                              //01 Baud Rate Prescaler value is 3.
    278                                              //10 Baud Rate Prescaler value is 5.
    279                                              //11 Baud Rate Prescaler value is 7.
    280          	    SPI0_CTAR0|=SPI_CTAR_BR(0x0100); //最终分频180/4=45MHz
   \   00000022   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000024   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0xE011             B.N      ??SPI_SetSpeed_1
    281                                              //0000 2
    282                                              //0001 4
    283                                              //0010 6
    284                                              //0011 8
    285                                              //0100 16
    286                                              //0101 32
    287                                              //0110 64
    288                                              //0111 128
    289                                              //SCK baud rate = (fSYS/PBR) x [(1+DBR)/BR]     
    290              }
    291              else
    292              {
    293                  SPI0_CTAR0|=SPI_CTAR_DBR_MASK;                          //两倍波特率 SCK Duty Cycle
   \                     ??SPI_SetSpeed_0:
   \   0000002C   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   00000034   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   00000036   0x6008             STR      R0,[R1, #+0]
    294          	    SPI0_CTAR0=SPI_CTAR_FMSZ(7);                            //帧大小为8bit
   \   00000038   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   0000003A   0xF05F 0x5160      MOVS     R1,#+939524096
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    295          	    SPI0_CTAR0|=SPI_CTAR_PBR(0);//预分频30M//
   \   00000040   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   00000042   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x6001             STR      R1,[R0, #+0]
    296                                              //00 Baud Rate Prescaler value is 2
    297                                              //01 Baud Rate Prescaler value is 3.
    298                                              //10 Baud Rate Prescaler value is 5.
    299                                              //11 Baud Rate Prescaler value is 7.
    300                SPI0_CTAR0|=SPI_CTAR_BR(0);
   \   00000048   0x....             LDR.N    R0,??DataTable5_17  ;; 0x4002c00c
   \   0000004A   0x....             LDR.N    R1,??DataTable5_17  ;; 0x4002c00c
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    301              }
    302          }
   \                     ??SPI_SetSpeed_1:
   \   00000050   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40049038         DC32     0x40049038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x4004903C         DC32     0x4004903c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40049040         DC32     0x40049040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40049044         DC32     0x40049044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x4004D004         DC32     0x4004d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x4004D008         DC32     0x4004d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x4004D00C         DC32     0x4004d00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x4004D010         DC32     0x4004d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x003F0C01         DC32     0x3f0c01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0xC60C0000         DC32     0xc60c0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x1A0A0000         DC32     0x1a0a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x4002C000         DC32     0x4002c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4002D000         DC32     0x4002d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x400AC000         DC32     0x400ac000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x4002C00C         DC32     0x4002c00c
    303          
    304          
    305          #if 0
    306          void lqwrite(unsigned char cmd)
    307          { 
    308              SPI0_PUSHR=cmd;
    309          	while((SPI0_SR&SPI_SR_TCF_MASK)==0);//等待传送完成
    310          	SPI0_SR|=SPI_SR_TCF_MASK;//清除标志	
    311          
    312          }
    313          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SPI_Configuration
              8 -> gpio_init
        8  SPI_ReadWriteByte
              8 -> hw_spi_get_base_address
        0  SPI_SetSpeed
        0  hw_spi_get_base_address
       16  hw_spi_init
             16 -> hw_spi_get_base_address
        8  hw_spi_re
              8 -> hw_spi_get_base_address


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
     136  SPI_Configuration
      90  SPI_ReadWriteByte
      82  SPI_SetSpeed
      30  hw_spi_get_base_address
     174  hw_spi_init
      48  hw_spi_re

 
 632 bytes in section .text
 
 632 bytes of CODE memory

Errors: none
Warnings: none
