###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     16/Nov/2014  15:25:33 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\sd_dri #
#                    ver.c                                                    #
#    Command line =  "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\sd_dr #
#                    iver.c" -D IAR -D TWR_K60N512 -lCN                       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\" -lB     #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\" -o      #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\Obj\"          #
#                    --no_cse --no_unroll --no_inline --no_code_motion        #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --fpu=None            #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.3\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "D:\IAR_TEST\Sirius\Sirius                     #
#                    V2.2\src\Sources\H\" -I "D:\IAR_TEST\Sirius\Sirius       #
#                    V2.2\src\Sources\H\Component_H\" -I                      #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\Frame_H\"  #
#                    -I "D:\IAR_TEST\Sirius\Sirius                            #
#                    V2.2\src\Sources\H\Function_H\" -I                       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\H\SD_H\"     #
#                    -Ol --use_c++_inline                                     #
#    List file    =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\List\sd_driver. #
#                    lst                                                      #
#    Object file  =  D:\IAR_TEST\Sirius\Sirius V2.2\bin\Flash\Obj\sd_driver.o #
#                                                                             #
#                                                                             #
###############################################################################

D:\IAR_TEST\Sirius\Sirius V2.2\src\Sources\C\SD_C\sd_driver.c
      1          /*******************************************************************************
      2          *  本文件为SPI操作SD卡的底层驱动文件
      3          *  包括SPI模块及相关IO的初始化，SPI读写SD卡（写指令，读数据等）
      4          *******************************************************************************/
      5          
      6          //#include <hidef.h>      /* common defines and macros */
      7          #include <MK60N512VMD100.h>     /* derivative information */
      8          #include "sd_driver.h"
      9          #include "spi.h"
     10          

   \                                 In section .bss, align 1
     11          unsigned char SD_Type=0 ;
   \                     SD_Type:
   \   00000000                      DS8 1
     12          
     13          #define STA_NOINIT		0x01	/* Drive not initialized */
     14          #define STA_NODISK		0x02	/* No medium in the drive */
     15          #define STA_PROTECT		0x04	/* Write protected */
     16          
     17          #if 0
     18          void SPI_Configuration(void)
     19          {
     20              MODRR_MODRR4=1; //使用m口
     21              DDRM = 0x31; //SCK0=1,MOSI=1,pm0为cs 0b00110001
     22              SPI0CR1 = 0x5e; //CPOL=1,CPHA=1 0b01011110
     23              SPI0CR2 = 0x10; //0b00010000
     24              SPI0BR  = 0x07;  // 80M / 256 = 312.5k
     25          }
     26             
     27          
     28          /*******************************************************************************
     29          * Function Name  : 	SPI_SetSpeed
     30          * Description    :		SPI设置速度为高速
     31          * Input          : 		unsigned char SpeedSet
     32          *                  			如果速度设置输入0，则低速模式，非0则高速模式
     33          *                  			SPI_SPEED_HIGH   1
     34          *                  			SPI_SPEED_LOW    0
     35          * Output         : 		None
     36          * Return         : 		None
     37          *******************************************************************************/
     38          
     39          void SPI_SetSpeed(unsigned char SpeedSet)
     40          {
     41              //如果速度设置输入0，则低速模式，非0则高速模式
     42              if(SpeedSet == SPI_SPEED_LOW)
     43              {
     44               // set low speed
     45                  SPI0CR1 = 0x5e; //CPOL=1,CPHA=1 0b01011110
     46                  SPI0CR2 = 0x10; //0b00010000
     47                  SPI0BR  = 0x07;  // 40M / 256 = 156.25k
     48              }
     49              else
     50              {
     51          	    SPI0BR  = 0x02;  // 40M / 8 = 5M       可以更高的~~
     52              }
     53              return ;
     54          }
     55          
     56          /*******************************************************************************
     57          * Function Name  : 	SPI_ReadWriteByte
     58          * Description    : 		SPI读写一个字节（发送完成后返回本次通讯读取的数据）
     59          * Input          : 		unsigned char TxData 待发送的数
     60          * Output         : 		None
     61          * Return         : 		unsigned char RxData 收到的数
     62          *******************************************************************************/
     63          unsigned char SPI_ReadWriteByte(unsigned char TxData)
     64          {
     65              unsigned char spi_tmp;
     66            
     67              while (!SPI0SR_SPTEF);
     68              SPI0DRL = TxData;
     69              while (!SPI0SR_SPIF);
     70              spi_tmp = SPI0DRL;
     71              return spi_tmp;
     72          }
     73          #endif
     74          /*******************************************************************************
     75          * Function Name  	: SD_WaitReady
     76          * Description    	: 等待SD卡Ready
     77          * Input          	: None
     78          * Output         	: None
     79          * Return         	: unsigned char
     80          *               		:0 成功
     81          *           			:other 失败
     82          *******************************************************************************/
     83          

   \                                 In section .text, align 2, keep-with-next
     84          unsigned char SD_WaitReady(void)
     85          {
   \                     SD_WaitReady:
   \   00000000   0xB510             PUSH     {R4,LR}
     86              unsigned char r1 ;
     87              unsigned char retry ;
     88              retry=0 ;
   \   00000002   0x2400             MOVS     R4,#+0
     89              do 
     90              {
     91                  r1=SPI_ReadWriteByte(0,0xFF);
   \                     ??SD_WaitReady_0:
   \   00000004   0x21FF             MOVS     R1,#+255
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       SPI_ReadWriteByte
     92                  if(retry++==200)//如果卡异常，会死循坏！
   \   0000000C   0x0021             MOVS     R1,R4
   \   0000000E   0x1C4C             ADDS     R4,R1,#+1
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x29C8             CMP      R1,#+200
   \   00000014   0xD101             BNE.N    ??SD_WaitReady_1
     93                  {
     94                      return 1 ;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE003             B.N      ??SD_WaitReady_2
     95                  }
     96              }
     97              while(r1!=0xFF);
   \                     ??SD_WaitReady_1:
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x28FF             CMP      R0,#+255
   \   0000001E   0xD1F1             BNE.N    ??SD_WaitReady_0
     98              
     99              return 0 ;
   \   00000020   0x2000             MOVS     R0,#+0
   \                     ??SD_WaitReady_2:
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    100          }
    101          
    102          
    103          /*******************************************************************************
    104          * Function Name  : 	SD_SendCommand
    105          * Description    : 		向SD卡发送一个命令
    106          * Input          : 		unsigned char cmd   命令
    107          *                  			unsigned long arg  命令参数
    108          *                  			unsigned char crc   crc校验值
    109          * Output         :		None
    110          * Return         : 		unsigned char r1 SD卡返回的响应
    111          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    112          unsigned char SD_SendCommand(unsigned char cmd,unsigned long arg,unsigned char crc)
    113          {
   \                     SD_SendCommand:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    114              unsigned char r1 ;
    115              unsigned char Retry=0 ;
   \   00000008   0x2700             MOVS     R7,#+0
    116              
    117              SPI_ReadWriteByte(0,0xff);
   \   0000000A   0x21FF             MOVS     R1,#+255
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       SPI_ReadWriteByte
    118              SD_CS_ENABLE();//片选端置低，选中SD卡
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x210D             MOVS     R1,#+13
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   0000001A   0x.... 0x....      BL       gpio_ctrl
    119              SPI_ReadWriteByte(0,cmd|0x40);//发送
   \   0000001E   0xF054 0x0140      ORRS     R1,R4,#0x40
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       SPI_ReadWriteByte
    120              //分别写入命令
    121              SPI_ReadWriteByte(0,arg>>24);	//参数[31..24]
   \   0000002A   0x0E29             LSRS     R1,R5,#+24
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       SPI_ReadWriteByte
    122              SPI_ReadWriteByte(0,arg>>16);	//参数[23..16]
   \   00000034   0x0C29             LSRS     R1,R5,#+16
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       SPI_ReadWriteByte
    123              SPI_ReadWriteByte(0,arg>>8);	//参数[15..8]
   \   0000003E   0x0A29             LSRS     R1,R5,#+8
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       SPI_ReadWriteByte
    124              SPI_ReadWriteByte(0,arg);		//参数[7..0]
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       SPI_ReadWriteByte
    125              SPI_ReadWriteByte(0,crc);
   \   00000052   0x0031             MOVS     R1,R6
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       SPI_ReadWriteByte
    126              
    127              //等待响应，或超时退出
    128              while((r1 = SPI_ReadWriteByte(0,0xFF)) == 0xFF)
   \                     ??SD_SendCommand_0:
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000064   0x0004             MOVS     R4,R0
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x28FF             CMP      R0,#+255
   \   0000006C   0xD103             BNE.N    ??SD_SendCommand_1
    129              {
    130                  Retry++;
   \   0000006E   0x1C7F             ADDS     R7,R7,#+1
    131                  if(Retry>200)
   \   00000070   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000072   0x2FC9             CMP      R7,#+201
   \   00000074   0xD3F2             BCC.N    ??SD_SendCommand_0
    132                  {
    133                  	break ;
    134                  }
    135              }   
    136              SD_CS_DISABLE(); //关闭片选
   \                     ??SD_SendCommand_1:
   \   00000076   0x2201             MOVS     R2,#+1
   \   00000078   0x210D             MOVS     R1,#+13
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   0000007E   0x.... 0x....      BL       gpio_ctrl
    137              
    138              SPI_ReadWriteByte(0,0xFF);//在总线上额外增加8个时钟，
   \   00000082   0x21FF             MOVS     R1,#+255
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       SPI_ReadWriteByte
    139              						//让SD卡完成剩下的工作
    140              
    141              //返回状态值
    142              return r1 ;
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    143          }
    144          
    145          
    146          /*******************************************************************************
    147          * Function Name  : 	SD_SendCommand_NoDeassert
    148          * Description    : 		向SD卡发送一个命令
    149          					(结束时不失能片选，还有后续数据传来）
    150          * Input          : 		unsigned char cmd   命令
    151          *                  			unsigned long arg  命令参数
    152          *                  			unsigned char crc   crc校验值
    153          * Output         : 		None
    154          * Return         : 		unsigned char r1 SD卡返回的响应
    155          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    156          unsigned char SD_SendCommand_NoDeassert(unsigned char cmd,
    157          													unsigned long arg,
    158          													unsigned char crc)
    159          {
   \                     SD_SendCommand_NoDeassert:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    160              unsigned char r1 ;
    161              unsigned char Retry=0 ;
   \   00000008   0x2700             MOVS     R7,#+0
    162              
    163              SPI_ReadWriteByte(0,0xff);//先给它8个时钟
   \   0000000A   0x21FF             MOVS     R1,#+255
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       SPI_ReadWriteByte
    164              SD_CS_ENABLE();//片选端置低，选中SD卡
   \   00000012   0x2200             MOVS     R2,#+0
   \   00000014   0x210D             MOVS     R1,#+13
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   0000001A   0x.... 0x....      BL       gpio_ctrl
    165              
    166              
    167              SPI_ReadWriteByte(0,cmd|0x40);//发送
   \   0000001E   0xF054 0x0140      ORRS     R1,R4,#0x40
   \   00000022   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       SPI_ReadWriteByte
    168              //分别写入命令
    169              SPI_ReadWriteByte(0,arg>>24);
   \   0000002A   0x0E29             LSRS     R1,R5,#+24
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      BL       SPI_ReadWriteByte
    170              SPI_ReadWriteByte(0,arg>>16);
   \   00000034   0x0C29             LSRS     R1,R5,#+16
   \   00000036   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       SPI_ReadWriteByte
    171              SPI_ReadWriteByte(0,arg>>8);
   \   0000003E   0x0A29             LSRS     R1,R5,#+8
   \   00000040   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       SPI_ReadWriteByte
    172              SPI_ReadWriteByte(0,arg);
   \   00000048   0x0029             MOVS     R1,R5
   \   0000004A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      BL       SPI_ReadWriteByte
    173              SPI_ReadWriteByte(0,crc);
   \   00000052   0x0031             MOVS     R1,R6
   \   00000054   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       SPI_ReadWriteByte
    174              
    175              //等待响应，或超时退出
    176              while((r1 = SPI_ReadWriteByte(0,0xFF)) == 0xFF)
   \                     ??SD_SendCommand_NoDeassert_0:
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000064   0x0001             MOVS     R1,R0
   \   00000066   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000068   0x29FF             CMP      R1,#+255
   \   0000006A   0xD103             BNE.N    ??SD_SendCommand_NoDeassert_1
    177              {
    178                  Retry++;
   \   0000006C   0x1C7F             ADDS     R7,R7,#+1
    179                  if(Retry>200)
   \   0000006E   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000070   0x2FC9             CMP      R7,#+201
   \   00000072   0xD3F3             BCC.N    ??SD_SendCommand_NoDeassert_0
    180                  {
    181                      break ;
    182                  }
    183              }
    184              //返回响应值
    185              return r1 ;
   \                     ??SD_SendCommand_NoDeassert_1:
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    186          }
    187          
    188          /*******************************************************************************
    189          * Function Name  : 	SD_Init
    190          * Description    : 		初始化SD卡
    191          * Input          : 		None
    192          * Output         : 		None
    193          * Return         : 		unsigned char
    194          *                  			0：NO_ERR
    195          *                  			1：TIME_OUT
    196          *                  			99：NO_CARD
    197          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          unsigned char SD_Init(void)
    199          {
   \                     SD_Init:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    200          
    201              unsigned int i ;// 用来循环计数
    202              unsigned char r1 ;// 存放SD卡的返回值
    203              unsigned int retry ;// 用来进行超时计
    204              unsigned char buff[6];
    205              
    206          //	put_s("SDinit...");
    207          
    208              for(i=0;i<0xf00;i++);// 纯延时，等待SD卡上电完成
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xE000             B.N      ??SD_Init_0
   \                     ??SD_Init_1:
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \                     ??SD_Init_0:
   \   0000000A   0xF5B4 0x6F70      CMP      R4,#+3840
   \   0000000E   0xD3FB             BCC.N    ??SD_Init_1
    209              
    210              /**先产生>74个脉冲，让SD卡自己初始化完成*/
    211              for(i=0;i<10;i++)
   \   00000010   0x2400             MOVS     R4,#+0
   \   00000012   0xE004             B.N      ??SD_Init_2
    212              {
    213                  SPI_ReadWriteByte(0,0xFF);
   \                     ??SD_Init_3:
   \   00000014   0x21FF             MOVS     R1,#+255
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      BL       SPI_ReadWriteByte
    214              }
   \   0000001C   0x1C64             ADDS     R4,R4,#+1
   \                     ??SD_Init_2:
   \   0000001E   0x2C0A             CMP      R4,#+10
   \   00000020   0xD3F8             BCC.N    ??SD_Init_3
    215          	
    216              //-----------------SD卡复位到idle开始-----------------
    217              //循环连续发送CMD0，直到SD卡返回0x01,进入IDLE状态
    218              //超时则直接退出
    219              retry=0 ;
   \   00000022   0x2500             MOVS     R5,#+0
    220              do 
    221              {
    222                  r1=SD_SendCommand(CMD0,0,0x95);//发送CMD0，让SD卡进入IDLE状态
   \                     ??SD_Init_4:
   \   00000024   0x2295             MOVS     R2,#+149
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       SD_SendCommand
   \   0000002E   0x0004             MOVS     R4,R0
    223                  retry++;
   \   00000030   0x1C6D             ADDS     R5,R5,#+1
    224              }
    225              while((r1!=0x01)&&(retry<200));
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x2C01             CMP      R4,#+1
   \   00000036   0xD001             BEQ.N    ??SD_Init_5
   \   00000038   0x2DC8             CMP      R5,#+200
   \   0000003A   0xD3F3             BCC.N    ??SD_Init_4
    226              //跳出循环后，检查原因：初始化成功？or 重试超时？
    227              if(retry==200)
   \                     ??SD_Init_5:
   \   0000003C   0x2DC8             CMP      R5,#+200
   \   0000003E   0xD101             BNE.N    ??SD_Init_6
    228              {   
    229          //		put_s("SD Time out!");
    230                  return 1 ;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xE0EE             B.N      ??SD_Init_7
    231                  //超时返回1
    232              }
    233          //	put_s("SdEnterIdle ");
    234              //-----------------SD卡复位到idle结束-----------------
    235              
    236          
    237              //获取卡片的SD版本信息
    238              r1=SD_SendCommand_NoDeassert(8,0x1aa,0x87);
   \                     ??SD_Init_6:
   \   00000044   0x2287             MOVS     R2,#+135
   \   00000046   0xF44F 0x71D5      MOV      R1,#+426
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0x.... 0x....      BL       SD_SendCommand_NoDeassert
   \   00000050   0x0004             MOVS     R4,R0
    239              
    240              //如果卡片版本信息是v1.0版本的，即r1=0x05，则进行以下初始化
    241              if(r1==0x05)
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2C05             CMP      R4,#+5
   \   00000056   0xD15A             BNE.N    ??SD_Init_8
    242              {
    243                  //设置卡类型为SDV1.0，如果后面检测到为MMC卡，再修改为MMC
    244          //		put_s("SD V1 ");
    245                  SD_Type=SD_TYPE_V1 ;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000005C   0x2101             MOVS     R1,#+1
   \   0000005E   0x7001             STRB     R1,[R0, #+0]
    246                  
    247                  //如果是V1.0卡，CMD8指令后没有后续数据
    248                  //片选置高，结束本次命令
    249                  SD_CS_DISABLE();
   \   00000060   0x2201             MOVS     R2,#+1
   \   00000062   0x210D             MOVS     R1,#+13
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   00000068   0x.... 0x....      BL       gpio_ctrl
    250                  //多发8个CLK，让SD结束后续操作
    251                  SPI_ReadWriteByte(0,0xFF);
   \   0000006C   0x21FF             MOVS     R1,#+255
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       SPI_ReadWriteByte
    252                  
    253                  //-----------------SD卡、MMC卡初始化开始-----------------
    254                  
    255                  //发卡初始化指令CMD55+ACMD41
    256                  // 如果有应答，说明是SD卡，且初始化完成
    257                  // 没有回应，说明是MMC卡，额外进行相应初始化
    258                  retry=0 ;
   \   00000074   0x2500             MOVS     R5,#+0
    259                  do 
    260                  {
    261                      //先发CMD55，应返回0x01；否则出错
    262                      r1=SD_SendCommand(CMD55,0,0);
   \                     ??SD_Init_9:
   \   00000076   0x2200             MOVS     R2,#+0
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x2037             MOVS     R0,#+55
   \   0000007C   0x.... 0x....      BL       SD_SendCommand
   \   00000080   0x0004             MOVS     R4,R0
    263                      if(r1!=0x01)
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x2C01             CMP      R4,#+1
   \   00000086   0xD002             BEQ.N    ??SD_Init_10
    264                      {
    265                          return r1 ;
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0xE0C9             B.N      ??SD_Init_7
    266                      }
    267                      //得到正确响应后，发ACMD41，应得到返回值0x00，否则重试400次
    268                      r1=SD_SendCommand(ACMD41,0,0);
   \                     ??SD_Init_10:
   \   0000008E   0x2200             MOVS     R2,#+0
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x2029             MOVS     R0,#+41
   \   00000094   0x.... 0x....      BL       SD_SendCommand
   \   00000098   0x0004             MOVS     R4,R0
    269                      retry++;
   \   0000009A   0x1C6D             ADDS     R5,R5,#+1
    270                  }
    271                  while((r1!=0x00)&&(retry<400));
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2C00             CMP      R4,#+0
   \   000000A0   0xD003             BEQ.N    ??SD_Init_11
   \   000000A2   0xF44F 0x70C8      MOV      R0,#+400
   \   000000A6   0x4285             CMP      R5,R0
   \   000000A8   0xD3E5             BCC.N    ??SD_Init_9
    272                  // 判断是超时还是得到正确回应
    273                  // 若有回应：是SD卡；没有回应：是MMC卡
    274                  
    275                  //----------MMC卡额外初始化操作开始------------
    276                  if(retry==400)
   \                     ??SD_Init_11:
   \   000000AA   0xF44F 0x70C8      MOV      R0,#+400
   \   000000AE   0x4285             CMP      R5,R0
   \   000000B0   0xD118             BNE.N    ??SD_Init_12
    277                  {
    278                      retry=0 ;
   \   000000B2   0x2500             MOVS     R5,#+0
    279                      //发送MMC卡初始化命令（没有测试）
    280                      do 
    281                      {
    282                          r1=SD_SendCommand(1,0,0);
   \                     ??SD_Init_13:
   \   000000B4   0x2200             MOVS     R2,#+0
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x2001             MOVS     R0,#+1
   \   000000BA   0x.... 0x....      BL       SD_SendCommand
   \   000000BE   0x0004             MOVS     R4,R0
    283                          retry++;
   \   000000C0   0x1C6D             ADDS     R5,R5,#+1
    284                      }
    285                      while((r1!=0x00)&&(retry<400));
   \   000000C2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C4   0x2C00             CMP      R4,#+0
   \   000000C6   0xD003             BEQ.N    ??SD_Init_14
   \   000000C8   0xF44F 0x70C8      MOV      R0,#+400
   \   000000CC   0x4285             CMP      R5,R0
   \   000000CE   0xD3F1             BCC.N    ??SD_Init_13
    286                      if(retry==400)
   \                     ??SD_Init_14:
   \   000000D0   0xF44F 0x70C8      MOV      R0,#+400
   \   000000D4   0x4285             CMP      R5,R0
   \   000000D6   0xD101             BNE.N    ??SD_Init_15
    287                      {
    288                          return 1 ;
   \   000000D8   0x2001             MOVS     R0,#+1
   \   000000DA   0xE0A2             B.N      ??SD_Init_7
    289                          //MMC卡初始化超时
    290                      }
    291                      //写入卡类型
    292                      SD_Type=SD_TYPE_MMC ;
   \                     ??SD_Init_15:
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x7001             STRB     R1,[R0, #+0]
    293                  }
    294                  //----------MMC卡额外初始化操作结束------------
    295                  
    296                  //设置SPI为高速模式
    297                  SPI_SetSpeed(1);
   \                     ??SD_Init_12:
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x.... 0x....      BL       SPI_SetSpeed
    298                  SPI_ReadWriteByte(0,0xFF);    
   \   000000EA   0x21FF             MOVS     R1,#+255
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x.... 0x....      BL       SPI_ReadWriteByte
    299                  //禁止CRC校验
    300                  /*
    301                  		r1 = SD_SendCommand(CMD59, 0, 0x01);
    302                          if(r1 != 0x00)
    303                          {
    304                              return r1;  //命令错误，返回r1
    305                          }
    306                          */
    307                  //设置Sector Size
    308                  r1=SD_SendCommand(CMD16,512,0xff);
   \   000000F2   0x22FF             MOVS     R2,#+255
   \   000000F4   0xF44F 0x7100      MOV      R1,#+512
   \   000000F8   0x2010             MOVS     R0,#+16
   \   000000FA   0x.... 0x....      BL       SD_SendCommand
   \   000000FE   0x0004             MOVS     R4,R0
    309                  if(r1!=0x00)
   \   00000100   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000102   0x2C00             CMP      R4,#+0
   \   00000104   0xF000 0x808B      BEQ.W    ??SD_Init_16
    310                  {
    311                      return r1 ;
   \   00000108   0x0020             MOVS     R0,R4
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0xE089             B.N      ??SD_Init_7
    312                      //命令错误，返回r1
    313                  }
    314                  //-----------------SD卡、MMC卡初始化结束-----------------
    315                  
    316              }
    317              //SD卡为V1.0版本的初始化结束
    318              
    319              
    320              //下面是V2.0卡的初始化
    321              //其中需要读取OCR数据，判断是SD2.0还是SD2.0HC卡
    322              else if(r1==0x01)
   \                     ??SD_Init_8:
   \   0000010E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000110   0x2C01             CMP      R4,#+1
   \   00000112   0xF040 0x8084      BNE.W    ??SD_Init_16
    323              {
    324          //		put_s("SD V2 ");
    325                  //V2.0的卡，CMD8命令后会传回4字节的数据，要跳过再结束本命令
    326                  buff[0]=SPI_ReadWriteByte(0,0xFF); //should be 0x00      
   \   00000116   0x21FF             MOVS     R1,#+255
   \   00000118   0x2000             MOVS     R0,#+0
   \   0000011A   0x.... 0x....      BL       SPI_ReadWriteByte
   \   0000011E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    327                  buff[1]=SPI_ReadWriteByte(0,0xFF);//should be 0x00 
   \   00000122   0x21FF             MOVS     R1,#+255
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x.... 0x....      BL       SPI_ReadWriteByte
   \   0000012A   0xF88D 0x0001      STRB     R0,[SP, #+1]
    328                  buff[2]=SPI_ReadWriteByte(0,0xFF); //should be 0x01
   \   0000012E   0x21FF             MOVS     R1,#+255
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000136   0xF88D 0x0002      STRB     R0,[SP, #+2]
    329                  buff[3]=SPI_ReadWriteByte(0,0xFF);//should be 0xAA
   \   0000013A   0x21FF             MOVS     R1,#+255
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000142   0xF88D 0x0003      STRB     R0,[SP, #+3]
    330                  
    331                  SD_CS_DISABLE();
   \   00000146   0x2201             MOVS     R2,#+1
   \   00000148   0x210D             MOVS     R1,#+13
   \   0000014A   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   0000014E   0x.... 0x....      BL       gpio_ctrl
    332                  SPI_ReadWriteByte(0,0xFF);//the next 8 clocks
   \   00000152   0x21FF             MOVS     R1,#+255
   \   00000154   0x2000             MOVS     R0,#+0
   \   00000156   0x.... 0x....      BL       SPI_ReadWriteByte
    333                  
    334                  //判断该卡是否支持2.7V-3.6V的电压范围
    335                  if(buff[2]==0x01&&buff[3]==0xAA)
   \   0000015A   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000015E   0x2801             CMP      R0,#+1
   \   00000160   0xD15D             BNE.N    ??SD_Init_16
   \   00000162   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000166   0x28AA             CMP      R0,#+170
   \   00000168   0xD159             BNE.N    ??SD_Init_16
    336                  {
    337                      //支持电压范围，可以操作
    338                      retry=0 ;
   \   0000016A   0x2500             MOVS     R5,#+0
    339                      //发卡初始化指令CMD55+ACMD41
    340                      do 
    341                      {
    342                          r1=SD_SendCommand(CMD55,0,0);
   \                     ??SD_Init_17:
   \   0000016C   0x2200             MOVS     R2,#+0
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0x2037             MOVS     R0,#+55
   \   00000172   0x.... 0x....      BL       SD_SendCommand
   \   00000176   0x0004             MOVS     R4,R0
    343                          if(r1!=0x01)
   \   00000178   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000017A   0x2C01             CMP      R4,#+1
   \   0000017C   0xD002             BEQ.N    ??SD_Init_18
    344                          {
    345                              return r1 ;
   \   0000017E   0x0020             MOVS     R0,R4
   \   00000180   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000182   0xE04E             B.N      ??SD_Init_7
    346                          }
    347                          r1=SD_SendCommand(ACMD41,0x40000000,0);
   \                     ??SD_Init_18:
   \   00000184   0x2200             MOVS     R2,#+0
   \   00000186   0xF05F 0x4180      MOVS     R1,#+1073741824
   \   0000018A   0x2029             MOVS     R0,#+41
   \   0000018C   0x.... 0x....      BL       SD_SendCommand
   \   00000190   0x0004             MOVS     R4,R0
    348                          if(retry>200)
   \   00000192   0x2DC9             CMP      R5,#+201
   \   00000194   0xD302             BCC.N    ??SD_Init_19
    349                          {
    350                              return r1 ;
   \   00000196   0x0020             MOVS     R0,R4
   \   00000198   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000019A   0xE042             B.N      ??SD_Init_7
    351                              //超时则返回r1状态
    352                          }
    353                      }
    354                      while(r1!=0);
   \                     ??SD_Init_19:
   \   0000019C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019E   0x2C00             CMP      R4,#+0
   \   000001A0   0xD1E4             BNE.N    ??SD_Init_17
    355                      
    356                      //初始化指令发送完成，接下来获取OCR信息
    357                      
    358                      //-----------鉴别SD2.0卡版本开始-----------
    359                      r1=SD_SendCommand_NoDeassert(CMD58,0,0);
   \   000001A2   0x2200             MOVS     R2,#+0
   \   000001A4   0x2100             MOVS     R1,#+0
   \   000001A6   0x203A             MOVS     R0,#+58
   \   000001A8   0x.... 0x....      BL       SD_SendCommand_NoDeassert
   \   000001AC   0x0004             MOVS     R4,R0
    360                      if(r1!=0x00)
   \   000001AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B0   0x2C00             CMP      R4,#+0
   \   000001B2   0xD002             BEQ.N    ??SD_Init_20
    361                      {
    362                          return r1 ;
   \   000001B4   0x0020             MOVS     R0,R4
   \   000001B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B8   0xE033             B.N      ??SD_Init_7
    363                          //如果命令没有返回正确应答，直接退出，返回应答
    364                      }
    365                      //读OCR指令发出后，紧接着是4字节的OCR信息
    366                      buff[0]=SPI_ReadWriteByte(0,0xFF);
   \                     ??SD_Init_20:
   \   000001BA   0x21FF             MOVS     R1,#+255
   \   000001BC   0x2000             MOVS     R0,#+0
   \   000001BE   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000001C2   0xF88D 0x0000      STRB     R0,[SP, #+0]
    367                      buff[1]=SPI_ReadWriteByte(0,0xFF);
   \   000001C6   0x21FF             MOVS     R1,#+255
   \   000001C8   0x2000             MOVS     R0,#+0
   \   000001CA   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000001CE   0xF88D 0x0001      STRB     R0,[SP, #+1]
    368                      buff[2]=SPI_ReadWriteByte(0,0xFF);
   \   000001D2   0x21FF             MOVS     R1,#+255
   \   000001D4   0x2000             MOVS     R0,#+0
   \   000001D6   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000001DA   0xF88D 0x0002      STRB     R0,[SP, #+2]
    369                      buff[3]=SPI_ReadWriteByte(0,0xFF);
   \   000001DE   0x21FF             MOVS     R1,#+255
   \   000001E0   0x2000             MOVS     R0,#+0
   \   000001E2   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000001E6   0xF88D 0x0003      STRB     R0,[SP, #+3]
    370                      
    371                      //OCR接收完成，片选置高
    372                      SD_CS_DISABLE();
   \   000001EA   0x2201             MOVS     R2,#+1
   \   000001EC   0x210D             MOVS     R1,#+13
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   000001F2   0x.... 0x....      BL       gpio_ctrl
    373                      SPI_ReadWriteByte(0,0xFF);
   \   000001F6   0x21FF             MOVS     R1,#+255
   \   000001F8   0x2000             MOVS     R0,#+0
   \   000001FA   0x.... 0x....      BL       SPI_ReadWriteByte
    374                      
    375                      //检查接收到的OCR中的bit30位（CCS），确定其为SD2.0还是SDHC
    376                      //如果CCS=1：SDHC   CCS=0：SD2.0
    377                      //检查CCS
    378                      if(buff[0]&0x40)
   \   000001FE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000202   0x0640             LSLS     R0,R0,#+25
   \   00000204   0xD504             BPL.N    ??SD_Init_21
    379                      {
    380                          SD_Type=SD_TYPE_V2HC ;
   \   00000206   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   0000020A   0x2104             MOVS     R1,#+4
   \   0000020C   0x7001             STRB     R1,[R0, #+0]
   \   0000020E   0xE003             B.N      ??SD_Init_22
    381          //				put_s("SDHC ");
    382          
    383                      }
    384                      else 
    385                      {
    386                          SD_Type=SD_TYPE_V2 ;
   \                     ??SD_Init_21:
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable7_1
   \   00000214   0x2102             MOVS     R1,#+2
   \   00000216   0x7001             STRB     R1,[R0, #+0]
    387                      }
    388                      //-----------鉴别SD2.0卡版本结束-----------
    389                      
    390                      
    391                      //设置SPI为高速模式
    392                      SPI_SetSpeed(1);
   \                     ??SD_Init_22:
   \   00000218   0x2001             MOVS     R0,#+1
   \   0000021A   0x.... 0x....      BL       SPI_SetSpeed
    393                  }
    394                  
    395              }
    396              return r1 ;
   \                     ??SD_Init_16:
   \   0000021E   0x0020             MOVS     R0,R4
   \   00000220   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??SD_Init_7:
   \   00000222   0xBD3E             POP      {R1-R5,PC}       ;; return
    397          }
    398          
    399          
    400          
    401          /*******************************************************************************
    402          * Function Name  : SD_ReceiveData
    403          * Description    : 从SD卡中读回指定长度的数据，放置在给定位置
    404          * Input          : unsigned char *data(存放读回数据的内存>len)
    405          *                  unsigned int len(数据长度）
    406          *                  unsigned char release(传输完成后是否释放总线CS置高 0：不释放 1：释放）
    407          * Output         : None
    408          * Return         : unsigned char
    409          *                  0：NO_ERR
    410          *                  other：错误信息
    411          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    412          unsigned char SD_ReceiveData(unsigned char*data,unsigned int len,unsigned char release)
    413          {
   \                     SD_ReceiveData:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    414              unsigned int retry ;
    415              unsigned char r1 ;
    416              
    417              // 启动一次传输
    418              SD_CS_ENABLE();
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x210D             MOVS     R1,#+13
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   00000010   0x.... 0x....      BL       gpio_ctrl
    419              //等待SD卡发回数据起始令牌0xFE
    420              retry=0 ;
   \   00000014   0x2700             MOVS     R7,#+0
    421              do 
    422              {
    423                  r1=SPI_ReadWriteByte(0,0xFF);
   \                     ??SD_ReceiveData_0:
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      BL       SPI_ReadWriteByte
    424                  //retry次等待后没有应答，退出报错
    425                  if(retry++>0xFFFE)
   \   0000001E   0x0039             MOVS     R1,R7
   \   00000020   0x1C4F             ADDS     R7,R1,#+1
   \   00000022   0xF64F 0x72FF      MOVW     R2,#+65535
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xD307             BCC.N    ??SD_ReceiveData_1
    426                  {
    427          //			put_s("SD tout");
    428          
    429                      SD_CS_DISABLE();
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x210D             MOVS     R1,#+13
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   00000032   0x.... 0x....      BL       gpio_ctrl
    430                      return 1 ;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xE023             B.N      ??SD_ReceiveData_2
    431                  }
    432              }
    433              while(r1!=0xFE);
   \                     ??SD_ReceiveData_1:
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x28FE             CMP      R0,#+254
   \   0000003E   0xD1EA             BNE.N    ??SD_ReceiveData_0
    434              //开始接收数据
    435              while(len--)
   \                     ??SD_ReceiveData_3:
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0x1E45             SUBS     R5,R0,#+1
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD006             BEQ.N    ??SD_ReceiveData_4
    436              {
    437                  *data=SPI_ReadWriteByte(0,0xFF);
   \   00000048   0x21FF             MOVS     R1,#+255
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000050   0x7020             STRB     R0,[R4, #+0]
    438                  data++;
   \   00000052   0x1C64             ADDS     R4,R4,#+1
   \   00000054   0xE7F4             B.N      ??SD_ReceiveData_3
    439              }
    440              //下面是2个伪CRC（dummy CRC）
    441              SPI_ReadWriteByte(0,0xFF);
   \                     ??SD_ReceiveData_4:
   \   00000056   0x21FF             MOVS     R1,#+255
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       SPI_ReadWriteByte
    442              SPI_ReadWriteByte(0,0xFF);
   \   0000005E   0x21FF             MOVS     R1,#+255
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      BL       SPI_ReadWriteByte
    443              //按需释放总线，将CS置高
    444              if(release==RELEASE)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E01             CMP      R6,#+1
   \   0000006A   0xD109             BNE.N    ??SD_ReceiveData_5
    445              {
    446                  //传输结束
    447                  SD_CS_DISABLE();
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0x210D             MOVS     R1,#+13
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable7  ;; 0x400ff000
   \   00000074   0x.... 0x....      BL       gpio_ctrl
    448                  SPI_ReadWriteByte(0,0xFF);
   \   00000078   0x21FF             MOVS     R1,#+255
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       SPI_ReadWriteByte
    449              }
    450          
    451              return 0 ;
   \                     ??SD_ReceiveData_5:
   \   00000080   0x2000             MOVS     R0,#+0
   \                     ??SD_ReceiveData_2:
   \   00000082   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    452          }
    453          
    454          
    455          /*******************************************************************************
    456          * Function Name  : SD_GetCID
    457          * Description    : 获取SD卡的CID信息，包括制造商信息
    458          * Input          : unsigned char *cid_data(存放CID的内存，至少16Byte）
    459          * Output         : None
    460          * Return         : unsigned char
    461          *                  0：NO_ERR
    462          *                  1：TIME_OUT
    463          *                  other：错误信息
    464          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    465          unsigned char SD_GetCID(unsigned char*cid_data)
    466          {
   \                     SD_GetCID:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    467              unsigned char r1 ;
    468              
    469             
    470              r1=SD_SendCommand(CMD10,0,0xFF); //发CMD10命令，读CID
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x200A             MOVS     R0,#+10
   \   0000000A   0x.... 0x....      BL       SD_SendCommand
    471              if(r1!=0x00)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??SD_GetCID_0
    472              {
    473                  return r1 ;
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xE005             B.N      ??SD_GetCID_1
    474                  //没返回正确应答，则退出，报错
    475              }
    476              //接收16个字节的数据
    477              SD_ReceiveData(cid_data,16,RELEASE);
   \                     ??SD_GetCID_0:
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2110             MOVS     R1,#+16
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       SD_ReceiveData
    478          
    479              return 0 ;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??SD_GetCID_1:
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    480          }
    481          
    482          
    483          /*******************************************************************************
    484          * Function Name  : SD_GetCSD
    485          * Description    : 获取SD卡的CSD信息，包括容量和速度信息
    486          * Input          : unsigned char *cid_data(存放CID的内存，至少16Byte）
    487          * Output         : None
    488          * Return         : unsigned char
    489          *                  0：NO_ERR
    490          *                  1：TIME_OUT
    491          *                  other：错误信息
    492          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    493          unsigned char SD_GetCSD(unsigned char *csd_data)
    494          {
   \                     SD_GetCSD:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    495              unsigned char r1 ;
    496              
    497             
    498              r1=SD_SendCommand(CMD9,0,0xFF); //发CMD9命令，读CSD
   \   00000004   0x22FF             MOVS     R2,#+255
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2009             MOVS     R0,#+9
   \   0000000A   0x.... 0x....      BL       SD_SendCommand
    499              if(r1!=0x00)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ.N    ??SD_GetCSD_0
    500              {
    501                  return r1 ;
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xE005             B.N      ??SD_GetCSD_1
    502                  //没返回正确应答，则退出，报错
    503              }
    504              //接收16个字节的数据
    505              SD_ReceiveData(csd_data,16,RELEASE);
   \                     ??SD_GetCSD_0:
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2110             MOVS     R1,#+16
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       SD_ReceiveData
    506              
    507              return 0 ;
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??SD_GetCSD_1:
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    508          }
    509          
    510          /*******************************************************************************
    511          * Function Name  : SD_GetCapacity
    512          * Description    : 获取SD卡的容量
    513          * Input          : None
    514          * Output         : None
    515          * Return         : unsigned long capacity
    516          *                   0： 取容量出错
    517          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    518          unsigned long SD_GetCapacity(void)
    519          {
   \                     SD_GetCapacity:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    520              unsigned char csd[16];
    521              unsigned long Capacity ;
    522              unsigned char r1 ;
    523              unsigned int i ;
    524              unsigned int temp ;
    525              
    526              
    527              if(SD_GetCSD(csd)!=0)//取CSD信息，如果期间出错，返回0
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      BL       SD_GetCSD
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??SD_GetCapacity_0
    528              {
    529                  return 0 ;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE040             B.N      ??SD_GetCapacity_1
    530              }
    531          
    532              //如果为SDHC卡，按照下面方式计算
    533              if((csd[0]&0xC0)==0x40)
   \                     ??SD_GetCapacity_0:
   \   00000012   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000016   0xF010 0x00C0      ANDS     R0,R0,#0xC0
   \   0000001A   0x2840             CMP      R0,#+64
   \   0000001C   0xD10B             BNE.N    ??SD_GetCapacity_2
    534              {
    535                  Capacity=((((unsigned long)csd[8])<<8)+(unsigned long)csd[9]+1)*(unsigned long)1024 ;
   \   0000001E   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000022   0x0200             LSLS     R0,R0,#+8
   \   00000024   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \   00000028   0xFA50 0xF081      UXTAB    R0,R0,R1
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0xF44F 0x6180      MOV      R1,#+1024
   \   00000032   0x4348             MULS     R0,R1,R0
   \   00000034   0xE02E             B.N      ??SD_GetCapacity_3
    536              }
    537              else 
    538              {
    539                  //下面代码为网上版本
    540                  ////////////formula of the capacity///////////////
    541                  //
    542                  //  memory capacity = BLOCKNR * BLOCK_LEN
    543                  //
    544                  //	BLOCKNR = (C_SIZE + 1)* MULT
    545                  //
    546                  //           C_SIZE_MULT+2
    547                  //	MULT = 2
    548                  //
    549                  //               READ_BL_LEN
    550                  //	BLOCK_LEN = 2
    551                  /**********************************************/
    552                  //C_SIZE
    553                  i=csd[6]&0x03 ;
   \                     ??SD_GetCapacity_2:
   \   00000036   0xF89D 0x0006      LDRB     R0,[SP, #+6]
   \   0000003A   0xF010 0x0103      ANDS     R1,R0,#0x3
    554                  i<<=8 ;
   \   0000003E   0x0209             LSLS     R1,R1,#+8
    555                  i+=csd[7];
   \   00000040   0xF89D 0x0007      LDRB     R0,[SP, #+7]
   \   00000044   0xFA51 0xF180      UXTAB    R1,R1,R0
    556                  i<<=2 ;
   \   00000048   0x0089             LSLS     R1,R1,#+2
    557                  i+=((csd[8]&0xc0)>>6);
   \   0000004A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x0980             LSRS     R0,R0,#+6
   \   00000052   0xFA51 0xF180      UXTAB    R1,R1,R0
    558                  
    559                  //C_SIZE_MULT
    560                  r1=csd[9]&0x03 ;
   \   00000056   0xF89D 0x0009      LDRB     R0,[SP, #+9]
   \   0000005A   0xF010 0x0003      ANDS     R0,R0,#0x3
    561                  r1<<=1 ;
   \   0000005E   0x0040             LSLS     R0,R0,#+1
    562                  r1+=((csd[10]&0x80)>>7);
   \   00000060   0xF89D 0x200A      LDRB     R2,[SP, #+10]
   \   00000064   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000066   0xEB10 0x10D2      ADDS     R0,R0,R2, LSR #+7
    563                  
    564                  //BLOCKNR
    565                  r1+=2 ;
   \   0000006A   0x1C80             ADDS     R0,R0,#+2
    566                  temp=1 ;
   \   0000006C   0x2201             MOVS     R2,#+1
   \   0000006E   0xE001             B.N      ??SD_GetCapacity_4
    567                  while(r1)
    568                  {
    569                      temp*=2 ;
   \                     ??SD_GetCapacity_5:
   \   00000070   0x0052             LSLS     R2,R2,#+1
    570                      r1--;
   \   00000072   0x1E40             SUBS     R0,R0,#+1
    571                  }
   \                     ??SD_GetCapacity_4:
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD1FA             BNE.N    ??SD_GetCapacity_5
    572                  Capacity=((unsigned long)(i+1))*((unsigned long)temp);
   \   0000007A   0x1C48             ADDS     R0,R1,#+1
   \   0000007C   0x4350             MULS     R0,R2,R0
    573                  
    574                  // READ_BL_LEN
    575                  i=csd[5]&0x0f ;
   \   0000007E   0xF89D 0x1005      LDRB     R1,[SP, #+5]
   \   00000082   0xF011 0x010F      ANDS     R1,R1,#0xF
    576                  //BLOCK_LEN
    577                  temp=1 ;
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0xE001             B.N      ??SD_GetCapacity_6
    578                  while(i)
    579                  {
    580                      temp*=2 ;
   \                     ??SD_GetCapacity_7:
   \   0000008A   0x0052             LSLS     R2,R2,#+1
    581                      i--;
   \   0000008C   0x1E49             SUBS     R1,R1,#+1
    582                  }
   \                     ??SD_GetCapacity_6:
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD1FB             BNE.N    ??SD_GetCapacity_7
    583                  //The final result
    584                  Capacity*=(unsigned long)temp ;
   \   00000092   0x4350             MULS     R0,R2,R0
    585                  //Capacity /= 512;
    586              }
    587              return (unsigned long)Capacity ;
   \                     ??SD_GetCapacity_3:
   \                     ??SD_GetCapacity_1:
   \   00000094   0xB005             ADD      SP,SP,#+20
   \   00000096   0xBD00             POP      {PC}             ;; return
    588          }
    589          
    590          
    591          /*******************************************************************************
    592          * Function Name  : SD_ReadSingleBlock
    593          * Description    : 读SD卡的一个block
    594          * Input          : unsigned long sector 扇区地址（sector值，非物理地址）
    595          *                  unsigned char *buffer 数据存储地址（大小至少512byte）
    596          * Output         : None
    597          * Return         : unsigned char r1
    598          *                   0： 成功
    599          *                   other：失败
    600          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    601          unsigned char SD_ReadSingleBlock(unsigned long sector,unsigned char*buffer)
    602          {
   \                     SD_ReadSingleBlock:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    603              unsigned char r1 ;
    604              
    605              SPI_SetSpeed(SPI_SPEED_HIGH);//设置为高速模式
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       SPI_SetSpeed
    606              //sector=sector<<9 ;//如果不是SDHC，将sector地址转成byte地址
    607              if(SD_Type!=SD_TYPE_V2HC)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD000             BEQ.N    ??SD_ReadSingleBlock_0
    608              {
    609                  sector=sector<<9 ;
   \   00000014   0x0264             LSLS     R4,R4,#+9
    610              }
    611              r1=SD_SendCommand(CMD17,sector,0xFF);//读命令
   \                     ??SD_ReadSingleBlock_0:
   \   00000016   0x22FF             MOVS     R2,#+255
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2011             MOVS     R0,#+17
   \   0000001C   0x.... 0x....      BL       SD_SendCommand
    612                 
    613              if(r1!=0x00)
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD001             BEQ.N    ??SD_ReadSingleBlock_1
    614              {
    615                  return r1 ;
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xE00B             B.N      ??SD_ReadSingleBlock_2
    616              }
    617              
    618              r1=SD_ReceiveData(buffer,512,RELEASE);
   \                     ??SD_ReadSingleBlock_1:
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xF44F 0x7100      MOV      R1,#+512
   \   00000030   0x0028             MOVS     R0,R5
   \   00000032   0x.... 0x....      BL       SD_ReceiveData
    619              if(r1!=0)
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ.N    ??SD_ReadSingleBlock_3
    620              {
    621                  return r1 ;
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xE000             B.N      ??SD_ReadSingleBlock_2
    622                  //读数据出错！
    623              }
    624              else 
    625              {
    626                  return 0 ; //success
   \                     ??SD_ReadSingleBlock_3:
   \   00000040   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadSingleBlock_2:
   \   00000042   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    627          
    628              }
    629          }
    630          
    631          /*******************************************************************************
    632          * Function Name  	: SD_WriteSingleBlock
    633          * Description    	: 写入SD卡的一个block
    634          * Input          	: unsigned long sector 扇区地址（sector值，非物理地址）
    635          *                  		  unsigned char *buffer 数据存储地址（大小至少512byte）
    636          * Output         	: None
    637          * Return         	: unsigned char r1
    638          *                   	0： 成功
    639          *                   	other：失败
    640          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    641          unsigned char SD_WriteSingleBlock(unsigned long sector,const unsigned char *data)
    642          {
   \                     SD_WriteSingleBlock:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    643              unsigned char r1 ;
    644              unsigned int i ;
    645              unsigned int retry ;
    646              
    647              //设置为高速模式
    648              SPI_SetSpeed(SPI_SPEED_HIGH);
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       SPI_SetSpeed
    649              
    650              //如果不是SDHC，给定的是sector地址，将其转换成byte地址
    651              if(SD_Type!=SD_TYPE_V2HC)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2804             CMP      R0,#+4
   \   00000012   0xD000             BEQ.N    ??SD_WriteSingleBlock_0
    652              {
    653                  sector=sector<<9 ;
   \   00000014   0x0264             LSLS     R4,R4,#+9
    654              }
    655              
    656              r1=SD_SendCommand(CMD24,sector,0xFF);
   \                     ??SD_WriteSingleBlock_0:
   \   00000016   0x22FF             MOVS     R2,#+255
   \   00000018   0x0021             MOVS     R1,R4
   \   0000001A   0x2018             MOVS     R0,#+24
   \   0000001C   0x.... 0x....      BL       SD_SendCommand
   \   00000020   0x0004             MOVS     R4,R0
    657              if(r1!=0x00)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD002             BEQ.N    ??SD_WriteSingleBlock_1
    658              {
    659                  return r1 ;
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xE057             B.N      ??SD_WriteSingleBlock_2
    660                  //应答不正确，直接返回
    661              }
    662              
    663              //开始准备数据传输
    664              SD_CS_ENABLE();
   \                     ??SD_WriteSingleBlock_1:
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x210D             MOVS     R1,#+13
   \   00000032   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   00000034   0x.... 0x....      BL       gpio_ctrl
    665              //先放3个空数据，等待SD卡准备好
    666              SPI_ReadWriteByte(0,0xff);
   \   00000038   0x21FF             MOVS     R1,#+255
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      BL       SPI_ReadWriteByte
    667              SPI_ReadWriteByte(0,0xff);
   \   00000040   0x21FF             MOVS     R1,#+255
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x.... 0x....      BL       SPI_ReadWriteByte
    668              SPI_ReadWriteByte(0,0xff);
   \   00000048   0x21FF             MOVS     R1,#+255
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       SPI_ReadWriteByte
    669              //放起始令牌0xFE
    670              SPI_ReadWriteByte(0,0xFE);
   \   00000050   0x21FE             MOVS     R1,#+254
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       SPI_ReadWriteByte
    671              
    672              //放一个sector的数据
    673              for(i=0;i<512;i++)
   \   00000058   0x2400             MOVS     R4,#+0
   \   0000005A   0xE005             B.N      ??SD_WriteSingleBlock_3
    674              {
    675                  SPI_ReadWriteByte(0,*data++);
   \                     ??SD_WriteSingleBlock_4:
   \   0000005C   0x7829             LDRB     R1,[R5, #+0]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000064   0x1C6D             ADDS     R5,R5,#+1
    676              }
   \   00000066   0x1C64             ADDS     R4,R4,#+1
   \                     ??SD_WriteSingleBlock_3:
   \   00000068   0xF44F 0x7000      MOV      R0,#+512
   \   0000006C   0x4284             CMP      R4,R0
   \   0000006E   0xD3F5             BCC.N    ??SD_WriteSingleBlock_4
    677              //发2个Byte的dummy CRC
    678              SPI_ReadWriteByte(0,0xff);
   \   00000070   0x21FF             MOVS     R1,#+255
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      BL       SPI_ReadWriteByte
    679              SPI_ReadWriteByte(0,0xff);
   \   00000078   0x21FF             MOVS     R1,#+255
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      BL       SPI_ReadWriteByte
    680              
    681              //等待SD卡应答
    682              r1=SPI_ReadWriteByte(0,0xff);
   \   00000080   0x21FF             MOVS     R1,#+255
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000088   0x0004             MOVS     R4,R0
    683              if((r1&0x1F)!=0x05)
   \   0000008A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   0xF014 0x001F      ANDS     R0,R4,#0x1F
   \   00000090   0x2805             CMP      R0,#+5
   \   00000092   0xD007             BEQ.N    ??SD_WriteSingleBlock_5
    684              {
    685                  SD_CS_DISABLE();
   \   00000094   0x2201             MOVS     R2,#+1
   \   00000096   0x210D             MOVS     R1,#+13
   \   00000098   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   0000009A   0x.... 0x....      BL       gpio_ctrl
    686                  return r1 ;
   \   0000009E   0x0020             MOVS     R0,R4
   \   000000A0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A2   0xE01C             B.N      ??SD_WriteSingleBlock_2
    687              }
    688              
    689              //等待操作完成
    690              retry=0 ;
   \                     ??SD_WriteSingleBlock_5:
   \   000000A4   0x2400             MOVS     R4,#+0
    691              while(!SPI_ReadWriteByte(0,0xff))
   \                     ??SD_WriteSingleBlock_6:
   \   000000A6   0x21FF             MOVS     R1,#+255
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD10B             BNE.N    ??SD_WriteSingleBlock_7
    692              {
    693                  retry++;
   \   000000B2   0x1C64             ADDS     R4,R4,#+1
    694                  //如果长时间写入没有完成，报错退出
    695                  if(retry>0xfffe)
   \   000000B4   0xF64F 0x70FF      MOVW     R0,#+65535
   \   000000B8   0x4284             CMP      R4,R0
   \   000000BA   0xD3F4             BCC.N    ??SD_WriteSingleBlock_6
    696                  {
    697                      SD_CS_DISABLE();
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x210D             MOVS     R1,#+13
   \   000000C0   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   000000C2   0x.... 0x....      BL       gpio_ctrl
    698                      return 1 ;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xE009             B.N      ??SD_WriteSingleBlock_2
    699                      //写入超时返回1
    700                  }
    701              }
    702              
    703              //写入完成，片选置1
    704              SD_CS_DISABLE();
   \                     ??SD_WriteSingleBlock_7:
   \   000000CA   0x2201             MOVS     R2,#+1
   \   000000CC   0x210D             MOVS     R1,#+13
   \   000000CE   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   000000D0   0x.... 0x....      BL       gpio_ctrl
    705              SPI_ReadWriteByte(0,0xff);
   \   000000D4   0x21FF             MOVS     R1,#+255
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      BL       SPI_ReadWriteByte
    706              
    707              return 0 ;
   \   000000DC   0x2000             MOVS     R0,#+0
   \                     ??SD_WriteSingleBlock_2:
   \   000000DE   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    708          }
    709          
    710          
    711          /*******************************************************************************
    712          * Function Name  : SD_ReadMultiBlock
    713          * Description    : 读SD卡的多个block
    714          * Input          : unsigned long sector 取地址（sector值，非物理地址）
    715          *                  unsigned char *buffer 数据存储地址（大小至少512byte）
    716          *                  unsigned char count 连续读count个block
    717          * Output         : None
    718          * Return         : unsigned char r1
    719          *                   0： 成功
    720          *                   other：失败
    721          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          unsigned char SD_ReadMultiBlock(unsigned long sector,unsigned char *buffer,unsigned char count)
    723          {
   \                     SD_ReadMultiBlock:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    724              unsigned char r1 ;
    725              
    726              //设置为高速模式
    727              SPI_SetSpeed(SPI_SPEED_HIGH);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       SPI_SetSpeed
    728              
    729              //如果不是SDHC，将sector地址转成byte地址
    730              sector=sector<<9 ;
   \   0000000E   0x0264             LSLS     R4,R4,#+9
    731              //SD_WaitReady();
    732              //发读多块命令
    733              r1=SD_SendCommand(CMD18,sector,0);
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0021             MOVS     R1,R4
   \   00000014   0x2012             MOVS     R0,#+18
   \   00000016   0x.... 0x....      BL       SD_SendCommand
    734              //读命令
    735              if(r1!=0x00)
   \   0000001A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??SD_ReadMultiBlock_0
    736              {
    737                  return r1 ;
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xE023             B.N      ??SD_ReadMultiBlock_1
    738              }
    739              //开始接收数据
    740              do 
    741              {
    742                  if(SD_ReceiveData(buffer,512,NO_RELEASE)!=0x00)
   \                     ??SD_ReadMultiBlock_0:
   \   00000024   0x2200             MOVS     R2,#+0
   \   00000026   0xF44F 0x7100      MOV      R1,#+512
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x.... 0x....      BL       SD_ReceiveData
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD106             BNE.N    ??SD_ReadMultiBlock_2
    743                  {
    744                      break ;
    745                  }
    746                  buffer+=512 ;
   \                     ??SD_ReadMultiBlock_3:
   \   00000034   0xF205 0x2500      ADDW     R5,R5,#+512
    747              }
    748              while(--count);
   \   00000038   0x1E76             SUBS     R6,R6,#+1
   \   0000003A   0x0030             MOVS     R0,R6
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD1F0             BNE.N    ??SD_ReadMultiBlock_0
    749              
    750              //全部传输完毕，发送停止命令
    751              SD_SendCommand(CMD12,0,0);
   \                     ??SD_ReadMultiBlock_2:
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x200C             MOVS     R0,#+12
   \   00000048   0x.... 0x....      BL       SD_SendCommand
    752              //释放总线
    753              SD_CS_DISABLE();
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x210D             MOVS     R1,#+13
   \   00000050   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   00000052   0x.... 0x....      BL       gpio_ctrl
    754              SPI_ReadWriteByte(0,0xFF);
   \   00000056   0x21FF             MOVS     R1,#+255
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       SPI_ReadWriteByte
    755              
    756              if(count!=0)
   \   0000005E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD002             BEQ.N    ??SD_ReadMultiBlock_4
    757              {
    758                  return count ;
   \   00000064   0x0030             MOVS     R0,R6
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0xE000             B.N      ??SD_ReadMultiBlock_1
    759                  //如果没有传完，返回剩余个数
    760              }
    761              else 
    762              {
    763                  return 0 ;
   \                     ??SD_ReadMultiBlock_4:
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??SD_ReadMultiBlock_1:
   \   0000006C   0xBD70             POP      {R4-R6,PC}       ;; return
    764              }
    765          }
    766          
    767          
    768          /*******************************************************************************
    769          * Function Name  : SD_WriteMultiBlock
    770          * Description    : 写入SD卡的N个block
    771          * Input          : unsigned long sector 扇区地址（sector值，非物理地址）
    772          *                  unsigned char *buffer 数据存储地址（大小至少512byte）
    773          *                  unsigned char count 写入的block数目
    774          * Output         : None
    775          * Return         : unsigned char r1
    776          *                   0： 成功
    777          *                   other：失败
    778          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    779          unsigned char SD_WriteMultiBlock(unsigned long sector,const unsigned char*data,unsigned char count)
    780          {
   \                     SD_WriteMultiBlock:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0015             MOVS     R5,R2
    781              unsigned char r1 ;
    782              unsigned int i ;
    783              
    784              //设置为高速模式
    785              SPI_SetSpeed(SPI_SPEED_HIGH);
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x.... 0x....      BL       SPI_SetSpeed
    786              
    787              //如果不是SDHC，给定的是sector地址，将其转换成byte地址
    788              if(SD_Type!=SD_TYPE_V2HC)
   \   0000000E   0x....             LDR.N    R0,??DataTable7_1
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD000             BEQ.N    ??SD_WriteMultiBlock_0
    789              {
    790                  sector=sector<<9 ;
   \   00000016   0x0276             LSLS     R6,R6,#+9
    791              }
    792              //如果目标卡不是MMC卡，启用ACMD23指令使能预擦除
    793              if(SD_Type!=SD_TYPE_MMC)
   \                     ??SD_WriteMultiBlock_0:
   \   00000018   0x....             LDR.N    R0,??DataTable7_1
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD006             BEQ.N    ??SD_WriteMultiBlock_1
    794              {
    795                  r1=SD_SendCommand(ACMD23,count,0x00);
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0029             MOVS     R1,R5
   \   00000026   0x2017             MOVS     R0,#+23
   \   00000028   0x.... 0x....      BL       SD_SendCommand
   \   0000002C   0x0007             MOVS     R7,R0
    796              }
    797              //发多块写入指令
    798              r1=SD_SendCommand(CMD25,sector,0x00);
   \                     ??SD_WriteMultiBlock_1:
   \   0000002E   0x2200             MOVS     R2,#+0
   \   00000030   0x0031             MOVS     R1,R6
   \   00000032   0x2019             MOVS     R0,#+25
   \   00000034   0x.... 0x....      BL       SD_SendCommand
   \   00000038   0x0007             MOVS     R7,R0
    799              if(r1!=0x00)
   \   0000003A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000003C   0x2F00             CMP      R7,#+0
   \   0000003E   0xD002             BEQ.N    ??SD_WriteMultiBlock_2
    800              {
    801                  return r1 ;
   \   00000040   0x0038             MOVS     R0,R7
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xE05F             B.N      ??SD_WriteMultiBlock_3
    802                  //应答不正确，直接返回
    803              }
    804              
    805              //开始准备数据传输
    806              SD_CS_ENABLE();
   \                     ??SD_WriteMultiBlock_2:
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x210D             MOVS     R1,#+13
   \   0000004A   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   0000004C   0x.... 0x....      BL       gpio_ctrl
    807              //先放3个空数据，等待SD卡准备好
    808              SPI_ReadWriteByte(0,0xff);
   \   00000050   0x21FF             MOVS     R1,#+255
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       SPI_ReadWriteByte
    809              SPI_ReadWriteByte(0,0xff);
   \   00000058   0x21FF             MOVS     R1,#+255
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      BL       SPI_ReadWriteByte
    810              
    811              //--------下面是N个sector写入的循环部分
    812              do 
    813              {
    814                  //放起始令牌0xFC 表明是多块写入
    815                  SPI_ReadWriteByte(0,0xFC);
   \                     ??SD_WriteMultiBlock_4:
   \   00000060   0x21FC             MOVS     R1,#+252
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      BL       SPI_ReadWriteByte
    816                  
    817                  //放一个sector的数据
    818                  for(i=0;i<512;i++)
   \   00000068   0x2600             MOVS     R6,#+0
   \   0000006A   0xE005             B.N      ??SD_WriteMultiBlock_5
    819                  {
    820                      SPI_ReadWriteByte(0,*data++);
   \                     ??SD_WriteMultiBlock_6:
   \   0000006C   0x7821             LDRB     R1,[R4, #+0]
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000074   0x1C64             ADDS     R4,R4,#+1
    821                  }
   \   00000076   0x1C76             ADDS     R6,R6,#+1
   \                     ??SD_WriteMultiBlock_5:
   \   00000078   0xF44F 0x7000      MOV      R0,#+512
   \   0000007C   0x4286             CMP      R6,R0
   \   0000007E   0xD3F5             BCC.N    ??SD_WriteMultiBlock_6
    822                  //发2个Byte的dummy CRC
    823                  SPI_ReadWriteByte(0,0xff);
   \   00000080   0x21FF             MOVS     R1,#+255
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       SPI_ReadWriteByte
    824                  SPI_ReadWriteByte(0,0xff);
   \   00000088   0x21FF             MOVS     R1,#+255
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      BL       SPI_ReadWriteByte
    825                  
    826                  //等待SD卡应答
    827                  r1=SPI_ReadWriteByte(0,0xff);
   \   00000090   0x21FF             MOVS     R1,#+255
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      BL       SPI_ReadWriteByte
   \   00000098   0x0007             MOVS     R7,R0
    828                  if((r1&0x1F)!=0x05)
   \   0000009A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000009C   0xF017 0x001F      ANDS     R0,R7,#0x1F
   \   000000A0   0x2805             CMP      R0,#+5
   \   000000A2   0xD007             BEQ.N    ??SD_WriteMultiBlock_7
    829                  {
    830                      SD_CS_DISABLE();
   \   000000A4   0x2201             MOVS     R2,#+1
   \   000000A6   0x210D             MOVS     R1,#+13
   \   000000A8   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   000000AA   0x.... 0x....      BL       gpio_ctrl
    831                      //如果应答为报错，则带错误代码直接退出
    832                      return r1 ;
   \   000000AE   0x0038             MOVS     R0,R7
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0xE028             B.N      ??SD_WriteMultiBlock_3
    833                  }
    834                  
    835                  //等待SD卡写入完成
    836                  if(SD_WaitReady()==1)
   \                     ??SD_WriteMultiBlock_7:
   \   000000B4   0x.... 0x....      BL       SD_WaitReady
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD106             BNE.N    ??SD_WriteMultiBlock_8
    837                  {
    838                      SD_CS_DISABLE();
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0x210D             MOVS     R1,#+13
   \   000000C0   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   000000C2   0x.... 0x....      BL       gpio_ctrl
    839                      //等待SD卡写入完成超时，直接退出报错
    840                      return 1 ;
   \   000000C6   0x2001             MOVS     R0,#+1
   \   000000C8   0xE01D             B.N      ??SD_WriteMultiBlock_3
    841                  }
    842                  
    843                  //本sector数据传输完成
    844              }
    845              while(--count);
   \                     ??SD_WriteMultiBlock_8:
   \   000000CA   0x1E6D             SUBS     R5,R5,#+1
   \   000000CC   0x0028             MOVS     R0,R5
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD1C5             BNE.N    ??SD_WriteMultiBlock_4
    846              
    847              //发结束传输令牌0xFD
    848              r1=SPI_ReadWriteByte(0,0xFD);
   \   000000D4   0x21FD             MOVS     R1,#+253
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x.... 0x....      BL       SPI_ReadWriteByte
   \   000000DC   0x0007             MOVS     R7,R0
    849              if(r1==0x00)
   \   000000DE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000E0   0x2F00             CMP      R7,#+0
   \   000000E2   0xD100             BNE.N    ??SD_WriteMultiBlock_9
    850              {
    851                  count=0xfe ;
   \   000000E4   0x25FE             MOVS     R5,#+254
    852              }
    853              
    854              if(SD_WaitReady())
   \                     ??SD_WriteMultiBlock_9:
   \   000000E6   0x.... 0x....      BL       SD_WaitReady
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xD000             BEQ.N    ??SD_WriteMultiBlock_10
    855              {
    856                  while(1){}
   \                     ??SD_WriteMultiBlock_11:
   \   000000EE   0xE7FE             B.N      ??SD_WriteMultiBlock_11
    857              }
    858              
    859              //写入完成，片选置1
    860              SD_CS_DISABLE();
   \                     ??SD_WriteMultiBlock_10:
   \   000000F0   0x2201             MOVS     R2,#+1
   \   000000F2   0x210D             MOVS     R1,#+13
   \   000000F4   0x....             LDR.N    R0,??DataTable7  ;; 0x400ff000
   \   000000F6   0x.... 0x....      BL       gpio_ctrl
    861              SPI_ReadWriteByte(0,0xff);
   \   000000FA   0x21FF             MOVS     R1,#+255
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x.... 0x....      BL       SPI_ReadWriteByte
    862              
    863              return count ;
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??SD_WriteMultiBlock_3:
   \   00000106   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    864              //返回count值，如果写完则count=0，否则count=1
    865          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     SD_Type

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SD_GetCID
              8 -> SD_ReceiveData
              8 -> SD_SendCommand
        8  SD_GetCSD
              8 -> SD_ReceiveData
              8 -> SD_SendCommand
       24  SD_GetCapacity
             24 -> SD_GetCSD
       24  SD_Init
             24 -> SD_SendCommand
             24 -> SD_SendCommand_NoDeassert
             24 -> SPI_ReadWriteByte
             24 -> SPI_SetSpeed
             24 -> gpio_ctrl
       16  SD_ReadMultiBlock
             16 -> SD_ReceiveData
             16 -> SD_SendCommand
             16 -> SPI_ReadWriteByte
             16 -> SPI_SetSpeed
             16 -> gpio_ctrl
       16  SD_ReadSingleBlock
             16 -> SD_ReceiveData
             16 -> SD_SendCommand
             16 -> SPI_SetSpeed
       24  SD_ReceiveData
             24 -> SPI_ReadWriteByte
             24 -> gpio_ctrl
       24  SD_SendCommand
             24 -> SPI_ReadWriteByte
             24 -> gpio_ctrl
       24  SD_SendCommand_NoDeassert
             24 -> SPI_ReadWriteByte
             24 -> gpio_ctrl
        8  SD_WaitReady
              8 -> SPI_ReadWriteByte
       24  SD_WriteMultiBlock
             24 -> SD_SendCommand
             24 -> SD_WaitReady
             24 -> SPI_ReadWriteByte
             24 -> SPI_SetSpeed
             24 -> gpio_ctrl
       16  SD_WriteSingleBlock
             16 -> SD_SendCommand
             16 -> SPI_ReadWriteByte
             16 -> SPI_SetSpeed
             16 -> gpio_ctrl


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
      38  SD_GetCID
      38  SD_GetCSD
     152  SD_GetCapacity
     548  SD_Init
     110  SD_ReadMultiBlock
      68  SD_ReadSingleBlock
     132  SD_ReceiveData
     144  SD_SendCommand
     120  SD_SendCommand_NoDeassert
       1  SD_Type
      36  SD_WaitReady
     264  SD_WriteMultiBlock
     224  SD_WriteSingleBlock

 
     1 byte  in section .bss
 1 882 bytes in section .text
 
 1 882 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: none
