###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        12/Mar/2016  23:02:56
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  E:\Sirius V2.5\src\Sources\C\Function_C\ImagePro.c
#    Command line =  
#        "E:\Sirius V2.5\src\Sources\C\Function_C\ImagePro.c" -D IAR -D
#        TWR_K60N512 -lCN "E:\Sirius V2.5\bin\Flash\List\" -lB "E:\Sirius
#        V2.5\bin\Flash\List\" -o "E:\Sirius V2.5\bin\Flash\Obj\" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I "E:\Sirius V2.5\src\Sources\H\"
#        -I "E:\Sirius V2.5\src\Sources\H\Component_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Frame_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\Function_H\" -I "E:\Sirius
#        V2.5\src\Sources\H\SD_H\" -Ol --use_c++_inline
#    List file    =  E:\Sirius V2.5\bin\Flash\List\ImagePro.lst
#    Object file  =  E:\Sirius V2.5\bin\Flash\Obj\ImagePro.o
#
###############################################################################

E:\Sirius V2.5\src\Sources\C\Function_C\ImagePro.c
      1          /******************************************************************************/
      2          /*******************************************************************************
      3            文件名：图像处理程序文件ImagePro.c
      4            功  能：图像处理
      5            日  期：2014.10.09
      6            作  者：HJZ
      7            备  注：
      8          *******************************************************************************/
      9          /******************************************************************************/
     10          
     11          #include "ImagePro.h"
     12          
     13          //中心线提取时，实际赛道宽度的一半对应的像素点数。是固定角度后测得的值。

   \                                 In section .rodata, align 4
     14          uint8 const CenterLineHalfWidth[CameraHight] =  
   \                     CenterLineHalfWidth:
   \   00000000   0x1A 0x1B          DC8 26, 27, 28, 30, 31, 33, 34, 36, 37, 38, 40, 41, 43, 44, 46, 47, 48
   \              0x1C 0x1E    
   \              0x1F 0x21    
   \              0x22 0x24    
   \              0x25 0x26    
   \              0x28 0x29    
   \              0x2B 0x2C    
   \              0x2E 0x2F    
   \              0x30         
   \   00000011   0x31 0x33          DC8 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x39 0x3A    
   \              0x3B 0x3C    
   \              0x3D 0x3E    
   \              0x3F 0x41    
   \              0x42 0x43    
   \              0x44         
   \   00000022   0x45 0x46          DC8 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84
   \              0x47 0x48    
   \              0x49 0x4A    
   \              0x4B 0x4C    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x54    
   \   00000032   0x00 0x00          DC8 0, 0
     15          {
     16          26,27,28,30,31,33,34,36,37,38,40,41,43,44,46,47,48,49,51,52,53,54,55,57,58,
     17          59,60,61,62,63,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84
     18          };
     19          

   \                                 In section .rodata, align 4
     20          uint8 const CenterLineHalfWidth02[CameraHight] =  
   \                     CenterLineHalfWidth02:
   \   00000000   0x2E 0x2F          DC8 46, 47, 48, 50, 51, 53, 54, 56, 57, 58, 60, 61, 63, 64, 66, 67, 68
   \              0x30 0x32    
   \              0x33 0x35    
   \              0x36 0x38    
   \              0x39 0x3A    
   \              0x3C 0x3D    
   \              0x3F 0x40    
   \              0x42 0x43    
   \              0x44         
   \   00000011   0x45 0x47          DC8 69, 71, 72, 73, 74, 75, 77, 78, 79, 80, 81, 82, 83, 85, 86, 87, 88
   \              0x48 0x49    
   \              0x4A 0x4B    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x55    
   \              0x56 0x57    
   \              0x58         
   \   00000022   0x59 0x5A          DC8 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104
   \              0x5B 0x5C    
   \              0x5D 0x5E    
   \              0x5F 0x60    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x67 0x68    
   \   00000032   0x00 0x00          DC8 0, 0
     21          {
     22          46,47,48,50,51,53,54,56,57,58,60,61,63,64,66,67,68,69,71,72,73,74,75,77,78,
     23          79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104
     24          };
     25          

   \                                 In section .bss, align 4
     26          uint8 ImgNew[CameraHight][CameraRealWidth];       //重新处理后的数据储存数组
   \                     ImgNew:
   \   00000000                      DS8 12500

   \                                 In section .bss, align 4
     27          uint8 BlackLeftLoc[CameraHight][3];       //左黑线位置存储数组
   \                     BlackLeftLoc:
   \   00000000                      DS8 152

   \                                 In section .bss, align 4
     28          uint8 BlackRightLoc[CameraHight][3];      //右黑线位置存储数组
   \                     BlackRightLoc:
   \   00000000                      DS8 152

   \                                 In section .bss, align 4
     29          uint8 CenterLineLoc[CameraHight];      //中心线位置存储数组, 255为无效值
   \                     CenterLineLoc:
   \   00000000                      DS8 52
     30          //uint8 MaxValUint8 = 255;             //自定义的无效值

   \                                 In section .data, align 1
     31          uint8 CenterLineResult = 1;             //中心线提取成功标志
   \                     CenterLineResult:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
     32          uint8 CenterKeyLine = 25;                  //固定的要选取的行。
   \                     CenterKeyLine:
   \   00000000   0x19               DC8 25

   \                                 In section .data, align 1
     33          uint8 CenterLocStore = MaxValUint8;         //左右黑线都提取到的时候，保存的CenterLineLoc[CameraHight - 1]。
   \                     CenterLocStore:
   \   00000000   0xFF               DC8 255
     34          

   \                                 In section .bss, align 1
     35          uint8 PathType = 0;                       //0未知 1直道 2左中 3右中 4左内 5左外 6右内 7右外
   \                     PathType:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     36          uint8 CurveLineChosenC1 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     37          uint8 CurveLineChosenC2 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     38          uint8 CurveLineChosenC3 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     39          uint8 CurveLineChosenL1 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     40          uint8 CurveLineChosenL2 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     41          uint8 CurveLineChosenL3 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     42          uint8 CurveLineChosenR1 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     43          uint8 CurveLineChosenR2 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     44          uint8 CurveLineChosenR3 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     45          int16 SABCL = 0;                          //曲率求取时，左黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     46          int16 SABCC = 0;                          //曲率求取时，中心线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     47          int16 SABCR = 0;                          //曲率求取时，右黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCR:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     48          int16 CURVEL = 0;                          //曲率求取时，左黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     49          int16 CURVEC = 0;                          //曲率求取时，中心线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     50          int16 CURVER = 0;                          //曲率求取时，右黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVER:
   \   00000000                      DS8 2

   \                                 In section .data, align 2
     51          int16 PathStraightLimitL = 20;           //赛道类型判断时，左黑线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitL:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     52          int16 PathStraightLimitC = 20;           //赛道类型判断时，中心线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitC:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     53          int16 PathStraightLimitR = 20;           //赛道类型判断时，右黑线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitR:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     54          int16 CurveGetCompen = 2000;             //曲率求取时，为了不使数太小，乘的补偿量。
   \                     CurveGetCompen:
   \   00000000   0x07D0             DC16 2000
     55          

   \                                 In section .bss, align 1
     56          uint8 ErrorGetSelf;                 //平均值与自身的偏差，也就是curve
   \                     ErrorGetSelf:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     57          uint8 ErrorGetCen;                 //平均值与物理中心线的偏差。
   \                     ErrorGetCen:
   \   00000000                      DS8 1
     58          
     59          //左

   \                                 In section .bss, align 2
     60          uint8 BlackLeftRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitLeftWB
   \                     BlackLeftRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     61          uint8 BlackLeftRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitLeftB
   \                     BlackLeftRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     62          uint8 BlackLeftRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitLeftW
   \                     BlackLeftRealW:
   \   00000000                      DS8 2
     63          //右

   \                                 In section .bss, align 2
     64          uint8 BlackRightRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitRightWB
   \                     BlackRightRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     65          uint8 BlackRightRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitRightB
   \                     BlackRightRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     66          uint8 BlackRightRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitRightW
   \                     BlackRightRealW:
   \   00000000                      DS8 2
     67          
     68          
     69          //左
     70          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .data, align 1
     71          uint8 LimitLeftWB = LimitOriLeftWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitLeftWB:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
     72          uint8 LimitLeftW = LimitOriLeftW;      //白点必须要大于此值
   \                     LimitLeftW:
   \   00000000   0x96               DC8 150

   \                                 In section .data, align 1
     73          uint8 LimitLeftB = LimitOriLeftB;      //黑点必须要小于此值
   \                     LimitLeftB:
   \   00000000   0x50               DC8 80
     74          

   \                                 In section .bss, align 1
     75          uint8 BlackLeftCrossDone = 0;    //左黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackLeftCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     76          uint8 BlackLeftDone = 1;          //左黑线提取成功标示位 1成功 0失败
   \                     BlackLeftDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
     77          uint8 BlackLeft3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackLeft3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     78          uint8 BlackLeftCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackLeftCrossTooLowLine:
   \   00000000   0x03               DC8 3
     79          //uint8 BlackLeftStep4Flag = 0;          //左黑线需要执行第4阶段的标志位，1需执行，0不需执行。
     80          //uint8 BlackLeftStep4StartLine = 0;     //左黑线第4阶段起始行

   \                                 In section .data, align 1
     81          uint8 BlackLeftHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
   \                     BlackLeftHeadLine:
   \   00000000   0xFF               DC8 255
     82          
     83          //右
     84          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .data, align 1
     85          uint8 LimitRightWB = LimitOriRightWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitRightWB:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
     86          uint8 LimitRightW = LimitOriRightW;      //白点必须要大于此值
   \                     LimitRightW:
   \   00000000   0x96               DC8 150

   \                                 In section .data, align 1
     87          uint8 LimitRightB = LimitOriRightB;      //黑点必须要小于此值
   \                     LimitRightB:
   \   00000000   0x50               DC8 80
     88          

   \                                 In section .bss, align 1
     89          uint8 BlackRightCrossDone = 0;   //右黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackRightCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     90          uint8 BlackRightDone = 1;          //右黑线提取成功标示位 1成功 0失败
   \                     BlackRightDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
     91          uint8 BlackRight3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackRight3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     92          uint8 BlackRightCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackRightCrossTooLowLine:
   \   00000000   0x03               DC8 3
     93          //uint8 BlackRightStep4Flag = 0;          //右黑线需要执行第4阶段的标志位，1需执行，0不需执行。
     94          //uint8 BlackRightStep4StartLine = 0;     //右黑线第4阶段起始行

   \                                 In section .data, align 1
     95          uint8 BlackRightHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
   \                     BlackRightHeadLine:
   \   00000000   0xFF               DC8 255
     96          
     97          
     98          //自身绝对值求值，只适合于int16型变量，返回int16型变量。

   \                                 In section .text, align 2, keep-with-next
     99          int16 AbsSelf(int16 x)
    100          {
    101            if(x < 0) return (0-x);
   \                     AbsSelf: (+1)
   \   00000000   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD503             BPL.N    ??AbsSelf_0
   \   00000006   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000008   0x4240             RSBS     R0,R0,#+0
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xE000             B.N      ??AbsSelf_1
    102            else return x;  
   \                     ??AbsSelf_0: (+1)
   \   0000000E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??AbsSelf_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    103          }
    104          
    105          //======================================================================
    106          //函数名：MaxRe
    107          //功  能：求取两数最大值
    108          //参  数：第1个数num1, 第2个数num2。
    109          //返  回：2个数中的最大值
    110          //影  响：无
    111          //说  明：1. 两个输入参数无先后顺序。
    112          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    113          //        3. 返回值的类型也是uint8.
    114          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    115          uint8 MaxRe(uint8 num1, uint8 num2)
    116          {
    117            if(num1 >= num2)
   \                     MaxRe: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD301             BCC.N    ??MaxRe_0
    118            {
    119              return num1;
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE001             B.N      ??MaxRe_1
    120            }
    121            else
    122            {
    123              return num2;
   \                     ??MaxRe_0: (+1)
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MaxRe_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    124            }
    125          }
    126          
    127          //======================================================================
    128          //函数名：MinRe
    129          //功  能：求取两数最小值
    130          //参  数：第1个数num1, 第2个数num2。
    131          //返  回：2个数中的最小值
    132          //影  响：无
    133          //说  明：1. 两个输入参数无先后顺序。
    134          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    135          //        3. 返回值的类型也是uint8.     
    136          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    137          uint8 MinRe(uint8 num1, uint8 num2)
    138          {
    139            if(num1 <= num2)
   \                     MinRe: (+1)
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD301             BCC.N    ??MinRe_0
    140            {
    141              return num1;  
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE001             B.N      ??MinRe_1
    142            }
    143            else
    144            {
    145              return num2;  
   \                     ??MinRe_0: (+1)
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MinRe_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    146            }
    147          }
    148          
    149          //======================================================================
    150          //函数名：AbsRe
    151          //功  能：求取两数差值的绝对值
    152          //参  数：第1个数num1, 第2个数num2。
    153          //返  回：2个数的绝对值。
    154          //影  响：无
    155          //说  明：1. 两个输入参数无先后顺序。
    156          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    157          //        3. 返回值的类型也是uint8.     
    158          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    159          uint8 AbsRe(uint8 num1, uint8 num2)
    160          {
    161            if(num1 >= num2)
   \                     AbsRe: (+1)
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD302             BCC.N    ??AbsRe_0
    162            {
    163              return (num1 - num2);  
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xE001             B.N      ??AbsRe_1
    164            }
    165            else
    166            {
    167              return (num2 - num1);  
   \                     ??AbsRe_0: (+1)
   \   0000000E   0x1A08             SUBS     R0,R1,R0
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??AbsRe_1: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    168            }
    169          }
    170          
    171          
    172          //======================================================================
    173          //函数名：LeastSquarea1
    174          //功  能：最小二乘法的a1值的求取
    175          //参  数：x数组，y数组，num基于的有效数据个数
    176          //返  回：a1
    177          //影  响：无
    178          //说  明：1. y = a0 + a1 * x;
    179          //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
    180          //  
    181          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    182          float LeastSquarea1(uint8 x[], uint8 y[], uint8 num)
    183          {
   \                     LeastSquarea1: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0014             MOVS     R4,R2
    184            float andxy = 0, andx = 0, andy = 0, andx2 = 0;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000014   0x2600             MOVS     R6,#+0
    185            float a1;
    186            uint8 i;
    187           
    188            for(i = 0; i < num; i++)
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000001A   0xE033             B.N      ??LeastSquarea1_0
    189            {
    190              andxy += x[i] * y[i];
   \                     ??LeastSquarea1_1: (+1)
   \   0000001C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000020   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   00000024   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000028   0xF81B 0x1008      LDRB     R1,[R11, R8]
   \   0000002C   0x4348             MULS     R0,R1,R0
   \   0000002E   0x.... 0x....      BL       __aeabi_i2f
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4681             MOV      R9,R0
    191              andx += x[i];
   \   0000003A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000003E   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   00000042   0x.... 0x....      BL       __aeabi_ui2f
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x.... 0x....      BL       __aeabi_fadd
   \   0000004C   0x0005             MOVS     R5,R0
    192              andy += y[i];
   \   0000004E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000052   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \   00000056   0x.... 0x....      BL       __aeabi_ui2f
   \   0000005A   0x4651             MOV      R1,R10
   \   0000005C   0x.... 0x....      BL       __aeabi_fadd
   \   00000060   0x4682             MOV      R10,R0
    193              andx2 += x[i] * x[i];
   \   00000062   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000066   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   0000006A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000006E   0xF81B 0x1007      LDRB     R1,[R11, R7]
   \   00000072   0x4348             MULS     R0,R1,R0
   \   00000074   0x.... 0x....      BL       __aeabi_i2f
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0x.... 0x....      BL       __aeabi_fadd
   \   0000007E   0x0006             MOVS     R6,R0
    194            }
   \   00000080   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??LeastSquarea1_0: (+1)
   \   00000084   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x45A3             CMP      R11,R4
   \   0000008C   0xD3C6             BCC.N    ??LeastSquarea1_1
    195            
    196            a1 = (num * andxy - andx * andy) * 1.0 / (num * andx2 - andx * andx);
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       __aeabi_ui2f
   \   00000096   0x4649             MOV      R1,R9
   \   00000098   0x.... 0x....      BL       __aeabi_fmul
   \   0000009C   0x0007             MOVS     R7,R0
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0x4651             MOV      R1,R10
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x0001             MOVS     R1,R0
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x.... 0x....      BL       __aeabi_f2d
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x3ff00000
   \   000000B8   0x.... 0x....      BL       __aeabi_dmul
   \   000000BC   0x4680             MOV      R8,R0
   \   000000BE   0x4689             MOV      R9,R1
   \   000000C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       __aeabi_ui2f
   \   000000C8   0x0031             MOVS     R1,R6
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x0004             MOVS     R4,R0
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x0029             MOVS     R1,R5
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x0001             MOVS     R1,R0
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       __aeabi_fsub
   \   000000E0   0x.... 0x....      BL       __aeabi_f2d
   \   000000E4   0x0002             MOVS     R2,R0
   \   000000E6   0x000B             MOVS     R3,R1
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x4649             MOV      R1,R9
   \   000000EC   0x.... 0x....      BL       __aeabi_ddiv
   \   000000F0   0x.... 0x....      BL       __aeabi_d2f
    197            return a1;  
   \   000000F4   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    198          }
    199          
    200          
    201          //======================================================================
    202          //函数名：LeastSquarea0
    203          //功  能：最小二乘法的a0值的求取
    204          //参  数：x数组，y数组，a1参数，num基于的有效数据个数
    205          //返  回：a0
    206          //影  响：无
    207          //说  明：1. y = a0 + a1 * x;
    208          //        2. a0 = Σy / N - a1 * Σx / N;
    209          //             
    210          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    211          float LeastSquarea0(uint8 x[], uint8 y[], float a1, uint8 num)
    212          {
   \                     LeastSquarea0: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001C             MOVS     R4,R3
    213            float andx = 0, andy = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    214            float a0;
    215            uint8 i;
    216            for(i = 0; i < num; i++)
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000018   0xE015             B.N      ??LeastSquarea0_0
    217            {
    218              andx += x[i];
   \                     ??LeastSquarea0_1: (+1)
   \   0000001A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000001E   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   00000022   0x.... 0x....      BL       __aeabi_ui2f
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4680             MOV      R8,R0
    219              andy += y[i];
   \   0000002E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000032   0xF81A 0x0006      LDRB     R0,[R10, R6]
   \   00000036   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0x.... 0x....      BL       __aeabi_fadd
   \   00000040   0x4681             MOV      R9,R0
    220            }
   \   00000042   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??LeastSquarea0_0: (+1)
   \   00000046   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x45A2             CMP      R10,R4
   \   0000004E   0xD3E4             BCC.N    ??LeastSquarea0_1
    221            
    222            a0 = andy / num - a1 * andx / num;
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       __aeabi_ui2f
   \   00000058   0x0001             MOVS     R1,R0
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000060   0x0005             MOVS     R5,R0
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x0006             MOVS     R6,R0
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       __aeabi_ui2f
   \   00000074   0x0001             MOVS     R1,R0
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       __aeabi_fdiv
   \   0000007C   0x0001             MOVS     R1,R0
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0x.... 0x....      BL       __aeabi_fsub
    223            return a0;
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    224          }
    225          
    226          
    227          
    228          
    229          
    230          //======================================================================
    231          //函数名：SendCenterLineLoc
    232          //功  能：中心线数组发送函数
    233          //参  数：img待发送的一维图像数组
    234          //返  回：无
    235          //影  响：无
    236          //说  明：
    237          //      
    238          //          
    239          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    240          void SendCenterLineLoc(uint8 img[CameraHight])
    241          {
   \                     SendCenterLineLoc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    242              uint8 i;
    243              uint8 cmd[4] = {0, 255, 1, 255 };   
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    244              uart_sendN(UART0, cmd, sizeof(cmd));    
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000016   0x.... 0x....      BL       uart_sendN
    245              for(i = 0; i < CameraHight; i++)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE006             B.N      ??SendCenterLineLoc_0
    246              {
    247                uart_send1(UART0, img[i]); //发送中心线数组
   \                     ??SendCenterLineLoc_1: (+1)
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x5D29             LDRB     R1,[R5, R4]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000026   0x.... 0x....      BL       uart_send1
    248              }
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendCenterLineLoc_0: (+1)
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D32             CMP      R5,#+50
   \   00000030   0xDBF5             BLT.N    ??SendCenterLineLoc_1
    249              
    250          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    251          
    252          
    253          
    254          
    255          //======================================================================
    256          //函数名：SendImage
    257          //功  能：OV7620的图像发送函数
    258          //参  数：待发送的二维图像数组imgaddr
    259          //返  回：无
    260          //影  响：无
    261          //说  明：       
    262          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    263          void SendImage(uint8 imgaddr[CameraHight][CameraRealWidth])
    264          {                            
   \                     SendImage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    265              uint8 i, j;
    266              uint8 cmd[4] = {0, 255, 1, 0 };
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable10_2
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    267            
    268              uart_sendN(UART0, cmd, sizeof(cmd));    
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000018   0x.... 0x....      BL       uart_sendN
    269              
    270              for(i = 0; i < CameraHight; i++)
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0xE00E             B.N      ??SendImage_0
    271                  for(j = 0; j < CameraRealWidth; j++)
    272                      uart_send1(UART0, imgaddr[i][j]); //发送图像
   \                     ??SendImage_1: (+1)
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x20FA             MOVS     R0,#+250
   \   00000026   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000002A   0x5C31             LDRB     R1,[R6, R0]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000030   0x.... 0x....      BL       uart_send1
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   \                     ??SendImage_2: (+1)
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2EFA             CMP      R6,#+250
   \   0000003A   0xDBF1             BLT.N    ??SendImage_1
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendImage_0: (+1)
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D32             CMP      R5,#+50
   \   00000042   0xDA01             BGE.N    ??SendImage_3
   \   00000044   0x2600             MOVS     R6,#+0
   \   00000046   0xE7F6             B.N      ??SendImage_2
    273          }
   \                     ??SendImage_3: (+1)
   \   00000048   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    274          
    275          
    276          
    277          //====================================左左左左左左左左左左左左左左左左左============================
    278          
    279          //======================================================================
    280          //函数名：BlackLeftRealClear
    281          //功  能：左黑线提取中，对3个关键值的实际值清零
    282          //参  数：无
    283          //返  回：无
    284          //影  响：B
    285          //说  明：
    286          //      
    287          //             
    288          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    289          void BlackLeftRealClear(void)
    290          {
    291              BlackLeftRealWB[0] = 0;
   \                     BlackLeftRealClear: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    292              BlackLeftRealWB[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
    293              BlackLeftRealW[0] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000016   0x7008             STRB     R0,[R1, #+0]
    294              BlackLeftRealW[1] = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
    295              BlackLeftRealB[0] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    296              BlackLeftRealB[1] = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
    297          }
   \   00000030   0x4770             BX       LR               ;; return
    298          
    299          
    300          
    301          
    302          //======================================================================
    303          //函数名：BlackGetLeftStep1Edge
    304          //功  能：处理该行左线的可疑黑点
    305          //参  数：待检测的行号row, 第几次使用use, 是否为十字再检测调用标志位CrossFlag
    306          //返  回：1成功 0失败
    307          //影  响：
    308          //说  明：
    309          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    310          uint8 BlackGetLeftStep1Edge(uint8 row, uint8 use, uint8 CrossFlag)
    311          {
   \                     BlackGetLeftStep1Edge: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    312            uint8 index, col, temp, temp1;
    313            uint8 abs1;
    314            
    315            temp = CameraRealWidth/2 - 1 + BlackLeftEdgeStartColOffset;
   \   0000000A   0xF05F 0x08A4      MOVS     R8,#+164
    316            
    317            index = 0;         //可疑点的序号
   \   0000000E   0x2700             MOVS     R7,#+0
    318            for(col = temp; col >= 4+BlackLeftEdgeNum; col--) 
   \   00000010   0xE045             B.N      ??BlackGetLeftStep1Edge_0
    319            {
    320                abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col-1-BlackLeftEdgeNum]); //取差值的绝对值。
    321                
    322                if( 
    323                    (abs1 > LimitLeftWB) //两者的差够大
    324                  &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
    325                  &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
    326                   )
    327                {         
    328                    //近处的行，向左3个点仍为黑点
    329                    if(row > BlackMiddleLine)
    330                    {
    331                      temp1 = (
    332                                (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    333                              &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    334                              &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
    335                              );
    336                    }          
    337                    else
    338                    {
    339                      //远处的行 ，向左2个点为仍为黑点
    340                      if(row > BlackFarLine)
    341                      {
    342                        temp1 = (
    343                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    344                                &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    345                                );
    346                      }
    347                      //远处的行 ，向左1个点为仍为黑点
    348                      else
    349                      {
    350                        temp1 = (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB);
    351                      }
    352                    }
    353          
    354                    if(temp1)
    355                    {
    356                        if(index == 3)       
    357                        {
    358                          if(CrossFlag)
    359                          {
    360                            //对3个关键值的实际值清零
    361                            BlackLeftRealClear();
    362                          }
    363                          //该行定位黑线失败，赋无效值
    364                          BlackLeftLoc[row][0] = MaxValUint8;
    365                          return 0;
    366                        }
    367          
    368                        if(CrossFlag)
    369                        {
    370                          if(use == 1)
    371                          {
    372                            BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
    373                            BlackLeftRealW[0] = ImgNew[row][col];
    374                            BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
    375                          }
    376                          else if(use == 2)
   \                     ??BlackGetLeftStep1Edge_1: (+1)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD135             BNE.N    ??BlackGetLeftStep1Edge_2
    377                          {
    378                            BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   00000018   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x20FA             MOVS     R0,#+250
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000024   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000028   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000002C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x21FA             MOVS     R1,#+250
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   00000038   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000003C   0xEB18 0x0101      ADDS     R1,R8,R1
   \   00000040   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000004A   0x7048             STRB     R0,[R1, #+1]
    379                            BlackLeftRealW[1] = ImgNew[row][col];
   \   0000004C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x20FA             MOVS     R0,#+250
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000058   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000005C   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000064   0x7048             STRB     R0,[R1, #+1]
    380                            BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x20FA             MOVS     R0,#+250
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000072   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000076   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000007A   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000082   0x7048             STRB     R0,[R1, #+1]
    381                          }
    382                          else
    383                          {
    384                          }
    385                        }
    386                        //跳变检测成功，取黑点
    387                        BlackLeftLoc[row][index] = col - 1 - BlackLeftEdgeNum;          
   \                     ??BlackGetLeftStep1Edge_2: (+1)
   \   00000084   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \   0000008E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000092   0xF1B8 0x0103      SUBS     R1,R8,#+3
   \   00000096   0x5439             STRB     R1,[R7, R0]
    388                        index++;            
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlackGetLeftStep1Edge_3: (+1)
   \   0000009A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??BlackGetLeftStep1Edge_0: (+1)
   \   0000009E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A2   0xF1B8 0x0F06      CMP      R8,#+6
   \   000000A6   0xF2C0 0x810A      BLT.W    ??BlackGetLeftStep1Edge_4
   \   000000AA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x20FA             MOVS     R0,#+250
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000000B6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000BA   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000BE   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \   000000C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x20FA             MOVS     R0,#+250
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   000000CE   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   000000D2   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000000D6   0x.... 0x....      BL       AbsRe
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000000DE   0x7809             LDRB     R1,[R1, #+0]
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x4281             CMP      R1,R0
   \   000000E4   0xD2D9             BCS.N    ??BlackGetLeftStep1Edge_3
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x21FA             MOVS     R1,#+250
   \   000000F4   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   000000F8   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000FC   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD2CA             BCS.N    ??BlackGetLeftStep1Edge_3
   \   00000104   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0x20FA             MOVS     R0,#+250
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000110   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000114   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000118   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000120   0x7809             LDRB     R1,[R1, #+0]
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD2B9             BCS.N    ??BlackGetLeftStep1Edge_3
   \   00000126   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000128   0x2C1F             CMP      R4,#+31
   \   0000012A   0xDB36             BLT.N    ??BlackGetLeftStep1Edge_5
   \   0000012C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000130   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000132   0x20FA             MOVS     R0,#+250
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000138   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000013C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000140   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000148   0x7809             LDRB     R1,[R1, #+0]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD223             BCS.N    ??BlackGetLeftStep1Edge_6
   \   0000014E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000152   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000154   0x20FA             MOVS     R0,#+250
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000015A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000015E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000162   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   0000016A   0x7809             LDRB     R1,[R1, #+0]
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xD212             BCS.N    ??BlackGetLeftStep1Edge_6
   \   00000170   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000174   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000176   0x20FA             MOVS     R0,#+250
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000017C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000180   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000184   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   0000018C   0x7809             LDRB     R1,[R1, #+0]
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xD201             BCS.N    ??BlackGetLeftStep1Edge_6
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xE000             B.N      ??BlackGetLeftStep1Edge_7
   \                     ??BlackGetLeftStep1Edge_6: (+1)
   \   00000196   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_7: (+1)
   \   00000198   0xE03C             B.N      ??BlackGetLeftStep1Edge_8
   \                     ??BlackGetLeftStep1Edge_5: (+1)
   \   0000019A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019C   0x2C15             CMP      R4,#+21
   \   0000019E   0xDB25             BLT.N    ??BlackGetLeftStep1Edge_9
   \   000001A0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A6   0x20FA             MOVS     R0,#+250
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000001AC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001B0   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001B4   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000001BC   0x7809             LDRB     R1,[R1, #+0]
   \   000001BE   0x4288             CMP      R0,R1
   \   000001C0   0xD212             BCS.N    ??BlackGetLeftStep1Edge_10
   \   000001C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C8   0x20FA             MOVS     R0,#+250
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000001CE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001D2   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001D6   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000001DE   0x7809             LDRB     R1,[R1, #+0]
   \   000001E0   0x4288             CMP      R0,R1
   \   000001E2   0xD201             BCS.N    ??BlackGetLeftStep1Edge_10
   \   000001E4   0x2001             MOVS     R0,#+1
   \   000001E6   0xE000             B.N      ??BlackGetLeftStep1Edge_11
   \                     ??BlackGetLeftStep1Edge_10: (+1)
   \   000001E8   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_11: (+1)
   \   000001EA   0xE013             B.N      ??BlackGetLeftStep1Edge_8
   \                     ??BlackGetLeftStep1Edge_9: (+1)
   \   000001EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F2   0x20FA             MOVS     R0,#+250
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000001F8   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001FC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000200   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000208   0x7809             LDRB     R1,[R1, #+0]
   \   0000020A   0x4288             CMP      R0,R1
   \   0000020C   0xD201             BCS.N    ??BlackGetLeftStep1Edge_12
   \   0000020E   0x2001             MOVS     R0,#+1
   \   00000210   0xE000             B.N      ??BlackGetLeftStep1Edge_13
   \                     ??BlackGetLeftStep1Edge_12: (+1)
   \   00000212   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_13: (+1)
   \                     ??BlackGetLeftStep1Edge_8: (+1)
   \   00000214   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xF43F 0xAF3F      BEQ.W    ??BlackGetLeftStep1Edge_3
   \   0000021C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000021E   0x2F03             CMP      R7,#+3
   \   00000220   0xD10E             BNE.N    ??BlackGetLeftStep1Edge_14
   \   00000222   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000224   0x2E00             CMP      R6,#+0
   \   00000226   0xD001             BEQ.N    ??BlackGetLeftStep1Edge_15
   \   00000228   0x.... 0x....      BL       BlackLeftRealClear
   \                     ??BlackGetLeftStep1Edge_15: (+1)
   \   0000022C   0x20FF             MOVS     R0,#+255
   \   0000022E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000230   0x2103             MOVS     R1,#+3
   \   00000232   0x.... 0x....      LDR.W    R2,??DataTable12_3
   \   00000236   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000023A   0x7008             STRB     R0,[R1, #+0]
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xE051             B.N      ??BlackGetLeftStep1Edge_16
   \                     ??BlackGetLeftStep1Edge_14: (+1)
   \   00000240   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000242   0x2E00             CMP      R6,#+0
   \   00000244   0xF43F 0xAF1E      BEQ.W    ??BlackGetLeftStep1Edge_2
   \   00000248   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024A   0x2D01             CMP      R5,#+1
   \   0000024C   0xF47F 0xAEE1      BNE.W    ??BlackGetLeftStep1Edge_1
   \   00000250   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000254   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000256   0x20FA             MOVS     R0,#+250
   \   00000258   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000025C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000260   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000264   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000268   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000026A   0x21FA             MOVS     R1,#+250
   \   0000026C   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   00000270   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000274   0xEB18 0x0101      ADDS     R1,R8,R1
   \   00000278   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   0000027C   0x1A40             SUBS     R0,R0,R1
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000282   0x7008             STRB     R0,[R1, #+0]
   \   00000284   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000288   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000028A   0x20FA             MOVS     R0,#+250
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000290   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000294   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000298   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   0000029C   0x7008             STRB     R0,[R1, #+0]
   \   0000029E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A4   0x20FA             MOVS     R0,#+250
   \   000002A6   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000002AA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002AE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000002B2   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   000002BA   0x7008             STRB     R0,[R1, #+0]
   \   000002BC   0xE6E2             B.N      ??BlackGetLeftStep1Edge_2
    389                    }    
    390                }   
    391            }
    392            
    393            //1个可疑黑点也没有，则报错。
    394            if(index == 0)
   \                     ??BlackGetLeftStep1Edge_4: (+1)
   \   000002BE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002C0   0x2F00             CMP      R7,#+0
   \   000002C2   0xD10E             BNE.N    ??BlackGetLeftStep1Edge_17
    395            {
    396              if(CrossFlag)
   \   000002C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002C6   0x2E00             CMP      R6,#+0
   \   000002C8   0xD001             BEQ.N    ??BlackGetLeftStep1Edge_18
    397              {
    398                //对3个关键值的实际值清零
    399                BlackLeftRealClear();
   \   000002CA   0x.... 0x....      BL       BlackLeftRealClear
    400              }
    401              //该行定位黑线失败，赋无效值
    402              BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftStep1Edge_18: (+1)
   \   000002CE   0x20FF             MOVS     R0,#+255
   \   000002D0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D2   0x2103             MOVS     R1,#+3
   \   000002D4   0x.... 0x....      LDR.W    R2,??DataTable12_3
   \   000002D8   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000002DC   0x7008             STRB     R0,[R1, #+0]
    403              return 0;
   \   000002DE   0x2000             MOVS     R0,#+0
   \   000002E0   0xE000             B.N      ??BlackGetLeftStep1Edge_16
    404            }
    405            
    406            //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
    407            return 1;
   \                     ??BlackGetLeftStep1Edge_17: (+1)
   \   000002E2   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeftStep1Edge_16: (+1)
   \   000002E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    408          }
    409          
    410          
    411          
    412          //======================================================================
    413          //函数名：BlackGetLeftStep2Win
    414          //功  能：窗口内跳变检测函数
    415          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict
    416          //返  回：1成功  0失败
    417          //影  响：
    418          //说  明：  
    419          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    420          uint8 BlackGetLeftStep2Win(uint8 row, uint8 win, uint8 predict)
    421          {
   \                     BlackGetLeftStep2Win: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    422            uint8 col, temp, temp1;
    423            uint8 abs1;
    424          
    425            //在规划好的窗口内，从右往左查找跳变沿
    426            //防止溢出
    427            
    428            //对左边界的限制
    429            if(predict <= win)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD301             BCC.N    ??BlackGetLeftStep2Win_0
    430            {
    431              temp = 4 + BlackLeftEdgeNum;
   \   0000000C   0x2506             MOVS     R5,#+6
   \   0000000E   0xE004             B.N      ??BlackGetLeftStep2Win_1
    432            }  
    433            else
    434            {
    435              temp = predict - win;
   \                     ??BlackGetLeftStep2Win_0: (+1)
   \   00000010   0x1A55             SUBS     R5,R2,R1
    436              if(temp < 4 + BlackLeftEdgeNum)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D06             CMP      R5,#+6
   \   00000016   0xDA00             BGE.N    ??BlackGetLeftStep2Win_1
    437              {
    438                temp = 4 + BlackLeftEdgeNum;
   \   00000018   0x2506             MOVS     R5,#+6
    439              }
    440              else 
    441              {
    442              } 
    443            }
    444            
    445            //对右边界的限制
    446            if(predict + win > CameraRealWidth - 1)
   \                     ??BlackGetLeftStep2Win_1: (+1)
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   00000020   0x28FA             CMP      R0,#+250
   \   00000022   0xDB01             BLT.N    ??BlackGetLeftStep2Win_2
    447            {
    448              col = CameraRealWidth - 1;  
   \   00000024   0x26F9             MOVS     R6,#+249
   \   00000026   0xE002             B.N      ??BlackGetLeftStep2Win_3
    449            }
    450            else
    451            {
    452              col = predict + win;  
   \                     ??BlackGetLeftStep2Win_2: (+1)
   \   00000028   0x188E             ADDS     R6,R1,R2
   \   0000002A   0xE000             B.N      ??BlackGetLeftStep2Win_3
    453            }
    454            
    455            //判断条件里的">"很关键，没有写">="是考虑temp = 0的情况，这样可以防止产生负数（uint8中为正数），即无限循环。
    456            for( ; col > temp; col--) 
   \                     ??BlackGetLeftStep2Win_4: (+1)
   \   0000002C   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackGetLeftStep2Win_3: (+1)
   \   0000002E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0x42B5             CMP      R5,R6
   \   00000034   0xF080 0x80AF      BCS.W    ??BlackGetLeftStep2Win_5
    457            {
    458              abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col-1-BlackLeftEdgeNum]);
   \   00000038   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003C   0x20FA             MOVS     R0,#+250
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000042   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000046   0x1830             ADDS     R0,R6,R0
   \   00000048   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \   0000004C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000050   0x20FA             MOVS     R0,#+250
   \   00000052   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   00000056   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   0000005A   0x5C30             LDRB     R0,[R6, R0]
   \   0000005C   0x.... 0x....      BL       AbsRe
    459              if( 
    460                    (abs1 > LimitLeftWB) //两者的差够大
    461                  &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
    462                  &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
    463                 )
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x4281             CMP      R1,R0
   \   0000006A   0xD2DF             BCS.N    ??BlackGetLeftStep2Win_4
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable12_5
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x21FA             MOVS     R1,#+250
   \   00000078   0x.... 0x....      LDR.W    R2,??DataTable12_2
   \   0000007C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000080   0x5C71             LDRB     R1,[R6, R1]
   \   00000082   0x4288             CMP      R0,R1
   \   00000084   0xD2D2             BCS.N    ??BlackGetLeftStep2Win_4
   \   00000086   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x20FA             MOVS     R0,#+250
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000090   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000094   0x1830             ADDS     R0,R6,R0
   \   00000096   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   0000009E   0x7809             LDRB     R1,[R1, #+0]
   \   000000A0   0x4288             CMP      R0,R1
   \   000000A2   0xD2C3             BCS.N    ??BlackGetLeftStep2Win_4
    464              {
    465                    //近处的行，向左3个点仍为黑点
    466                    if(row > BlackMiddleLine)
   \   000000A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A6   0x2C1F             CMP      R4,#+31
   \   000000A8   0xDB30             BLT.N    ??BlackGetLeftStep2Win_6
    467                    {
    468                      temp1 = (
    469                                (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    470                              &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    471                              &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
    472                              );
   \   000000AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AE   0x20FA             MOVS     R0,#+250
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000000B4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000B8   0x1830             ADDS     R0,R6,R0
   \   000000BA   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000C2   0x7809             LDRB     R1,[R1, #+0]
   \   000000C4   0x4288             CMP      R0,R1
   \   000000C6   0xD21F             BCS.N    ??BlackGetLeftStep2Win_7
   \   000000C8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CC   0x20FA             MOVS     R0,#+250
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000000D2   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000D6   0x1830             ADDS     R0,R6,R0
   \   000000D8   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000E0   0x7809             LDRB     R1,[R1, #+0]
   \   000000E2   0x4288             CMP      R0,R1
   \   000000E4   0xD210             BCS.N    ??BlackGetLeftStep2Win_7
   \   000000E6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000E8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EA   0x20FA             MOVS     R0,#+250
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000000F0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000F4   0x1830             ADDS     R0,R6,R0
   \   000000F6   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000FE   0x7809             LDRB     R1,[R1, #+0]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD201             BCS.N    ??BlackGetLeftStep2Win_7
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0xE000             B.N      ??BlackGetLeftStep2Win_8
   \                     ??BlackGetLeftStep2Win_7: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_8: (+1)
   \   0000010A   0xE036             B.N      ??BlackGetLeftStep2Win_9
    473                    }
    474                    else
    475                    {
    476                      //中间的行 ，向左2个点为仍为黑点
    477                      if(row > BlackFarLine)
   \                     ??BlackGetLeftStep2Win_6: (+1)
   \   0000010C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010E   0x2C15             CMP      R4,#+21
   \   00000110   0xDB21             BLT.N    ??BlackGetLeftStep2Win_10
    478                      {
    479                        temp1 = (
    480                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    481                                &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    482                                );
   \   00000112   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000114   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000116   0x20FA             MOVS     R0,#+250
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000011C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000120   0x1830             ADDS     R0,R6,R0
   \   00000122   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000126   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   0000012A   0x7809             LDRB     R1,[R1, #+0]
   \   0000012C   0x4288             CMP      R0,R1
   \   0000012E   0xD210             BCS.N    ??BlackGetLeftStep2Win_11
   \   00000130   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000132   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000134   0x20FA             MOVS     R0,#+250
   \   00000136   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000013A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000013E   0x1830             ADDS     R0,R6,R0
   \   00000140   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000148   0x7809             LDRB     R1,[R1, #+0]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD201             BCS.N    ??BlackGetLeftStep2Win_11
   \   0000014E   0x2001             MOVS     R0,#+1
   \   00000150   0xE000             B.N      ??BlackGetLeftStep2Win_12
   \                     ??BlackGetLeftStep2Win_11: (+1)
   \   00000152   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_12: (+1)
   \   00000154   0xE011             B.N      ??BlackGetLeftStep2Win_9
    483                      }
    484                      //远处的行 ，向左1个点为仍为黑点
    485                      else
    486                      {
    487                        temp1 = (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB);
   \                     ??BlackGetLeftStep2Win_10: (+1)
   \   00000156   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000158   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015A   0x20FA             MOVS     R0,#+250
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000160   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000164   0x1830             ADDS     R0,R6,R0
   \   00000166   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000016A   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   0000016E   0x7809             LDRB     R1,[R1, #+0]
   \   00000170   0x4288             CMP      R0,R1
   \   00000172   0xD201             BCS.N    ??BlackGetLeftStep2Win_13
   \   00000174   0x2001             MOVS     R0,#+1
   \   00000176   0xE000             B.N      ??BlackGetLeftStep2Win_14
   \                     ??BlackGetLeftStep2Win_13: (+1)
   \   00000178   0x2000             MOVS     R0,#+0
    488                      }
    489                    }
    490                    if(temp1)
   \                     ??BlackGetLeftStep2Win_14: (+1)
   \                     ??BlackGetLeftStep2Win_9: (+1)
   \   0000017A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xF43F 0xAF55      BEQ.W    ??BlackGetLeftStep2Win_4
    491                    {
    492                      //两批条件均满足，直接记录该点为黑线，返回即可
    493                      BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
   \   00000182   0x1EF0             SUBS     R0,R6,#+3
   \   00000184   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000186   0x2103             MOVS     R1,#+3
   \   00000188   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000018C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000190   0x7008             STRB     R0,[R1, #+0]
    494                      return 1;
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xE008             B.N      ??BlackGetLeftStep2Win_15
    495                      //break;          
    496                    }
    497              }
    498              
    499              
    500              
    501            }// end of for循环
    502            
    503            //如果一直到窗口最左边还没有找到跳变沿，  
    504            BlackLeftLoc[row][0] = MaxValUint8;   //该行的黑线位置记为无效值
   \                     ??BlackGetLeftStep2Win_5: (+1)
   \   00000196   0x20FF             MOVS     R0,#+255
   \   00000198   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   0x2103             MOVS     R1,#+3
   \   0000019C   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000001A0   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000001A4   0x7008             STRB     R0,[R1, #+0]
    505            return 0;
   \   000001A6   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_15: (+1)
   \   000001A8   0xBD70             POP      {R4-R6,PC}       ;; return
    506          
    507            
    508          }
    509          
    510          
    511          //======================================================================
    512          //函数名：BlackGetLeftStep1Scan
    513          //功  能：行扫描函数
    514          //参  数：扫描起始行FirstLine, 扫描结束行LastLine, 十字再检测标志CrossFlag
    515          //返  回：0~CameraHight-1行数 255采集失败
    516          //影  响：
    517          //说  明：
    518          //             
    519          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    520          uint8 BlackGetLeftStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
    521          {
   \                     BlackGetLeftStep1Scan: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
    522              uint8 row, temp1, temp2;
    523              uint8 abs1;
    524              uint8 tempWB, tempW, tempB;
    525            //最近的BlackStep1Size行用差值法找黑线
    526              for(row = FirstLine; row > LastLine; row -= 2)
   \   00000008   0xE000             B.N      ??BlackGetLeftStep1Scan_0
   \                     ??BlackGetLeftStep1Scan_1: (+1)
   \   0000000A   0x1EAD             SUBS     R5,R5,#+2
   \                     ??BlackGetLeftStep1Scan_0: (+1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD270             BCS.N    ??BlackGetLeftStep1Scan_2
    527              {
    528                //判断是否连续两行检测到跳变。
    529                temp1 = BlackGetLeftStep1Edge(row, 1, CrossFlag);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       BlackGetLeftStep1Edge
   \   00000022   0x0007             MOVS     R7,R0
    530                temp2 = BlackGetLeftStep1Edge(row-1, 2, CrossFlag);
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x1E68             SUBS     R0,R5,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       BlackGetLeftStep1Edge
    531                if(temp1 && temp2)//这里可以这么写，不用嵌套if，因为&&的特点
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD0E8             BEQ.N    ??BlackGetLeftStep1Scan_1
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0E5             BEQ.N    ??BlackGetLeftStep1Scan_1
    532                {
    533                  abs1 = AbsRe(BlackLeftLoc[row-1][0], BlackLeftLoc[row][0]);
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \   00000046   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000004A   0x7801             LDRB     R1,[R0, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable12_3
   \   00000054   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   00000058   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000005C   0x.... 0x....      BL       AbsRe
    534                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
    535                  if(abs1 < BlackLeftStep1ScanMinus)
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2806             CMP      R0,#+6
   \   00000064   0xDAD1             BGE.N    ??BlackGetLeftStep1Scan_1
    536                  {
    537                    if(CrossFlag)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD044             BEQ.N    ??BlackGetLeftStep1Scan_3
    538                      {
    539                        //差值的处理，留有裕度，且有上下界。
    540                        tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable11
   \   00000076   0x7849             LDRB     R1,[R1, #+1]
   \   00000078   0x1808             ADDS     R0,R1,R0
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000080   0x3814             SUBS     R0,R0,#+20
    541                        if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x284B             CMP      R0,#+75
   \   00000086   0xDA01             BGE.N    ??BlackGetLeftStep1Scan_4
   \   00000088   0x204B             MOVS     R0,#+75
   \   0000008A   0xE003             B.N      ??BlackGetLeftStep1Scan_5
    542                        else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   \                     ??BlackGetLeftStep1Scan_4: (+1)
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x286A             CMP      R0,#+106
   \   00000090   0xDB00             BLT.N    ??BlackGetLeftStep1Scan_5
   \   00000092   0x2069             MOVS     R0,#+105
    543                        else ;
    544                        LimitLeftWB = tempWB;
   \                     ??BlackGetLeftStep1Scan_5: (+1)
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000098   0x7008             STRB     R0,[R1, #+0]
    545                        
    546                        //白点的处理，留有裕度，且有上下界。
    547                        tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   000000A4   0x7849             LDRB     R1,[R1, #+1]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000AE   0x381E             SUBS     R0,R0,#+30
    548                        if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2896             CMP      R0,#+150
   \   000000B4   0xDA01             BGE.N    ??BlackGetLeftStep1Scan_6
   \   000000B6   0x2096             MOVS     R0,#+150
   \   000000B8   0xE003             B.N      ??BlackGetLeftStep1Scan_7
    549                        else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   \                     ??BlackGetLeftStep1Scan_6: (+1)
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x28C9             CMP      R0,#+201
   \   000000BE   0xDB00             BLT.N    ??BlackGetLeftStep1Scan_7
   \   000000C0   0x20C8             MOVS     R0,#+200
    550                        else ;
    551                        LimitLeftW = tempW;
   \                     ??BlackGetLeftStep1Scan_7: (+1)
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    552                        
    553                        //黑点的处理，留有裕度，且有上下界。
    554                        tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   000000D2   0x7849             LDRB     R1,[R1, #+1]
   \   000000D4   0x1808             ADDS     R0,R1,R0
   \   000000D6   0x2102             MOVS     R1,#+2
   \   000000D8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000DC   0x301E             ADDS     R0,R0,#+30
    555                        if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2855             CMP      R0,#+85
   \   000000E2   0xDA01             BGE.N    ??BlackGetLeftStep1Scan_8
   \   000000E4   0x2055             MOVS     R0,#+85
   \   000000E6   0xE003             B.N      ??BlackGetLeftStep1Scan_9
    556                        else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   \                     ??BlackGetLeftStep1Scan_8: (+1)
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2865             CMP      R0,#+101
   \   000000EC   0xDB00             BLT.N    ??BlackGetLeftStep1Scan_9
   \   000000EE   0x2064             MOVS     R0,#+100
    557                        else ;
    558                        LimitLeftB = tempB;
   \                     ??BlackGetLeftStep1Scan_9: (+1)
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
    559                      }
    560                    break;
    561                  }
    562                }      
    563              }   
    564              
    565              //黑线检测失败
    566              if(row <= LastLine)
   \                     ??BlackGetLeftStep1Scan_3: (+1)
   \                     ??BlackGetLeftStep1Scan_2: (+1)
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x42AC             CMP      R4,R5
   \   000000FC   0xD301             BCC.N    ??BlackGetLeftStep1Scan_10
    567                return MaxValUint8;
   \   000000FE   0x20FF             MOVS     R0,#+255
   \   00000100   0xE001             B.N      ??BlackGetLeftStep1Scan_11
    568              else 
    569                return row;
   \                     ??BlackGetLeftStep1Scan_10: (+1)
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetLeftStep1Scan_11: (+1)
   \   00000106   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    570            
    571          }
    572          
    573          //======================================================================
    574          //函数名：BlackLeftCrossStep3
    575          //功  能：脑补线函数
    576          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
    577          //返  回：1成功 0失败
    578          //影  响：
    579          //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
    580          //             
    581          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    582          uint8 BlackLeftCrossStep3(uint8 FirstLine, uint8 LastLine)
    583          {
   \                     BlackLeftCrossStep3: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    584            float delta_x, delta_y, delta, index;
    585            uint8 row, temp1, temp2;
    586            //uint8 temp3, temp4, flag1, flag2;
    587            
    588            //超始行比结束行还高，报错！
    589            if(LastLine >= FirstLine)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x42A5             CMP      R5,R4
   \   0000000E   0xD308             BCC.N    ??BlackLeftCrossStep3_0
    590            {
    591              uart_sendN(UART0, (uint8 *)"\nError In BlackLeftCrossStep3!", 30);
   \   00000010   0x221E             MOVS     R2,#+30
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_1
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   0000001A   0x.... 0x....      BL       uart_sendN
    592              return 0;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE0A2             B.N      ??BlackLeftCrossStep3_1
    593            }
    594            
    595            temp1 = BlackLeftLoc[FirstLine][0];
   \                     ??BlackLeftCrossStep3_0: (+1)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000002A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002E   0x7807             LDRB     R7,[R0, #+0]
    596            temp2 = BlackLeftLoc[LastLine][0];
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000038   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000003C   0xF890 0x8000      LDRB     R8,[R0, #+0]
    597            
    598            /*
    599            flag = 1;
    600            flag = 2;
    601            //确认这两个点是直角处的点，也就是往左6个点仍为黑点
    602            if(temp1 <= (CameraRealWidth - 9))
    603            {
    604              temp3 = (
    605                      (ImgNew[FirstLine+1][temp1+6] < LimitLeftB)
    606                    &&(ImgNew[FirstLine+1][temp1+7] < LimitLeftB)
    607                    &&(ImgNew[FirstLine+1][temp1+8] < LimitLeftB)
    608                    );
    609              if(temp3)
    610              {
    611                flag1 = 0;  
    612              }
    613            }
    614            
    615            if(temp2 <= (CameraRealWidth - 9))
    616            {
    617              temp4 = (
    618                      (ImgNew[LastLine-1][temp2+6] < LimitLeftB)
    619                    &&(ImgNew[LastLine-1][temp2+7] < LimitLeftB)
    620                    &&(ImgNew[LastLine-1][temp2+8] < LimitLeftB)
    621                    );
    622              if(temp4)
    623              {
    624                flag2 = 0;  
    625              }
    626            }
    627            
    628            if((flag1 == 0) || (flag2 == 0))
    629            {
    630              return 0;  
    631            }
    632            
    633            */
    634            
    635            delta_y = FirstLine - LastLine;
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x1B60             SUBS     R0,R4,R5
   \   00000046   0x.... 0x....      BL       __aeabi_i2f
   \   0000004A   0x0006             MOVS     R6,R0
    636            
    637            
    638            //斜率向右
    639            if(temp1 < temp2)
   \   0000004C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0x4547             CMP      R7,R8
   \   00000054   0xD239             BCS.N    ??BlackLeftCrossStep3_2
    640            {
    641              delta_x = temp2 - temp1;
   \   00000056   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0xEBB8 0x0007      SUBS     R0,R8,R7
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
    642              delta = delta_x / delta_y; //这是1个浮点数
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x0007             MOVS     R7,R0
    643              
    644              index = 1.0;
   \   0000006C   0xF05F 0x587E      MOVS     R8,#+1065353216
    645              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   00000070   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackLeftCrossStep3_3: (+1)
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x1C68             ADDS     R0,R5,#+1
   \   00000078   0x4286             CMP      R6,R0
   \   0000007A   0xDB74             BLT.N    ??BlackLeftCrossStep3_4
    646              {
    647                //每次右移一点点
    648                BlackLeftLoc[row][0] = (uint8)((float)BlackLeftLoc[FirstLine][0] + delta * index);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000084   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x4641             MOV      R1,R8
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x2103             MOVS     R1,#+3
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000AA   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    649                index += 1.0;
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x3ff00000
   \   000000BC   0x.... 0x....      BL       __aeabi_dadd
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
   \   000000C4   0x4680             MOV      R8,R0
    650              }
   \   000000C6   0x1E76             SUBS     R6,R6,#+1
   \   000000C8   0xE7D3             B.N      ??BlackLeftCrossStep3_3
    651            }
    652            //斜率向左
    653            else if(temp1 > temp2)
   \                     ??BlackLeftCrossStep3_2: (+1)
   \   000000CA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D0   0x45B8             CMP      R8,R7
   \   000000D2   0xD239             BCS.N    ??BlackLeftCrossStep3_5
    654            {
    655              delta_x = temp1 - temp2;
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DA   0xEBB7 0x0008      SUBS     R0,R7,R8
   \   000000DE   0x.... 0x....      BL       __aeabi_i2f
    656              delta = delta_x / delta_y;
   \   000000E2   0x0031             MOVS     R1,R6
   \   000000E4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000E8   0x0007             MOVS     R7,R0
    657              
    658              index = 1.0;
   \   000000EA   0xF05F 0x587E      MOVS     R8,#+1065353216
    659              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000EE   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackLeftCrossStep3_6: (+1)
   \   000000F0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F4   0x1C68             ADDS     R0,R5,#+1
   \   000000F6   0x4286             CMP      R6,R0
   \   000000F8   0xDB35             BLT.N    ??BlackLeftCrossStep3_4
    660              {
    661                //每次右移一点点
    662                BlackLeftLoc[row][0] = (uint8)((float)BlackLeftLoc[FirstLine][0] - delta * index);
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000102   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x.... 0x....      BL       __aeabi_ui2f
   \   0000010C   0x4681             MOV      R9,R0
   \   0000010E   0x0038             MOVS     R0,R7
   \   00000110   0x4641             MOV      R1,R8
   \   00000112   0x.... 0x....      BL       __aeabi_fmul
   \   00000116   0x0001             MOVS     R1,R0
   \   00000118   0x4648             MOV      R0,R9
   \   0000011A   0x.... 0x....      BL       __aeabi_fsub
   \   0000011E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000122   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000124   0x2103             MOVS     R1,#+3
   \   00000126   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000012A   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   0000012E   0x7008             STRB     R0,[R1, #+0]
    663                index += 1.0;
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0x.... 0x....      BL       __aeabi_f2d
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0x....             LDR.N    R3,??DataTable10  ;; 0x3ff00000
   \   0000013A   0x.... 0x....      BL       __aeabi_dadd
   \   0000013E   0x.... 0x....      BL       __aeabi_d2f
   \   00000142   0x4680             MOV      R8,R0
    664              }
   \   00000144   0x1E76             SUBS     R6,R6,#+1
   \   00000146   0xE7D3             B.N      ??BlackLeftCrossStep3_6
    665            }
    666            //斜率直走，这个不太可能出现
    667            else
    668            {
    669              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackLeftCrossStep3_5: (+1)
   \   00000148   0x1E66             SUBS     R6,R4,#+1
   \   0000014A   0xE007             B.N      ??BlackLeftCrossStep3_7
    670              {
    671                //赋相同的值
    672                BlackLeftLoc[row][0] = temp1;
   \                     ??BlackLeftCrossStep3_8: (+1)
   \   0000014C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000014E   0x2003             MOVS     R0,#+3
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000154   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000158   0x7007             STRB     R7,[R0, #+0]
    673              }
   \   0000015A   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackLeftCrossStep3_7: (+1)
   \   0000015C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000015E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000160   0x1C68             ADDS     R0,R5,#+1
   \   00000162   0x4286             CMP      R6,R0
   \   00000164   0xDAF2             BGE.N    ??BlackLeftCrossStep3_8
    674            }
    675            
    676            return 1;
   \                     ??BlackLeftCrossStep3_4: (+1)
   \   00000166   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftCrossStep3_1: (+1)
   \   00000168   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    677              
    678          }
    679          
    680          //======================================================================
    681          //函数名：BlackLeftCrossConfirm
    682          //功  能：线头有效性的确认
    683          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
    684          //返  回：1成功 0失败
    685          //影  响：无
    686          //说  明：
    687          //      
    688          //             
    689          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    690          uint8 BlackLeftCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
    691          {
   \                     BlackLeftCrossConfirm: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
    692            uint8 row, index;
    693            uint8 x[BlackCrossConfirmNum];
    694            uint8 y[BlackCrossConfirmNum];
    695            
    696            float a0, a1, temp;
    697            
    698            //第一段黑线太短，无法检测正确性。直接返回1.
    699            if(Row1RealLastLine < 5) return 1;
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xDA01             BGE.N    ??BlackLeftCrossConfirm_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE071             B.N      ??BlackLeftCrossConfirm_1
    700            
    701            //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
    702            index = 0;
   \                     ??BlackLeftCrossConfirm_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
    703            for(row = Row1RealLastLine; ; row++)
   \   00000010   0xE000             B.N      ??BlackLeftCrossConfirm_2
   \                     ??BlackLeftCrossConfirm_3: (+1)
   \   00000012   0x1C40             ADDS     R0,R0,#+1
    704            {
    705              //有效行的记录
    706              if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??BlackLeftCrossConfirm_2: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2203             MOVS     R2,#+3
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable14
   \   0000001C   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD00D             BEQ.N    ??BlackLeftCrossConfirm_4
    707              {
    708                y[index] = BlackLeftLoc[row][0];
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable14
   \   0000002E   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0x54CA             STRB     R2,[R1, R3]
    709                x[index] = row;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xAA01             ADD      R2,SP,#+4
   \   0000003E   0x5488             STRB     R0,[R1, R2]
    710                index++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
    711              }
    712              //点数够多，则跳出。
    713              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackLeftCrossConfirm_4: (+1)
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x2903             CMP      R1,#+3
   \   00000046   0xD124             BNE.N    ??BlackLeftCrossConfirm_5
    714              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
    715              if(row == CameraHight - 1) return 1;
    716            }
    717            
    718            //最小二乘法
    719            //y = a0 + a1 * x
    720            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       LeastSquarea1
   \   00000052   0x0006             MOVS     R6,R0
    721            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       LeastSquarea0
   \   00000060   0x0005             MOVS     R5,R0
    722            
    723            //temp为第2段黑线起始行本应该在的位置。
    724            temp = a0 + a1 * Row2RealFirstLine;
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       __aeabi_ui2f
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x0029             MOVS     R1,R5
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x0005             MOVS     R5,R0
    725            if((temp < 0) || (temp > CameraRealWidth - 1)) 
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000080   0xD305             BCC.N    ??BlackLeftCrossConfirm_6
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable16  ;; 0x43790001
   \   00000088   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000008C   0xD806             BHI.N    ??BlackLeftCrossConfirm_7
    726            {
    727              return 0;
   \                     ??BlackLeftCrossConfirm_6: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE02F             B.N      ??BlackLeftCrossConfirm_1
    728            }
   \                     ??BlackLeftCrossConfirm_5: (+1)
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2831             CMP      R0,#+49
   \   00000096   0xD1BC             BNE.N    ??BlackLeftCrossConfirm_3
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE02A             B.N      ??BlackLeftCrossConfirm_1
    729            else
    730            { //这里本来应该加上把这个点限定在窗内，但是似乎没必要。
    731              if(
    732                (BlackLeftLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
    733              &&(BlackLeftLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)
    734                )
   \                     ??BlackLeftCrossConfirm_7: (+1)
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000A4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000AE   0x0001             MOVS     R1,R0
   \   000000B0   0x000E             MOVS     R6,R1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable16_1  ;; 0xc1200000
   \   000000B6   0x0029             MOVS     R1,R5
   \   000000B8   0x.... 0x....      BL       __aeabi_fadd
   \   000000BC   0x0031             MOVS     R1,R6
   \   000000BE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C2   0xD215             BCS.N    ??BlackLeftCrossConfirm_8
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable16_2  ;; 0x41200000
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x0001             MOVS     R1,R0
   \   000000D0   0x000D             MOVS     R5,R1
   \   000000D2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000DA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x.... 0x....      BL       __aeabi_ui2f
   \   000000E4   0x0029             MOVS     R1,R5
   \   000000E6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EA   0xD201             BCS.N    ??BlackLeftCrossConfirm_8
    735              {
    736                return 1;
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xE000             B.N      ??BlackLeftCrossConfirm_1
    737              }
    738              else
    739              {
    740                return 0;
   \                     ??BlackLeftCrossConfirm_8: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \                     ??BlackLeftCrossConfirm_1: (+1)
   \   000000F2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    741              }
    742              
    743            }  
    744          }
    745          
    746          
    747          
    748          //======================================================================
    749          //函数名：BlackLeftAgainForCross
    750          //功  能：十字检测程序
    751          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
    752          //        第1段黑线的实际结束行Row1RealLastLine
    753          //返  回：1成功 0失败
    754          //影  响：
    755          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
    756          //             
    757          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    758          uint8 BlackLeftAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine)
    759          {
   \                     BlackLeftAgainForCross: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    760              uint8 row, temp, temp1, temp2;
    761              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
    762              uint8 i;
    763              
    764              temp = BlackGetLeftStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       BlackGetLeftStep1Scan
   \   00000018   0x4680             MOV      R8,R0
    765              if(temp == MaxValUint8)  
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD10E             BNE.N    ??BlackLeftAgainForCross_0
    766              {
    767                //扫屁股工作。       
    768                for(i = Row2FirstLine; ; i--)
   \   00000024   0xE000             B.N      ??BlackLeftAgainForCross_1
   \                     ??BlackLeftAgainForCross_2: (+1)
   \   00000026   0x1E64             SUBS     R4,R4,#+1
    769                {
    770                  BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_1: (+1)
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000032   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    771                  if(i == 0) break;
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD1F3             BNE.N    ??BlackLeftAgainForCross_2
    772                }
    773                return 0;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE07A             B.N      ??BlackLeftAgainForCross_3
    774              }
    775              else 
    776              {
    777                if(!BlackLeftCrossConfirm(Row1RealLastLine, temp))
   \                     ??BlackLeftAgainForCross_0: (+1)
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackLeftCrossConfirm
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD10E             BNE.N    ??BlackLeftAgainForCross_4
    778                { //扫屁股工作。       //i >= (temp-1)
    779                  for(i = Row2FirstLine; ; i--)
   \   00000052   0xE000             B.N      ??BlackLeftAgainForCross_5
   \                     ??BlackLeftAgainForCross_6: (+1)
   \   00000054   0x1E64             SUBS     R4,R4,#+1
    780                  {
    781                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_5: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000060   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    782                    if(i == 0) break;
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C00             CMP      R4,#+0
   \   0000006A   0xD1F3             BNE.N    ??BlackLeftAgainForCross_6
    783                  }
    784                  return 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE063             B.N      ??BlackLeftAgainForCross_3
    785                }
    786                //十字再检测的线头的确在限定的范围内，可以继续。
    787                else
    788                {
    789                row = temp;
   \                     ??BlackLeftAgainForCross_4: (+1)
   \   00000070   0x4644             MOV      R4,R8
    790                }
    791                //row = temp;
    792              }
    793              
    794              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000072   0x0027             MOVS     R7,R4
    795              
    796              //temp为预测的黑点位置
    797              temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000007C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2103             MOVS     R1,#+3
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000008C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000090   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000009E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0xEBB0 0x0801      SUBS     R8,R0,R1
    798              //从最近的认证行到取最远的行
    799              for(row -= 2; ; row -= 2)
   \   000000A8   0x1EA4             SUBS     R4,R4,#+2
   \   000000AA   0xE000             B.N      ??BlackLeftAgainForCross_7
   \                     ??BlackLeftAgainForCross_8: (+1)
   \   000000AC   0x1EA4             SUBS     R4,R4,#+2
    800              {
    801                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp);
   \                     ??BlackLeftAgainForCross_7: (+1)
   \   000000AE   0x4642             MOV      R2,R8
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x210F             MOVS     R1,#+15
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   000000BC   0x4681             MOV      R9,R0
    802                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp);
   \   000000BE   0x4642             MOV      R2,R8
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0x210F             MOVS     R1,#+15
   \   000000C4   0x1E60             SUBS     R0,R4,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x.... 0x....      BL       BlackGetLeftStep2Win
    803                if(temp1 && temp2) 
   \   000000CC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D4   0xD01C             BEQ.N    ??BlackLeftAgainForCross_9
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD019             BEQ.N    ??BlackLeftAgainForCross_9
    804                {
    805                  temp = BlackLeftLoc[row - 1][0] + BlackLeftLoc[row - 1][0] - BlackLeftLoc[row][0];
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000E4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2103             MOVS     R1,#+3
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000F4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000F8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000FC   0x1808             ADDS     R0,R1,R0
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2103             MOVS     R1,#+3
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000106   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000010A   0x7809             LDRB     R1,[R1, #+0]
   \   0000010C   0xEBB0 0x0801      SUBS     R8,R0,R1
    806                }
    807                else
    808                {
    809                }       
    810                
    811                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackLeftAgainForCross_9: (+1)
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x42AC             CMP      R4,R5
   \   00000116   0xD004             BEQ.N    ??BlackLeftAgainForCross_10
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011C   0x1C68             ADDS     R0,R5,#+1
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD1C4             BNE.N    ??BlackLeftAgainForCross_8
    812              }
    813              
    814               //脑补两段线的接线。
    815              if(!BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine))
   \                     ??BlackLeftAgainForCross_10: (+1)
   \   00000122   0x0039             MOVS     R1,R7
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x0030             MOVS     R0,R6
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x.... 0x....      BL       BlackLeftCrossStep3
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD101             BNE.N    ??BlackLeftAgainForCross_11
    816              {
    817                return 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE000             B.N      ??BlackLeftAgainForCross_3
    818              }
    819              
    820              return 1;
   \                     ??BlackLeftAgainForCross_11: (+1)
   \   00000136   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftAgainForCross_3: (+1)
   \   00000138   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    821                  
    822          }
    823          
    824          //======================================================================
    825          //函数名：BlackLeftStep4BackLine
    826          //功  能：补线函数。
    827          //参  数：Step4StartLine开始行
    828          //返  回：1成功 0失败
    829          //影  响：
    830          //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
    831          //             
    832          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    833          uint8 BlackLeftStep4BackLine(uint8 Step4StartLine)
    834          {
   \                     BlackLeftStep4BackLine: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    835            uint8 row;
    836            uint8 i, index;
    837            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
    838            uint8 y[BlackBackLineNum];
    839            uint8 j;
    840            uint8 temp1;
    841            
    842            float temp;
    843            float a0, a1;
    844            
    845            if (Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0xF1B4 0x0008      SUBS     R0,R4,#+8
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD501             BPL.N    ??BlackLeftStep4BackLine_0
    846            {
    847              temp1 = 0;    
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xE001             B.N      ??BlackLeftStep4BackLine_1
    848            }
    849            else
    850            {
    851              temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
   \                     ??BlackLeftStep4BackLine_0: (+1)
   \   00000012   0xF1B4 0x0208      SUBS     R2,R4,#+8
    852            }
    853          
    854            index = 0;
   \                     ??BlackLeftStep4BackLine_1: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
    855            for(i = Step4StartLine; ; i--)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xE000             B.N      ??BlackLeftStep4BackLine_2
   \                     ??BlackLeftStep4BackLine_3: (+1)
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
    856            {
    857              if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftStep4BackLine_2: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2303             MOVS     R3,#+3
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable14
   \   00000026   0xFB03 0x5300      MLA      R3,R3,R0,R5
   \   0000002A   0x781B             LDRB     R3,[R3, #+0]
   \   0000002C   0x2BFF             CMP      R3,#+255
   \   0000002E   0xD00D             BEQ.N    ??BlackLeftStep4BackLine_4
    858              {
    859                y[index] = BlackLeftLoc[i][0];
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2303             MOVS     R3,#+3
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable14
   \   00000038   0xFB03 0x5300      MLA      R3,R3,R0,R5
   \   0000003C   0x781B             LDRB     R3,[R3, #+0]
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0xAD00             ADD      R5,SP,#+0
   \   00000042   0x554B             STRB     R3,[R1, R5]
    860                x[index] = i;
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xAB01             ADD      R3,SP,#+4
   \   00000048   0x54C8             STRB     R0,[R1, R3]
    861                index++;
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
    862              }
    863              if(index == BlackBackLineNum)
   \                     ??BlackLeftStep4BackLine_4: (+1)
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x2904             CMP      R1,#+4
   \   00000050   0xD10E             BNE.N    ??BlackLeftStep4BackLine_5
    864              {
    865                break;  
    866              }
    867              if(i == temp1)
    868              {
    869                return 0;
    870              }
    871            }
    872            
    873            //最小二乘法
    874            //y = a0 + a1 * x
    875            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       LeastSquarea1
   \   0000005C   0x0006             MOVS     R6,R0
    876            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   0000005E   0x2304             MOVS     R3,#+4
   \   00000060   0x0032             MOVS     R2,R6
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xA801             ADD      R0,SP,#+4
   \   00000066   0x.... 0x....      BL       LeastSquarea0
   \   0000006A   0x0005             MOVS     R5,R0
    877            
    878            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   0000006C   0x1C64             ADDS     R4,R4,#+1
   \   0000006E   0xE00F             B.N      ??BlackLeftStep4BackLine_6
   \                     ??BlackLeftStep4BackLine_5: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x4290             CMP      R0,R2
   \   00000076   0xD1D1             BNE.N    ??BlackLeftStep4BackLine_3
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE03D             B.N      ??BlackLeftStep4BackLine_7
    879            {
    880              //补线也有个度，向左向右都不能补出范围。
    881              temp = a0 + a1 * row;
    882              if(temp >= CameraRealWidth)
    883              {
    884                //BlackLeftLoc[row][0] = CameraRealWidth - 1;
    885                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
    886                for(j = row; ; j++)
    887                {
    888                  BlackLeftLoc[row][0] = MaxValUint8;
    889                  if(j == CameraHight - 1) break;
    890                }
    891                break;
    892              }
    893              else if(temp <= 0)
    894              {
    895                //BlackLeftLoc[row][0] = 0;
    896                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
    897                for(j = row; ; j++)
    898                {
    899                  BlackLeftLoc[row][0] = MaxValUint8;
    900                  if(j == CameraHight - 1) break;
    901                }
    902                break;
    903              }
    904              else
    905              {
    906                BlackLeftLoc[row][0] = (uint8)(temp); 
   \                     ??BlackLeftStep4BackLine_8: (+1)
   \   0000007C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000088   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    907              }
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackLeftStep4BackLine_6: (+1)
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C32             CMP      R4,#+50
   \   00000094   0xDA2F             BGE.N    ??BlackLeftStep4BackLine_9
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x.... 0x....      BL       __aeabi_fmul
   \   000000A4   0x0029             MOVS     R1,R5
   \   000000A6   0x.... 0x....      BL       __aeabi_fadd
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x437a0000
   \   000000AE   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000B2   0xD80E             BHI.N    ??BlackLeftStep4BackLine_10
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xE000             B.N      ??BlackLeftStep4BackLine_11
   \                     ??BlackLeftStep4BackLine_12: (+1)
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_11: (+1)
   \   000000BA   0x21FF             MOVS     R1,#+255
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2203             MOVS     R2,#+3
   \   000000C0   0x.... 0x....      LDR.W    R3,??DataTable14
   \   000000C4   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   000000C8   0x7011             STRB     R1,[R2, #+0]
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x2831             CMP      R0,#+49
   \   000000CE   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_12
   \   000000D0   0xE011             B.N      ??BlackLeftStep4BackLine_9
   \                     ??BlackLeftStep4BackLine_10: (+1)
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D8   0xD8D0             BHI.N    ??BlackLeftStep4BackLine_8
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0xE000             B.N      ??BlackLeftStep4BackLine_13
   \                     ??BlackLeftStep4BackLine_14: (+1)
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_13: (+1)
   \   000000E0   0x21FF             MOVS     R1,#+255
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x2203             MOVS     R2,#+3
   \   000000E6   0x.... 0x....      LDR.W    R3,??DataTable14
   \   000000EA   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   000000EE   0x7011             STRB     R1,[R2, #+0]
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0x2831             CMP      R0,#+49
   \   000000F4   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_14
    908            }
    909            
    910            return 1;
   \                     ??BlackLeftStep4BackLine_9: (+1)
   \   000000F6   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftStep4BackLine_7: (+1)
   \   000000F8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    911            
    912          }
    913          
    914          
    915          
    916          
    917          //======================================================================
    918          //函数名：BlackGetLeft
    919          //功  能：左黑线提取算法
    920          //参  数：无
    921          //返  回：1成功 0失败
    922          //影  响：
    923          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
    924          //      
    925          //             
    926          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    927          uint8 BlackGetLeft(void)
    928          {
   \                     BlackGetLeft: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    929              uint8 row, temp, temp1, temp2, temp3, i;
    930              uint8 GapCount, Row1RealLastLine, index;
    931              uint8 Step4Flag, Step4StartLine;  
    932              
    933              Step4Flag = 0;
   \   00000004   0x2500             MOVS     R5,#+0
    934              //默认十字检测标志置为未进入。
    935              BlackLeftCrossDone = 0;    
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    936              
    937              //有可能会返回黑线提取失败
    938              temp = BlackGetLeftStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0x2031             MOVS     R0,#+49
   \   00000014   0x.... 0x....      BL       BlackGetLeftStep1Scan
   \   00000018   0x0007             MOVS     R7,R0
    939              if(temp == MaxValUint8)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2FFF             CMP      R7,#+255
   \   0000001E   0xD101             BNE.N    ??BlackGetLeft_0
    940              {
    941                return 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE13C             B.N      ??BlackGetLeft_1
    942              }    
    943              else 
    944              {
    945                row = temp;
   \                     ??BlackGetLeft_0: (+1)
   \   00000024   0x46BA             MOV      R10,R7
    946                //起始线头的位置非常高
    947                if(row < CameraHight - BlackLeftBackLineStart)
   \   00000026   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002A   0xF1BA 0x0F2A      CMP      R10,#+42
   \   0000002E   0xDA01             BGE.N    ??BlackGetLeft_2
    948                {
    949                  Step4Flag = 1;
   \   00000030   0x2501             MOVS     R5,#+1
    950                  Step4StartLine = row;
   \   00000032   0x4656             MOV      R6,R10
    951                }
    952              }
    953          
    954              //上次已经处理完了第row-1行，下一次要处理第row-2行
    955              //BlackLeftSlope();
    956              
    957              //temp为预测的黑点位置
    958          
    959              //对预测值的大小限定
    960              if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) < 0)
   \                     ??BlackGetLeft_2: (+1)
   \   00000034   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable12_3
   \   0000003C   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000040   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000044   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0x....             LDR.N    R2,??DataTable12_3
   \   0000004C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000050   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000054   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000058   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0x....             LDR.N    R2,??DataTable12_3
   \   00000060   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x1A40             SUBS     R0,R0,R1
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD501             BPL.N    ??BlackGetLeft_3
    961              {
    962                temp = 0;
   \   0000006C   0x2700             MOVS     R7,#+0
   \   0000006E   0xE036             B.N      ??BlackGetLeft_4
    963              }
    964              else if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) >= CameraRealWidth)
   \                     ??BlackGetLeft_3: (+1)
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x....             LDR.N    R1,??DataTable12_3
   \   00000078   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000007C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000080   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x....             LDR.N    R2,??DataTable12_3
   \   00000088   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000008C   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000090   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x....             LDR.N    R2,??DataTable12_3
   \   0000009C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x1A40             SUBS     R0,R0,R1
   \   000000A4   0x28FA             CMP      R0,#+250
   \   000000A6   0xDB01             BLT.N    ??BlackGetLeft_5
    965              {
    966                temp = CameraRealWidth - 1;
   \   000000A8   0x27F9             MOVS     R7,#+249
   \   000000AA   0xE018             B.N      ??BlackGetLeft_4
    967              }
    968              else
    969              {
    970                temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];  
   \                     ??BlackGetLeft_5: (+1)
   \   000000AC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x....             LDR.N    R1,??DataTable12_3
   \   000000B4   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000000B8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0x2103             MOVS     R1,#+3
   \   000000C2   0x....             LDR.N    R2,??DataTable12_3
   \   000000C4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000C8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D2   0x2103             MOVS     R1,#+3
   \   000000D4   0x....             LDR.N    R2,??DataTable12_3
   \   000000D6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x1A47             SUBS     R7,R0,R1
    971              }
    972          
    973              index = 0;
   \                     ??BlackGetLeft_4: (+1)
   \   000000DE   0xF05F 0x0800      MOVS     R8,#+0
    974              
    975              GapCount = 0;  //连续多少行没有采集到黑线
   \   000000E2   0xF05F 0x0900      MOVS     R9,#+0
    976              //从最近的认证行到取最远的行
    977              for(row -= 2; ; row -= 2)
   \   000000E6   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   \   000000EA   0xE001             B.N      ??BlackGetLeft_6
   \                     ??BlackGetLeft_7: (+1)
   \   000000EC   0xF1BA 0x0A02      SUBS     R10,R10,#+2
    978              {
    979                //如果连续两行的黑点检测成功，则更新预测点的位置
    980                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp);
   \                     ??BlackGetLeft_6: (+1)
   \   000000F0   0x003A             MOVS     R2,R7
   \   000000F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F4   0x210F             MOVS     R1,#+15
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   000000FE   0x4683             MOV      R11,R0
    981                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp);
   \   00000100   0x003A             MOVS     R2,R7
   \   00000102   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000104   0x210F             MOVS     R1,#+15
   \   00000106   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x.... 0x....      BL       BlackGetLeftStep2Win
    982                temp3 = (
    983                        (!temp1)
    984                      &&(!temp2)
    985                      //&&(!Step4Flag)
    986                        );
   \   00000110   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000114   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000118   0xD104             BNE.N    ??BlackGetLeft_8
   \   0000011A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD101             BNE.N    ??BlackGetLeft_8
   \   00000120   0x2101             MOVS     R1,#+1
   \   00000122   0xE000             B.N      ??BlackGetLeft_9
   \                     ??BlackGetLeft_8: (+1)
   \   00000124   0x2100             MOVS     R1,#+0
    987                if(temp1 && temp2) 
   \                     ??BlackGetLeft_9: (+1)
   \   00000126   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000012A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000012E   0xD058             BEQ.N    ??BlackGetLeft_10
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD055             BEQ.N    ??BlackGetLeft_10
    988                {   //对预测值的大小限定
    989                    if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) < 0)
   \   00000136   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x....             LDR.N    R1,??DataTable12_3
   \   0000013E   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000142   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000146   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000014A   0x2103             MOVS     R1,#+3
   \   0000014C   0x....             LDR.N    R2,??DataTable12_3
   \   0000014E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000152   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000156   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   0000015A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015E   0x2103             MOVS     R1,#+3
   \   00000160   0x....             LDR.N    R2,??DataTable12_3
   \   00000162   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000166   0x7809             LDRB     R1,[R1, #+0]
   \   00000168   0x1A40             SUBS     R0,R0,R1
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD501             BPL.N    ??BlackGetLeft_11
    990                    {
    991                      temp = 0;
   \   0000016E   0x2700             MOVS     R7,#+0
   \   00000170   0xE07E             B.N      ??BlackGetLeft_12
    992                    }
    993                    else if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) >= CameraRealWidth)
   \                     ??BlackGetLeft_11: (+1)
   \   00000172   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0x....             LDR.N    R1,??DataTable12_3
   \   0000017A   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000017E   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000182   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000186   0x2103             MOVS     R1,#+3
   \   00000188   0x....             LDR.N    R2,??DataTable12_3
   \   0000018A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000018E   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000192   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000196   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000019A   0x2103             MOVS     R1,#+3
   \   0000019C   0x....             LDR.N    R2,??DataTable12_3
   \   0000019E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001A2   0x7809             LDRB     R1,[R1, #+0]
   \   000001A4   0x1A40             SUBS     R0,R0,R1
   \   000001A6   0x28FA             CMP      R0,#+250
   \   000001A8   0xDB01             BLT.N    ??BlackGetLeft_13
    994                    {
    995                      temp = CameraRealWidth - 1;
   \   000001AA   0x27F9             MOVS     R7,#+249
   \   000001AC   0xE060             B.N      ??BlackGetLeft_12
    996                    }
    997                    else
    998                    {
    999                      temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];  
   \                     ??BlackGetLeft_13: (+1)
   \   000001AE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001B2   0x2003             MOVS     R0,#+3
   \   000001B4   0x....             LDR.N    R1,??DataTable12_3
   \   000001B6   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000001BA   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000001BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C2   0x2103             MOVS     R1,#+3
   \   000001C4   0x....             LDR.N    R2,??DataTable12_3
   \   000001C6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001CA   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000001CE   0x1808             ADDS     R0,R1,R0
   \   000001D0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D4   0x2103             MOVS     R1,#+3
   \   000001D6   0x....             LDR.N    R2,??DataTable12_3
   \   000001D8   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001DC   0x7809             LDRB     R1,[R1, #+0]
   \   000001DE   0x1A47             SUBS     R7,R0,R1
   \   000001E0   0xE046             B.N      ??BlackGetLeft_12
   1000                    }
   1001                }
   1002                else if(temp3)
   \                     ??BlackGetLeft_10: (+1)
   \   000001E2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E4   0x2900             CMP      R1,#+0
   \   000001E6   0xD043             BEQ.N    ??BlackGetLeft_12
   1003                {       
   1004                  //Row1RealLastLine记录第1段黑线的最后一行。
   1005                  if(index == 0)
   \   000001E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001F0   0xD118             BNE.N    ??BlackGetLeft_14
   1006                  {
   1007                    //进来一次后，就再也不会进来了。
   1008                    index++;
   \   000001F2   0xF118 0x0801      ADDS     R8,R8,#+1
   1009                    for(i = row; i < (row + 5); i++)
   \   000001F6   0x4650             MOV      R0,R10
   \   000001F8   0xE000             B.N      ??BlackGetLeft_15
   \                     ??BlackGetLeft_16: (+1)
   \   000001FA   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeft_15: (+1)
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000202   0xF11A 0x0105      ADDS     R1,R10,#+5
   \   00000206   0x4288             CMP      R0,R1
   \   00000208   0xDA08             BGE.N    ??BlackGetLeft_17
   1010                    {
   1011                      if(BlackLeftLoc[i][0] != MaxValUint8)
   \   0000020A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020C   0x2103             MOVS     R1,#+3
   \   0000020E   0x....             LDR.N    R2,??DataTable12_3
   \   00000210   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000214   0x7809             LDRB     R1,[R1, #+0]
   \   00000216   0x29FF             CMP      R1,#+255
   \   00000218   0xD0EF             BEQ.N    ??BlackGetLeft_16
   1012                      {
   1013                        Row1RealLastLine = i;
   \   0000021A   0x0004             MOVS     R4,R0
   1014                        break;
   1015                      }
   1016                    }
   1017                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetLeft_17: (+1)
   \   0000021C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021E   0x2C31             CMP      R4,#+49
   \   00000220   0xDB00             BLT.N    ??BlackGetLeft_14
   1018                    {
   1019                      Row1RealLastLine = CameraHight - 1;
   \   00000222   0x2431             MOVS     R4,#+49
   1020                    }
   1021                    else
   1022                    {
   1023                    }
   1024                  }
   1025                  
   1026                  GapCount += 2;
   \                     ??BlackGetLeft_14: (+1)
   \   00000224   0xF119 0x0902      ADDS     R9,R9,#+2
   1027          
   1028                  if(GapCount > BlackCrossGapLine)
   \   00000228   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000022C   0xF1B9 0x0F0B      CMP      R9,#+11
   \   00000230   0xDB1A             BLT.N    ??BlackGetLeft_18
   1029                  {
   1030                    //再检测时的行太远了，就没必要检测了。
   1031                    if(row < BlackLeftCrossTooLowLine)
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000236   0x7800             LDRB     R0,[R0, #+0]
   \   00000238   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000023C   0x4582             CMP      R10,R0
   \   0000023E   0xD322             BCC.N    ??BlackGetLeft_19
   1032                    {
   1033                      break;
   1034                    }
   1035                    else
   1036                    {
   1037                    }
   1038                    
   1039                    if(!BlackLeftAgainForCross(row - 2, 1, Row1RealLastLine))
   \                     ??BlackGetLeft_20: (+1)
   \   00000240   0x0022             MOVS     R2,R4
   \   00000242   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000244   0x2101             MOVS     R1,#+1
   \   00000246   0xF1BA 0x0002      SUBS     R0,R10,#+2
   \   0000024A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024C   0x.... 0x....      BL       BlackLeftAgainForCross
   \   00000250   0x2800             CMP      R0,#+0
   \   00000252   0xD104             BNE.N    ??BlackGetLeft_21
   1040                    {
   1041                      BlackLeftCrossDone = 1;  //十字检测失败           
   \   00000254   0x2001             MOVS     R0,#+1
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000025A   0x7008             STRB     R0,[R1, #+0]
   \   0000025C   0xE003             B.N      ??BlackGetLeft_22
   1042                    }
   1043                    else
   1044                    {
   1045                      BlackLeftCrossDone = 2;  //十字检测成功
   \                     ??BlackGetLeft_21: (+1)
   \   0000025E   0x2002             MOVS     R0,#+2
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable19
   \   00000264   0x7008             STRB     R0,[R1, #+0]
   1046                    }
   1047                    break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetLeft_22: (+1)
   \   00000266   0xE00E             B.N      ??BlackGetLeft_19
   1048                    
   1049                  }
   1050                  else
   1051                  {
   1052                    BlackLeftCrossDone = 0;   //十字检测未进入
   \                     ??BlackGetLeft_18: (+1)
   \   00000268   0x2000             MOVS     R0,#+0
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable19
   \   0000026E   0x7008             STRB     R0,[R1, #+0]
   1053                  }
   1054                }
   1055                else
   1056                {        
   1057                }
   1058                
   1059                
   1060                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetLeft_12: (+1)
   \   00000270   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000274   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000278   0xD005             BEQ.N    ??BlackGetLeft_23
   \   0000027A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000027E   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000282   0xF47F 0xAF33      BNE.W    ??BlackGetLeft_7
   1061                
   1062              }
   1063              
   1064              
   1065              //这里有浮点运算，要严格控制调用。
   1066              if(Step4Flag)
   \                     ??BlackGetLeft_23: (+1)
   \                     ??BlackGetLeft_19: (+1)
   \   00000286   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000288   0x2D00             CMP      R5,#+0
   \   0000028A   0xD007             BEQ.N    ??BlackGetLeft_24
   1067              {
   1068                if(!BlackLeftStep4BackLine(Step4StartLine))
   \   0000028C   0x0030             MOVS     R0,R6
   \   0000028E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000290   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   00000294   0x2800             CMP      R0,#+0
   \   00000296   0xD101             BNE.N    ??BlackGetLeft_24
   1069                {
   1070                  return 0;  
   \   00000298   0x2000             MOVS     R0,#+0
   \   0000029A   0xE000             B.N      ??BlackGetLeft_1
   1071                }
   1072              }
   1073              
   1074              
   1075              return 1;
   \                     ??BlackGetLeft_24: (+1)
   \   0000029C   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeft_1: (+1)
   \   0000029E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1076          }
   1077          
   1078          
   1079          
   1080          //====================================右右右右右右右右右右右右右右右右右============================
   1081          
   1082          
   1083          
   1084          //======================================================================
   1085          //函数名：BlackRightRealClear
   1086          //功  能：右黑线提取中，对3个关键值的实际值清零
   1087          //参  数：无
   1088          //返  回：无
   1089          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
   1090          //说  明：
   1091          //      
   1092          //             
   1093          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1094          void BlackRightRealClear(void)
   1095          {
   1096              BlackRightRealWB[0] = 0;
   \                     BlackRightRealClear: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1097              BlackRightRealWB[1] = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   0000000E   0x7048             STRB     R0,[R1, #+1]
   1098              BlackRightRealW[0] = 0;
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   00000016   0x7008             STRB     R0,[R1, #+0]
   1099              BlackRightRealW[1] = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   0000001E   0x7048             STRB     R0,[R1, #+1]
   1100              BlackRightRealB[0] = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   1101              BlackRightRealB[1] = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable20
   \   0000002E   0x7048             STRB     R0,[R1, #+1]
   1102          }
   \   00000030   0x4770             BX       LR               ;; return
   1103          
   1104          
   1105          
   1106          //======================================================================
   1107          //函数名：BlackGetRightStep1Edge
   1108          //功  能：处理该右左线的可疑黑点
   1109          //参  数：待检测的行号row, 第几次使用use, 是否为十字再检测调用标志位CrossFlag
   1110          //返  回：1成功 0失败
   1111          //影  响：
   1112          //说  明：
   1113          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1114          uint8 BlackGetRightStep1Edge(uint8 row, uint8 use, uint8 CrossFlag)
   1115          {
   \                     BlackGetRightStep1Edge: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1116            uint8 index, col, temp1;
   1117            uint8 abs1;
   1118            uint8 RightBeginCol; //右线跳变检测起点
   1119            
   1120            //左黑线检测成功时
   1121            if(BlackLeftDone == 1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD11F             BNE.N    ??BlackGetRightStep1Edge_0
   1122            {
   1123                //右线跳变检测的起点至少要比该行左线的跳变点要靠右。
   1124              if(BlackLeftLoc[row][0] == MaxValUint8)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000001C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD102             BNE.N    ??BlackGetRightStep1Edge_1
   1125              {
   1126                RightBeginCol = CameraRealWidth/2;
   \   00000026   0xF05F 0x087D      MOVS     R8,#+125
   \   0000002A   0xE015             B.N      ??BlackGetRightStep1Edge_2
   1127              }
   1128              else
   1129              {
   1130                //至少要在左跳变向右4+BlackRightEdgeNum个点
   1131                RightBeginCol = MaxRe(CameraRealWidth/2, BlackLeftLoc[row][0] + 4 + BlackRightEdgeNum);
   \                     ??BlackGetRightStep1Edge_1: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000034   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x1D81             ADDS     R1,R0,#+6
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x207D             MOVS     R0,#+125
   \   00000040   0x.... 0x....      BL       MaxRe
   \   00000044   0x4680             MOV      R8,R0
   1132                //同时，也不能超过数组界限219，其实是不能超过CameraRealWidth - 5 - BlackRightEdgeNum，下面for循环里。
   1133                RightBeginCol = MinRe(RightBeginCol, CameraRealWidth - 5 - BlackRightEdgeNum);
   \   00000046   0x21F3             MOVS     R1,#+243
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x.... 0x....      BL       MinRe
   \   00000050   0x4680             MOV      R8,R0
   \   00000052   0xE001             B.N      ??BlackGetRightStep1Edge_2
   1134              }
   1135            }
   1136            //左黑线检测失败时，右黑线检测的起点要比中心线靠左BlackRightEdgeStartColOffset这么多列。
   1137            else
   1138            {
   1139              RightBeginCol = CameraRealWidth/2 - BlackRightEdgeStartColOffset;  
   \                     ??BlackGetRightStep1Edge_0: (+1)
   \   00000054   0xF05F 0x0855      MOVS     R8,#+85
   1140            }
   1141            
   1142            index = 0;         //可疑点的序号
   \                     ??BlackGetRightStep1Edge_2: (+1)
   \   00000058   0x2700             MOVS     R7,#+0
   1143            //从中间到最右边扫描，隔1个点求差
   1144            for(col = RightBeginCol; col <= CameraRealWidth - 5 - BlackRightEdgeNum; col++) 
   \   0000005A   0xE043             B.N      ??BlackGetRightStep1Edge_3
   1145            {
   1146                abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col+1+BlackRightEdgeNum]);
   1147                if( 
   1148                    (abs1 > LimitRightWB) //两者的差够大
   1149                  &&(ImgNew[row][col] > LimitRightW)                     //白点够白
   1150                  &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB) //黑点够黑
   1151                   )
   1152                {         
   1153                    //近处的行，向右3个点仍为黑点
   1154                    if(row > BlackMiddleLine)
   1155                    {
   1156                      temp1 = (
   1157                                (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1158                              &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1159                              &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
   1160                              );
   1161                    }
   1162                    else
   1163                    {
   1164                      if(row > BlackFarLine)
   1165                      {
   1166                        //中间的行，向右2个点仍为黑点。
   1167                        temp1 = (
   1168                                  (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1169                                &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1170                                );
   1171                      }
   1172                      //远处的行，向右1个点仍为黑点。
   1173                      else
   1174                      {
   1175                        temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
   1176                      }
   1177                    }
   1178                    
   1179                    if(temp1)
   1180                    {
   1181                                      
   1182                        //超过3个可疑黑点，则报错
   1183                        if(index == 3)       
   1184                        {
   1185                          if(CrossFlag)
   1186                          {
   1187                            //对3个关键值的实际值清零
   1188                            BlackRightRealClear();
   1189                          }
   1190                          //该行定位黑线失败，赋无效值
   1191                          BlackRightLoc[row][0] = MaxValUint8;
   1192                          return 0;
   1193                        }
   1194                        if(CrossFlag)
   1195                        {
   1196                          if(use == 1)
   1197                          {
   1198                            BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   1199                            BlackRightRealW[0] = ImgNew[row][col];
   1200                            BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
   1201                          }
   1202                          else if(use == 2)
   \                     ??BlackGetRightStep1Edge_4: (+1)
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D02             CMP      R5,#+2
   \   00000060   0xD133             BNE.N    ??BlackGetRightStep1Edge_5
   1203                          {
   1204                            BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x20FA             MOVS     R0,#+250
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000006E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000072   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000076   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x21FA             MOVS     R1,#+250
   \   0000007E   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000082   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000086   0xEB18 0x0101      ADDS     R1,R8,R1
   \   0000008A   0x78C9             LDRB     R1,[R1, #+3]
   \   0000008C   0x1A40             SUBS     R0,R0,R1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000092   0x7048             STRB     R0,[R1, #+1]
   1205                            BlackRightRealW[1] = ImgNew[row][col];
   \   00000094   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x20FA             MOVS     R0,#+250
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000A0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000A4   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   000000AC   0x7048             STRB     R0,[R1, #+1]
   1206                            BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   000000AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B4   0x20FA             MOVS     R0,#+250
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000BA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000BE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000C2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000C8   0x7048             STRB     R0,[R1, #+1]
   1207                          }
   1208                          else
   1209                          {
   1210                          }
   1211                        }
   1212                        //跳变检测成功，取黑点
   1213                        BlackRightLoc[row][index] = col + 1 + BlackRightEdgeNum;          
   \                     ??BlackGetRightStep1Edge_5: (+1)
   \   000000CA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000D4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000D8   0xF118 0x0103      ADDS     R1,R8,#+3
   \   000000DC   0x5439             STRB     R1,[R7, R0]
   1214                        index++;
   \   000000DE   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlackGetRightStep1Edge_6: (+1)
   \   000000E0   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??BlackGetRightStep1Edge_3: (+1)
   \   000000E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E8   0xF1B8 0x0FF4      CMP      R8,#+244
   \   000000EC   0xF280 0x8100      BGE.W    ??BlackGetRightStep1Edge_7
   \   000000F0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F6   0x20FA             MOVS     R0,#+250
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000FC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000100   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000104   0x78C1             LDRB     R1,[R0, #+3]
   \   00000106   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000010A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010C   0x20FA             MOVS     R0,#+250
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000112   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   00000116   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000011A   0x.... 0x....      BL       AbsRe
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000122   0x7809             LDRB     R1,[R1, #+0]
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x4281             CMP      R1,R0
   \   00000128   0xD2DA             BCS.N    ??BlackGetRightStep1Edge_6
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000134   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000136   0x21FA             MOVS     R1,#+250
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000013C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000140   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD2CB             BCS.N    ??BlackGetRightStep1Edge_6
   \   00000148   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0x20FA             MOVS     R0,#+250
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000154   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000158   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000015C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000162   0x7809             LDRB     R1,[R1, #+0]
   \   00000164   0x4288             CMP      R0,R1
   \   00000166   0xD2BB             BCS.N    ??BlackGetRightStep1Edge_6
   \   00000168   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016A   0x2C1F             CMP      R4,#+31
   \   0000016C   0xDB33             BLT.N    ??BlackGetRightStep1Edge_8
   \   0000016E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000172   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000174   0x20FA             MOVS     R0,#+250
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000017A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000017E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000182   0x7900             LDRB     R0,[R0, #+4]
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000188   0x7809             LDRB     R1,[R1, #+0]
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD221             BCS.N    ??BlackGetRightStep1Edge_9
   \   0000018E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000192   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000194   0x20FA             MOVS     R0,#+250
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000019A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000019E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001A2   0x7940             LDRB     R0,[R0, #+5]
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000001A8   0x7809             LDRB     R1,[R1, #+0]
   \   000001AA   0x4288             CMP      R0,R1
   \   000001AC   0xD211             BCS.N    ??BlackGetRightStep1Edge_9
   \   000001AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B4   0x20FA             MOVS     R0,#+250
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000001BA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001BE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001C2   0x7980             LDRB     R0,[R0, #+6]
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000001C8   0x7809             LDRB     R1,[R1, #+0]
   \   000001CA   0x4288             CMP      R0,R1
   \   000001CC   0xD201             BCS.N    ??BlackGetRightStep1Edge_9
   \   000001CE   0x2001             MOVS     R0,#+1
   \   000001D0   0xE000             B.N      ??BlackGetRightStep1Edge_10
   \                     ??BlackGetRightStep1Edge_9: (+1)
   \   000001D2   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_10: (+1)
   \   000001D4   0xE039             B.N      ??BlackGetRightStep1Edge_11
   \                     ??BlackGetRightStep1Edge_8: (+1)
   \   000001D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D8   0x2C15             CMP      R4,#+21
   \   000001DA   0xDB23             BLT.N    ??BlackGetRightStep1Edge_12
   \   000001DC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E2   0x20FA             MOVS     R0,#+250
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000001E8   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001EC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001F0   0x7900             LDRB     R0,[R0, #+4]
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000001F6   0x7809             LDRB     R1,[R1, #+0]
   \   000001F8   0x4288             CMP      R0,R1
   \   000001FA   0xD211             BCS.N    ??BlackGetRightStep1Edge_13
   \   000001FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000200   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000202   0x20FA             MOVS     R0,#+250
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000208   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000020C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000210   0x7940             LDRB     R0,[R0, #+5]
   \   00000212   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000216   0x7809             LDRB     R1,[R1, #+0]
   \   00000218   0x4288             CMP      R0,R1
   \   0000021A   0xD201             BCS.N    ??BlackGetRightStep1Edge_13
   \   0000021C   0x2001             MOVS     R0,#+1
   \   0000021E   0xE000             B.N      ??BlackGetRightStep1Edge_14
   \                     ??BlackGetRightStep1Edge_13: (+1)
   \   00000220   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_14: (+1)
   \   00000222   0xE012             B.N      ??BlackGetRightStep1Edge_11
   \                     ??BlackGetRightStep1Edge_12: (+1)
   \   00000224   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000228   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022A   0x20FA             MOVS     R0,#+250
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000230   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000234   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000238   0x7900             LDRB     R0,[R0, #+4]
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000023E   0x7809             LDRB     R1,[R1, #+0]
   \   00000240   0x4288             CMP      R0,R1
   \   00000242   0xD201             BCS.N    ??BlackGetRightStep1Edge_15
   \   00000244   0x2001             MOVS     R0,#+1
   \   00000246   0xE000             B.N      ??BlackGetRightStep1Edge_16
   \                     ??BlackGetRightStep1Edge_15: (+1)
   \   00000248   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_16: (+1)
   \                     ??BlackGetRightStep1Edge_11: (+1)
   \   0000024A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xF43F 0xAF47      BEQ.W    ??BlackGetRightStep1Edge_6
   \   00000252   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000254   0x2F03             CMP      R7,#+3
   \   00000256   0xD10E             BNE.N    ??BlackGetRightStep1Edge_17
   \   00000258   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000025A   0x2E00             CMP      R6,#+0
   \   0000025C   0xD001             BEQ.N    ??BlackGetRightStep1Edge_18
   \   0000025E   0x.... 0x....      BL       BlackRightRealClear
   \                     ??BlackGetRightStep1Edge_18: (+1)
   \   00000262   0x20FF             MOVS     R0,#+255
   \   00000264   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000266   0x2103             MOVS     R1,#+3
   \   00000268   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000026C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000270   0x7008             STRB     R0,[R1, #+0]
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xE04F             B.N      ??BlackGetRightStep1Edge_19
   \                     ??BlackGetRightStep1Edge_17: (+1)
   \   00000276   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000278   0x2E00             CMP      R6,#+0
   \   0000027A   0xF43F 0xAF26      BEQ.W    ??BlackGetRightStep1Edge_5
   \   0000027E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000280   0x2D01             CMP      R5,#+1
   \   00000282   0xF47F 0xAEEB      BNE.W    ??BlackGetRightStep1Edge_4
   \   00000286   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000028A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000028C   0x20FA             MOVS     R0,#+250
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000292   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000296   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000029A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000029E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A0   0x21FA             MOVS     R1,#+250
   \   000002A2   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000002A6   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000002AA   0xEB18 0x0101      ADDS     R1,R8,R1
   \   000002AE   0x78C9             LDRB     R1,[R1, #+3]
   \   000002B0   0x1A40             SUBS     R0,R0,R1
   \   000002B2   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   000002B6   0x7008             STRB     R0,[R1, #+0]
   \   000002B8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002BE   0x20FA             MOVS     R0,#+250
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000002C4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002C8   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   000002D0   0x7008             STRB     R0,[R1, #+0]
   \   000002D2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D8   0x20FA             MOVS     R0,#+250
   \   000002DA   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000002DE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002E2   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000002E6   0x78C0             LDRB     R0,[R0, #+3]
   \   000002E8   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000002EC   0x7008             STRB     R0,[R1, #+0]
   \   000002EE   0xE6EC             B.N      ??BlackGetRightStep1Edge_5
   1215                      
   1216                    }   
   1217                }  
   1218            }
   1219            
   1220            //1个可疑黑点也没有，则报错。
   1221            if(index == 0)
   \                     ??BlackGetRightStep1Edge_7: (+1)
   \   000002F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002F2   0x2F00             CMP      R7,#+0
   \   000002F4   0xD10E             BNE.N    ??BlackGetRightStep1Edge_20
   1222            {
   1223              if(CrossFlag)
   \   000002F6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002F8   0x2E00             CMP      R6,#+0
   \   000002FA   0xD001             BEQ.N    ??BlackGetRightStep1Edge_21
   1224              {
   1225                //对3个关键值的实际值清零
   1226                BlackRightRealClear();
   \   000002FC   0x.... 0x....      BL       BlackRightRealClear
   1227              }
   1228              //该行定位黑线失败，赋无效值
   1229              BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightStep1Edge_21: (+1)
   \   00000300   0x20FF             MOVS     R0,#+255
   \   00000302   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000304   0x2103             MOVS     R1,#+3
   \   00000306   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000030A   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000030E   0x7008             STRB     R0,[R1, #+0]
   1230              return 0;
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0xE000             B.N      ??BlackGetRightStep1Edge_19
   1231            }
   1232            
   1233            //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
   1234            return 1;
   \                     ??BlackGetRightStep1Edge_20: (+1)
   \   00000314   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRightStep1Edge_19: (+1)
   \   00000316   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1235          }
   1236          
   1237          
   1238          
   1239          //======================================================================
   1240          //函数名：BlackGetRightStep2Win
   1241          //功  能：窗口内跳变检测函数
   1242          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict
   1243          //返  回：1成功  0失败
   1244          //影  响：
   1245          //说  明：    
   1246          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1247          uint8 BlackGetRightStep2Win(uint8 row, uint8 win, uint8 predict)
   1248          {
   \                     BlackGetRightStep2Win: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1249            uint8 col, temp, temp1;
   1250            uint8 abs1;
   1251          
   1252            //在规划好的窗口内，从左往右查找跳变沿
   1253            //防止溢出
   1254            //对右边界的限制 
   1255            if((predict + win) >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   0000000A   0x28F3             CMP      R0,#+243
   \   0000000C   0xDB01             BLT.N    ??BlackGetRightStep2Win_0
   1256            {
   1257              temp = CameraRealWidth - 5 - BlackRightEdgeNum;
   \   0000000E   0x25F3             MOVS     R5,#+243
   \   00000010   0xE000             B.N      ??BlackGetRightStep2Win_1
   1258            }  
   1259            else
   1260            {
   1261              temp = predict + win;
   \                     ??BlackGetRightStep2Win_0: (+1)
   \   00000012   0x188D             ADDS     R5,R1,R2
   1262            }
   1263            //对左边界的限制
   1264            if(predict <= win)
   \                     ??BlackGetRightStep2Win_1: (+1)
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x4291             CMP      R1,R2
   \   0000001A   0xD301             BCC.N    ??BlackGetRightStep2Win_2
   1265            {
   1266              col = 0;
   \   0000001C   0x2600             MOVS     R6,#+0
   \   0000001E   0xE002             B.N      ??BlackGetRightStep2Win_3
   1267            }
   1268            else
   1269            {
   1270              col = predict - win;  
   \                     ??BlackGetRightStep2Win_2: (+1)
   \   00000020   0x1A56             SUBS     R6,R2,R1
   \   00000022   0xE000             B.N      ??BlackGetRightStep2Win_3
   1271            }
   1272             
   1273            for(; col < temp; col++) 
   \                     ??BlackGetRightStep2Win_4: (+1)
   \   00000024   0x1C76             ADDS     R6,R6,#+1
   \                     ??BlackGetRightStep2Win_3: (+1)
   \   00000026   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000028   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002A   0x42AE             CMP      R6,R5
   \   0000002C   0xF080 0x80A7      BCS.W    ??BlackGetRightStep2Win_5
   1274            {
   1275              abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col+1+BlackRightEdgeNum]);
   \   00000030   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000032   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000034   0x20FA             MOVS     R0,#+250
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000003A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000003E   0x1830             ADDS     R0,R6,R0
   \   00000040   0x78C1             LDRB     R1,[R0, #+3]
   \   00000042   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x20FA             MOVS     R0,#+250
   \   00000048   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000004C   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   00000050   0x5C30             LDRB     R0,[R6, R0]
   \   00000052   0x.... 0x....      BL       AbsRe
   1276              if( 
   1277                    (abs1 > LimitRightWB) //两者的差够大
   1278                  &&(ImgNew[row][col] > LimitRightW)                     //白点够白
   1279                  &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB)                   //黑点够黑
   1280                 )
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000005A   0x7809             LDRB     R1,[R1, #+0]
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x4281             CMP      R1,R0
   \   00000060   0xD2E0             BCS.N    ??BlackGetRightStep2Win_4
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable20_4
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x21FA             MOVS     R1,#+250
   \   0000006E   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   00000072   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000076   0x5C71             LDRB     R1,[R6, R1]
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD2D3             BCS.N    ??BlackGetRightStep2Win_4
   \   0000007C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000080   0x20FA             MOVS     R0,#+250
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000086   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000008A   0x1830             ADDS     R0,R6,R0
   \   0000008C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000092   0x7809             LDRB     R1,[R1, #+0]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD2C5             BCS.N    ??BlackGetRightStep2Win_4
   1281              {
   1282                  
   1283                    //近处的行，向右3个点仍为黑点
   1284                    if(row > BlackMiddleLine)
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x2C1F             CMP      R4,#+31
   \   0000009C   0xDB2D             BLT.N    ??BlackGetRightStep2Win_6
   1285                    {
   1286                      temp1 = (
   1287                                (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1288                              &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1289                              &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
   1290                              );
   \   0000009E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0x20FA             MOVS     R0,#+250
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000A8   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000AC   0x1830             ADDS     R0,R6,R0
   \   000000AE   0x7900             LDRB     R0,[R0, #+4]
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000B4   0x7809             LDRB     R1,[R1, #+0]
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xD21D             BCS.N    ??BlackGetRightStep2Win_7
   \   000000BA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x20FA             MOVS     R0,#+250
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000C4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000C8   0x1830             ADDS     R0,R6,R0
   \   000000CA   0x7940             LDRB     R0,[R0, #+5]
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000D0   0x7809             LDRB     R1,[R1, #+0]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD20F             BCS.N    ??BlackGetRightStep2Win_7
   \   000000D6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000D8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DA   0x20FA             MOVS     R0,#+250
   \   000000DC   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   000000E0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E4   0x1830             ADDS     R0,R6,R0
   \   000000E6   0x7980             LDRB     R0,[R0, #+6]
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000EC   0x7809             LDRB     R1,[R1, #+0]
   \   000000EE   0x4288             CMP      R0,R1
   \   000000F0   0xD201             BCS.N    ??BlackGetRightStep2Win_7
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xE000             B.N      ??BlackGetRightStep2Win_8
   \                     ??BlackGetRightStep2Win_7: (+1)
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_8: (+1)
   \   000000F8   0xE033             B.N      ??BlackGetRightStep2Win_9
   1291                    }
   1292                    else
   1293                    {
   1294                      //中间的行 ，向右2个点为仍为黑点
   1295                      if(row > BlackFarLine)
   \                     ??BlackGetRightStep2Win_6: (+1)
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0x2C15             CMP      R4,#+21
   \   000000FE   0xDB1F             BLT.N    ??BlackGetRightStep2Win_10
   1296                      {
   1297                        temp1 = (
   1298                                  (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1299                                &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1300                                );
   \   00000100   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000102   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000104   0x20FA             MOVS     R0,#+250
   \   00000106   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000010A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000010E   0x1830             ADDS     R0,R6,R0
   \   00000110   0x7900             LDRB     R0,[R0, #+4]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000116   0x7809             LDRB     R1,[R1, #+0]
   \   00000118   0x4288             CMP      R0,R1
   \   0000011A   0xD20F             BCS.N    ??BlackGetRightStep2Win_11
   \   0000011C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000011E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000120   0x20FA             MOVS     R0,#+250
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   00000126   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000012A   0x1830             ADDS     R0,R6,R0
   \   0000012C   0x7940             LDRB     R0,[R0, #+5]
   \   0000012E   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000132   0x7809             LDRB     R1,[R1, #+0]
   \   00000134   0x4288             CMP      R0,R1
   \   00000136   0xD201             BCS.N    ??BlackGetRightStep2Win_11
   \   00000138   0x2001             MOVS     R0,#+1
   \   0000013A   0xE000             B.N      ??BlackGetRightStep2Win_12
   \                     ??BlackGetRightStep2Win_11: (+1)
   \   0000013C   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_12: (+1)
   \   0000013E   0xE010             B.N      ??BlackGetRightStep2Win_9
   1301                      }
   1302                      //远处的行，向右1个点仍为黑点
   1303                      else
   1304                      {
   1305                        temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
   \                     ??BlackGetRightStep2Win_10: (+1)
   \   00000140   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000142   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000144   0x20FA             MOVS     R0,#+250
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000014A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000014E   0x1830             ADDS     R0,R6,R0
   \   00000150   0x7900             LDRB     R0,[R0, #+4]
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000156   0x7809             LDRB     R1,[R1, #+0]
   \   00000158   0x4288             CMP      R0,R1
   \   0000015A   0xD201             BCS.N    ??BlackGetRightStep2Win_13
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE000             B.N      ??BlackGetRightStep2Win_14
   \                     ??BlackGetRightStep2Win_13: (+1)
   \   00000160   0x2000             MOVS     R0,#+0
   1306                      }
   1307                    }
   1308                    
   1309                    if(temp1)
   \                     ??BlackGetRightStep2Win_14: (+1)
   \                     ??BlackGetRightStep2Win_9: (+1)
   \   00000162   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xF43F 0xAF5D      BEQ.W    ??BlackGetRightStep2Win_4
   1310                    {
   1311                    //直接记录该点为黑线，返回即可
   1312                    BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
   \   0000016A   0x1CF0             ADDS     R0,R6,#+3
   \   0000016C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016E   0x2103             MOVS     R1,#+3
   \   00000170   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000174   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000178   0x7008             STRB     R0,[R1, #+0]
   1313                    return 1;
   \   0000017A   0x2001             MOVS     R0,#+1
   \   0000017C   0xE008             B.N      ??BlackGetRightStep2Win_15
   1314                    //break;               
   1315                    }
   1316              }   
   1317            }// end of for循环
   1318            
   1319            //如果一直到窗口最左边还没有找到跳变沿，
   1320            
   1321            BlackRightLoc[row][0] = MaxValUint8;   //该行的黑线位置记为无效值
   \                     ??BlackGetRightStep2Win_5: (+1)
   \   0000017E   0x20FF             MOVS     R0,#+255
   \   00000180   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000182   0x2103             MOVS     R1,#+3
   \   00000184   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000188   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
   1322            return 0;
   \   0000018E   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_15: (+1)
   \   00000190   0xBD70             POP      {R4-R6,PC}       ;; return
   1323            
   1324          }
   1325          
   1326          
   1327          
   1328          //======================================================================
   1329          //函数名：BlackGetRightStep1Scan
   1330          //功  能：行扫描函数
   1331          //参  数：扫描起始行FirstLine, 扫描结束行LastLine, 十字再检测标志CrossFlag
   1332          //返  回：0~CameraHight - 1行数 255采集失败
   1333          //影  响：
   1334          //说  明：
   1335          //             
   1336          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1337          uint8 BlackGetRightStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
   1338          {
   \                     BlackGetRightStep1Scan: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
   1339              uint8 row, temp1, temp2;
   1340              uint8 abs1;
   1341              uint8 tempWB, tempW, tempB;
   1342              
   1343            //最近的BlackStep1Size行用差值法找黑线
   1344              for(row = FirstLine; row > LastLine; row -= 2)
   \   00000008   0xE000             B.N      ??BlackGetRightStep1Scan_0
   \                     ??BlackGetRightStep1Scan_1: (+1)
   \   0000000A   0x1EAD             SUBS     R5,R5,#+2
   \                     ??BlackGetRightStep1Scan_0: (+1)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD270             BCS.N    ??BlackGetRightStep1Scan_2
   1345              {
   1346                //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个
   1347                temp1 = BlackGetRightStep1Edge(row, 1, CrossFlag);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       BlackGetRightStep1Edge
   \   00000022   0x0007             MOVS     R7,R0
   1348                temp2 = BlackGetRightStep1Edge(row-1, 2, CrossFlag);
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x1E68             SUBS     R0,R5,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       BlackGetRightStep1Edge
   1349                if(temp1 && temp2)//这里可以这么写，不用嵌套if，因为&&的特点
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD0E8             BEQ.N    ??BlackGetRightStep1Scan_1
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0E5             BEQ.N    ??BlackGetRightStep1Scan_1
   1350                {
   1351                  abs1 = AbsRe(BlackRightLoc[row-1][0], BlackRightLoc[row][0]);
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000046   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000004A   0x7801             LDRB     R1,[R0, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000054   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   00000058   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000005C   0x.... 0x....      BL       AbsRe
   1352                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
   1353                  if(abs1 < BlackRightStep1ScanMinus)
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2806             CMP      R0,#+6
   \   00000064   0xDAD1             BGE.N    ??BlackGetRightStep1Scan_1
   1354                  {
   1355                    if(CrossFlag)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD044             BEQ.N    ??BlackGetRightStep1Scan_3
   1356                      {           
   1357                        //差值的处理，留有裕度，且有上下界。
   1358                        tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable19_2
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable19_2
   \   00000076   0x7849             LDRB     R1,[R1, #+1]
   \   00000078   0x1808             ADDS     R0,R1,R0
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000080   0x3814             SUBS     R0,R0,#+20
   1359                        if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x284B             CMP      R0,#+75
   \   00000086   0xDA01             BGE.N    ??BlackGetRightStep1Scan_4
   \   00000088   0x204B             MOVS     R0,#+75
   \   0000008A   0xE003             B.N      ??BlackGetRightStep1Scan_5
   1360                        else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   \                     ??BlackGetRightStep1Scan_4: (+1)
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x286A             CMP      R0,#+106
   \   00000090   0xDB00             BLT.N    ??BlackGetRightStep1Scan_5
   \   00000092   0x2069             MOVS     R0,#+105
   1361                        else ;
   1362                        LimitRightWB = tempWB;
   \                     ??BlackGetRightStep1Scan_5: (+1)
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   1363                        
   1364                        //白点的处理，留有裕度，且有上下界。
   1365                        tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable19_3
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable19_3
   \   000000A4   0x7849             LDRB     R1,[R1, #+1]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000AE   0x381E             SUBS     R0,R0,#+30
   1366                        if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2896             CMP      R0,#+150
   \   000000B4   0xDA01             BGE.N    ??BlackGetRightStep1Scan_6
   \   000000B6   0x2096             MOVS     R0,#+150
   \   000000B8   0xE003             B.N      ??BlackGetRightStep1Scan_7
   1367                        else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   \                     ??BlackGetRightStep1Scan_6: (+1)
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x28C9             CMP      R0,#+201
   \   000000BE   0xDB00             BLT.N    ??BlackGetRightStep1Scan_7
   \   000000C0   0x20C8             MOVS     R0,#+200
   1368                        else ;
   1369                        LimitRightW = tempW;
   \                     ??BlackGetRightStep1Scan_7: (+1)
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable20_4
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
   1370                        
   1371                        //黑点的处理，留有裕度，且有上下界。
   1372                        tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000000D2   0x7849             LDRB     R1,[R1, #+1]
   \   000000D4   0x1808             ADDS     R0,R1,R0
   \   000000D6   0x2102             MOVS     R1,#+2
   \   000000D8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000DC   0x301E             ADDS     R0,R0,#+30
   1373                        if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2855             CMP      R0,#+85
   \   000000E2   0xDA01             BGE.N    ??BlackGetRightStep1Scan_8
   \   000000E4   0x2055             MOVS     R0,#+85
   \   000000E6   0xE003             B.N      ??BlackGetRightStep1Scan_9
   1374                        else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   \                     ??BlackGetRightStep1Scan_8: (+1)
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2865             CMP      R0,#+101
   \   000000EC   0xDB00             BLT.N    ??BlackGetRightStep1Scan_9
   \   000000EE   0x2064             MOVS     R0,#+100
   1375                        else ;
   1376                        LimitRightB = tempB;           
   \                     ??BlackGetRightStep1Scan_9: (+1)
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   1377                      }
   1378                    break;
   1379                  }
   1380                }      
   1381              }   
   1382              
   1383              //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
   1384              if(row <= LastLine)
   \                     ??BlackGetRightStep1Scan_3: (+1)
   \                     ??BlackGetRightStep1Scan_2: (+1)
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x42AC             CMP      R4,R5
   \   000000FC   0xD301             BCC.N    ??BlackGetRightStep1Scan_10
   1385                return MaxValUint8;
   \   000000FE   0x20FF             MOVS     R0,#+255
   \   00000100   0xE001             B.N      ??BlackGetRightStep1Scan_11
   1386              else
   1387                return row;
   \                     ??BlackGetRightStep1Scan_10: (+1)
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetRightStep1Scan_11: (+1)
   \   00000106   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1388            
   1389          }
   1390          
   1391          
   1392          //======================================================================
   1393          //函数名：BlackRightCrossStep3
   1394          //功  能：脑补线函数
   1395          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
   1396          //返  回：1成功 0失败
   1397          //影  响：
   1398          //说  明：
   1399          //             
   1400          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1401          uint8 BlackRightCrossStep3(uint8 FirstLine, uint8 LastLine)
   1402          {
   \                     BlackRightCrossStep3: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1403            float delta_x, delta_y, delta, index;
   1404            uint8 row, temp1, temp2;
   1405            //uint8 temp3, temp4, flag1, flag2;
   1406            
   1407            //超始行比结束行还高，报错！
   1408            if(LastLine >= FirstLine)
   \   00000008   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x42A5             CMP      R5,R4
   \   0000000E   0xD308             BCC.N    ??BlackRightCrossStep3_0
   1409            {
   1410              uart_sendN(UART0, (uint8 *)"\nError In BlackRightCrossStep3!", 31);
   \   00000010   0x221F             MOVS     R2,#+31
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_3  ;; 0x4006a000
   \   0000001A   0x.... 0x....      BL       uart_sendN
   1411              return 0;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE0A3             B.N      ??BlackRightCrossStep3_1
   1412            }
   1413            
   1414            temp1 = BlackRightLoc[FirstLine][0];
   \                     ??BlackRightCrossStep3_0: (+1)
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000002A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002E   0x7807             LDRB     R7,[R0, #+0]
   1415            temp2 = BlackRightLoc[LastLine][0];
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000038   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000003C   0xF890 0x8000      LDRB     R8,[R0, #+0]
   1416            
   1417            /*
   1418            flag1 = 1;
   1419            flag2 = 1;
   1420            //确认这两个点是直角处的点，也就是往右6个点仍为黑点
   1421            if(temp1 <= (CameraRealWidth - 9))
   1422            {
   1423              temp3 = (
   1424                      (ImgNew[FirstLine+1][temp1+6] < LimitRightB)
   1425                    &&(ImgNew[FirstLine+1][temp1+7] < LimitRightB)
   1426                    &&(ImgNew[FirstLine+1][temp1+8] < LimitRightB)
   1427                    );
   1428              if(temp3)
   1429              {
   1430                flag1 = 0;  
   1431              }
   1432            }
   1433            
   1434            if(temp2 <= (CameraRealWidth - 9))
   1435            {
   1436              temp4 = (
   1437                      (ImgNew[LastLine-1][temp2+6] < LimitRightB)
   1438                    &&(ImgNew[LastLine-1][temp2+7] < LimitRightB)
   1439                    &&(ImgNew[LastLine-1][temp2+8] < LimitRightB)
   1440                    );
   1441              if(temp4)
   1442              {
   1443                flag2 = 0;  
   1444              }
   1445            }
   1446            
   1447            if((flag1 == 0) || (flag2 == 0))
   1448            {
   1449              return 0;  
   1450            }
   1451            
   1452            */
   1453            
   1454            delta_y = FirstLine - LastLine;
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000044   0x1B60             SUBS     R0,R4,R5
   \   00000046   0x.... 0x....      BL       __aeabi_i2f
   \   0000004A   0x0006             MOVS     R6,R0
   1455            
   1456            
   1457            //斜率向右
   1458            if(temp1 < temp2)
   \   0000004C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0x4547             CMP      R7,R8
   \   00000054   0xD239             BCS.N    ??BlackRightCrossStep3_2
   1459            {
   1460              delta_x = temp2 - temp1;
   \   00000056   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000005C   0xEBB8 0x0007      SUBS     R0,R8,R7
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   1461              delta = delta_x / delta_y; //这是1个浮点数
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x0007             MOVS     R7,R0
   1462              
   1463              index = 1.0;
   \   0000006C   0xF05F 0x587E      MOVS     R8,#+1065353216
   1464              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   00000070   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackRightCrossStep3_3: (+1)
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000076   0x1C68             ADDS     R0,R5,#+1
   \   00000078   0x4286             CMP      R6,R0
   \   0000007A   0xDB75             BLT.N    ??BlackRightCrossStep3_4
   1465              {
   1466                //每次右移一点点
   1467                BlackRightLoc[row][0] = (uint8)((float)BlackRightLoc[FirstLine][0] + delta * index);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000084   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0x0038             MOVS     R0,R7
   \   00000092   0x4641             MOV      R1,R8
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x2103             MOVS     R1,#+3
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable21
   \   000000AA   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   1468                index += 1.0;
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0x.... 0x....      LDR.W    R3,??DataTable21_4  ;; 0x3ff00000
   \   000000BC   0x.... 0x....      BL       __aeabi_dadd
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
   \   000000C4   0x4680             MOV      R8,R0
   1469              }
   \   000000C6   0x1E76             SUBS     R6,R6,#+1
   \   000000C8   0xE7D3             B.N      ??BlackRightCrossStep3_3
   1470            }
   1471            //斜率向左
   1472            else if(temp1 > temp2)
   \                     ??BlackRightCrossStep3_2: (+1)
   \   000000CA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000CE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D0   0x45B8             CMP      R8,R7
   \   000000D2   0xD23A             BCS.N    ??BlackRightCrossStep3_5
   1473            {
   1474              delta_x = temp1 - temp2;
   \   000000D4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000D6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DA   0xEBB7 0x0008      SUBS     R0,R7,R8
   \   000000DE   0x.... 0x....      BL       __aeabi_i2f
   1475              delta = delta_x / delta_y;
   \   000000E2   0x0031             MOVS     R1,R6
   \   000000E4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000E8   0x0007             MOVS     R7,R0
   1476              
   1477              index = 1.0;
   \   000000EA   0xF05F 0x587E      MOVS     R8,#+1065353216
   1478              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000EE   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackRightCrossStep3_6: (+1)
   \   000000F0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F4   0x1C68             ADDS     R0,R5,#+1
   \   000000F6   0x4286             CMP      R6,R0
   \   000000F8   0xDB36             BLT.N    ??BlackRightCrossStep3_4
   1479              {
   1480                //每次右移一点点
   1481                BlackRightLoc[row][0] = (uint8)((float)BlackRightLoc[FirstLine][0] - delta * index);
   \   000000FA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FC   0x2003             MOVS     R0,#+3
   \   000000FE   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000102   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x.... 0x....      BL       __aeabi_ui2f
   \   0000010C   0x4681             MOV      R9,R0
   \   0000010E   0x0038             MOVS     R0,R7
   \   00000110   0x4641             MOV      R1,R8
   \   00000112   0x.... 0x....      BL       __aeabi_fmul
   \   00000116   0x0001             MOVS     R1,R0
   \   00000118   0x4648             MOV      R0,R9
   \   0000011A   0x.... 0x....      BL       __aeabi_fsub
   \   0000011E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000122   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000124   0x2103             MOVS     R1,#+3
   \   00000126   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000012A   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   0000012E   0x7008             STRB     R0,[R1, #+0]
   1482                index += 1.0;
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0x.... 0x....      BL       __aeabi_f2d
   \   00000136   0x2200             MOVS     R2,#+0
   \   00000138   0x.... 0x....      LDR.W    R3,??DataTable21_4  ;; 0x3ff00000
   \   0000013C   0x.... 0x....      BL       __aeabi_dadd
   \   00000140   0x.... 0x....      BL       __aeabi_d2f
   \   00000144   0x4680             MOV      R8,R0
   1483              }
   \   00000146   0x1E76             SUBS     R6,R6,#+1
   \   00000148   0xE7D2             B.N      ??BlackRightCrossStep3_6
   1484            }
   1485            //斜率直走，这个不太可能出现
   1486            else
   1487            {
   1488              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackRightCrossStep3_5: (+1)
   \   0000014A   0x1E66             SUBS     R6,R4,#+1
   \   0000014C   0xE007             B.N      ??BlackRightCrossStep3_7
   1489              {
   1490                //赋相同的值
   1491                BlackRightLoc[row][0] = temp1;
   \                     ??BlackRightCrossStep3_8: (+1)
   \   0000014E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000150   0x2003             MOVS     R0,#+3
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000156   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000015A   0x7007             STRB     R7,[R0, #+0]
   1492              }
   \   0000015C   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackRightCrossStep3_7: (+1)
   \   0000015E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000160   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000162   0x1C68             ADDS     R0,R5,#+1
   \   00000164   0x4286             CMP      R6,R0
   \   00000166   0xDAF2             BGE.N    ??BlackRightCrossStep3_8
   1493            }
   1494            
   1495            return 1;
   \                     ??BlackRightCrossStep3_4: (+1)
   \   00000168   0x2001             MOVS     R0,#+1
   \                     ??BlackRightCrossStep3_1: (+1)
   \   0000016A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1496              
   1497          }
   1498          
   1499          //======================================================================
   1500          //函数名：BlackRightCrossConfirm
   1501          //功  能：线头有效性的确认。
   1502          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
   1503          //返  回：1成功 0失败
   1504          //影  响：无
   1505          //说  明：
   1506          //      
   1507          //             
   1508          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1509          uint8 BlackRightCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
   1510          {
   \                     BlackRightCrossConfirm: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1511            uint8 row, index;
   1512            uint8 x[BlackCrossConfirmNum];
   1513            uint8 y[BlackCrossConfirmNum];
   1514            
   1515            float a0, a1, temp;
   1516            
   1517            //第一段黑线太短，无法检测正确性。直接返回1.
   1518            if(Row1RealLastLine < 5) return 1;
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xDA01             BGE.N    ??BlackRightCrossConfirm_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE071             B.N      ??BlackRightCrossConfirm_1
   1519            
   1520            index = 0;
   \                     ??BlackRightCrossConfirm_0: (+1)
   \   0000000E   0x2100             MOVS     R1,#+0
   1521            for(row = Row1RealLastLine; ; row++)
   \   00000010   0xE000             B.N      ??BlackRightCrossConfirm_2
   \                     ??BlackRightCrossConfirm_3: (+1)
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   1522            {
   1523              //有效行的记录
   1524              if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??BlackRightCrossConfirm_2: (+1)
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2203             MOVS     R2,#+3
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable21
   \   0000001C   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD00D             BEQ.N    ??BlackRightCrossConfirm_4
   1525              {
   1526                y[index] = BlackRightLoc[row][0];
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable21
   \   0000002E   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0x54CA             STRB     R2,[R1, R3]
   1527                x[index] = row;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xAA01             ADD      R2,SP,#+4
   \   0000003E   0x5488             STRB     R0,[R1, R2]
   1528                index++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   1529              }
   1530              //点数够多，则跳出。
   1531              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackRightCrossConfirm_4: (+1)
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x2903             CMP      R1,#+3
   \   00000046   0xD124             BNE.N    ??BlackRightCrossConfirm_5
   1532              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
   1533              if(row == CameraHight - 1) return 1;
   1534            }
   1535            
   1536            //最小二乘法
   1537            //y = a0 + a1 * x
   1538            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       LeastSquarea1
   \   00000052   0x0006             MOVS     R6,R0
   1539            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       LeastSquarea0
   \   00000060   0x0005             MOVS     R5,R0
   1540            
   1541            //temp为第2段黑线起始行本应该在的位置。
   1542            temp = a0 + a1 * Row2RealFirstLine;
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       __aeabi_ui2f
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x0029             MOVS     R1,R5
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x0005             MOVS     R5,R0
   1543            //如果这个位置本来就超出了左右边界的范围，那说明不可能有第2段黑线存在了。
   1544            //也就不用检测第2段黑线了，直接返回0.
   1545            if((temp < 0) || (temp > CameraRealWidth - 1)) 
   \   00000078   0x0028             MOVS     R0,R5
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000080   0xD305             BCC.N    ??BlackRightCrossConfirm_6
   \   00000082   0x0028             MOVS     R0,R5
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable21_5  ;; 0x43790001
   \   00000088   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000008C   0xD806             BHI.N    ??BlackRightCrossConfirm_7
   1546            {
   1547              return 0;
   \                     ??BlackRightCrossConfirm_6: (+1)
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE02F             B.N      ??BlackRightCrossConfirm_1
   1548            }
   \                     ??BlackRightCrossConfirm_5: (+1)
   \   00000092   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000094   0x2831             CMP      R0,#+49
   \   00000096   0xD1BC             BNE.N    ??BlackRightCrossConfirm_3
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0xE02A             B.N      ??BlackRightCrossConfirm_1
   1549            else
   1550            { //这里本来应该加上把这个点限定在窗内，但是似乎没必要。
   1551              if(
   1552                (BlackRightLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
   1553              &&(BlackRightLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)
   1554                )
   \                     ??BlackRightCrossConfirm_7: (+1)
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x2003             MOVS     R0,#+3
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000A4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000AE   0x0001             MOVS     R1,R0
   \   000000B0   0x000E             MOVS     R6,R1
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0xc1200000
   \   000000B6   0x0029             MOVS     R1,R5
   \   000000B8   0x.... 0x....      BL       __aeabi_fadd
   \   000000BC   0x0031             MOVS     R1,R6
   \   000000BE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C2   0xD215             BCS.N    ??BlackRightCrossConfirm_8
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable21_7  ;; 0x41200000
   \   000000C8   0x0029             MOVS     R1,R5
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x0001             MOVS     R1,R0
   \   000000D0   0x000D             MOVS     R5,R1
   \   000000D2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000D4   0x2003             MOVS     R0,#+3
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000DA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000DE   0x7800             LDRB     R0,[R0, #+0]
   \   000000E0   0x.... 0x....      BL       __aeabi_ui2f
   \   000000E4   0x0029             MOVS     R1,R5
   \   000000E6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EA   0xD201             BCS.N    ??BlackRightCrossConfirm_8
   1555              {
   1556                return 1;
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xE000             B.N      ??BlackRightCrossConfirm_1
   1557              }
   1558              else
   1559              {
   1560                return 0;
   \                     ??BlackRightCrossConfirm_8: (+1)
   \   000000F0   0x2000             MOVS     R0,#+0
   \                     ??BlackRightCrossConfirm_1: (+1)
   \   000000F2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1561              }
   1562              
   1563            }  
   1564          }
   1565          
   1566          
   1567          //======================================================================
   1568          //函数名：BlackRightAgainForCross
   1569          //功  能：十字检测程序
   1570          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   1571          //        第1段黑线的实际结束行Row1RealLastLine
   1572          //返  回：1成功 0失败
   1573          //影  响：BlackRightLoc[][]。
   1574          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
   1575          //             
   1576          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1577          uint8 BlackRightAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine)
   1578          {
   \                     BlackRightAgainForCross: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1579              uint8 row, temp, temp1, temp2;
   1580              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
   1581              uint8 i;
   1582          
   1583              temp = BlackGetRightStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       BlackGetRightStep1Scan
   \   00000018   0x4680             MOV      R8,R0
   1584              if(temp == MaxValUint8)  
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD10E             BNE.N    ??BlackRightAgainForCross_0
   1585              {
   1586                //扫屁股工作。        //i >= Row2LastLine
   1587                for(i = Row2FirstLine; ; i--)
   \   00000024   0xE000             B.N      ??BlackRightAgainForCross_1
   \                     ??BlackRightAgainForCross_2: (+1)
   \   00000026   0x1E64             SUBS     R4,R4,#+1
   1588                {
   1589                  BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_1: (+1)
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2103             MOVS     R1,#+3
   \   0000002E   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000032   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000036   0x7008             STRB     R0,[R1, #+0]
   1590                  if(i == 0) break;
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD1F3             BNE.N    ??BlackRightAgainForCross_2
   1591                }
   1592                return 0;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE07A             B.N      ??BlackRightAgainForCross_3
   1593              }
   1594              else 
   1595              {
   1596                if(!BlackRightCrossConfirm(Row1RealLastLine, temp))
   \                     ??BlackRightAgainForCross_0: (+1)
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackRightCrossConfirm
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD10E             BNE.N    ??BlackRightAgainForCross_4
   1597                { //扫屁股工作。         //i >= (temp-1)
   1598                  for(i = Row2FirstLine; ; i--)
   \   00000052   0xE000             B.N      ??BlackRightAgainForCross_5
   \                     ??BlackRightAgainForCross_6: (+1)
   \   00000054   0x1E64             SUBS     R4,R4,#+1
   1599                  {
   1600                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_5: (+1)
   \   00000056   0x20FF             MOVS     R0,#+255
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2103             MOVS     R1,#+3
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000060   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   1601                    if(i == 0) break;
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C00             CMP      R4,#+0
   \   0000006A   0xD1F3             BNE.N    ??BlackRightAgainForCross_6
   1602                  }
   1603                  return 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE063             B.N      ??BlackRightAgainForCross_3
   1604                }
   1605                //十字再检测的线头的确在限定的范围内，可以继续。
   1606                else
   1607                {
   1608                row = temp;
   \                     ??BlackRightAgainForCross_4: (+1)
   \   00000070   0x4644             MOV      R4,R8
   1609                }
   1610                //row = temp;
   1611              }
   1612              
   1613              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000072   0x0027             MOVS     R7,R4
   1614              
   1615              //十字再检测第2阶段，顺着线头找线。
   1616              //temp为预测的黑点位置
   1617              temp = BlackRightLoc[row-1][0] + BlackRightLoc[row-1][0] - BlackRightLoc[row][0];
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000007C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2103             MOVS     R1,#+3
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000008C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000090   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable21
   \   0000009E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0xEBB0 0x0801      SUBS     R8,R0,R1
   1618              //从最近的认证行到取最远的行
   1619              for(row -= 2; ; row -= 2)
   \   000000A8   0x1EA4             SUBS     R4,R4,#+2
   \   000000AA   0xE000             B.N      ??BlackRightAgainForCross_7
   \                     ??BlackRightAgainForCross_8: (+1)
   \   000000AC   0x1EA4             SUBS     R4,R4,#+2
   1620              {
   1621                //如果连续两行的黑点检测成功，则更新预测点的位置
   1622                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp);
   \                     ??BlackRightAgainForCross_7: (+1)
   \   000000AE   0x4642             MOV      R2,R8
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x210F             MOVS     R1,#+15
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackGetRightStep2Win
   \   000000BC   0x4681             MOV      R9,R0
   1623                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp);
   \   000000BE   0x4642             MOV      R2,R8
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0x210F             MOVS     R1,#+15
   \   000000C4   0x1E60             SUBS     R0,R4,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x.... 0x....      BL       BlackGetRightStep2Win
   1624                if(temp1 && temp2) 
   \   000000CC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D4   0xD01C             BEQ.N    ??BlackRightAgainForCross_9
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD019             BEQ.N    ??BlackRightAgainForCross_9
   1625                {
   1626                  temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000E4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2103             MOVS     R1,#+3
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable21
   \   000000F4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000F8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000FC   0x1808             ADDS     R0,R1,R0
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2103             MOVS     R1,#+3
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000106   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000010A   0x7809             LDRB     R1,[R1, #+0]
   \   0000010C   0xEBB0 0x0801      SUBS     R8,R0,R1
   1627                }
   1628                //如果没能连续两行检测黑点成功，则不更新预测点位置，采用原位置。
   1629                else
   1630                {
   1631                }     
   1632                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackRightAgainForCross_9: (+1)
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x42AC             CMP      R4,R5
   \   00000116   0xD004             BEQ.N    ??BlackRightAgainForCross_10
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011C   0x1C68             ADDS     R0,R5,#+1
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD1C4             BNE.N    ??BlackRightAgainForCross_8
   1633              }
   1634              
   1635              //脑补两段线的接线。
   1636              if(!BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine))
   \                     ??BlackRightAgainForCross_10: (+1)
   \   00000122   0x0039             MOVS     R1,R7
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x0030             MOVS     R0,R6
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x.... 0x....      BL       BlackRightCrossStep3
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD101             BNE.N    ??BlackRightAgainForCross_11
   1637              {
   1638                return 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE000             B.N      ??BlackRightAgainForCross_3
   1639              }
   1640              
   1641              return 1;
   \                     ??BlackRightAgainForCross_11: (+1)
   \   00000136   0x2001             MOVS     R0,#+1
   \                     ??BlackRightAgainForCross_3: (+1)
   \   00000138   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1642                  
   1643          }
   1644          
   1645          
   1646          //======================================================================
   1647          //函数名：BlackRightStep4BackLine
   1648          //功  能：向后补线函数。
   1649          //参  数：Step4StartLine开始行
   1650          //返  回：1成功 0失败
   1651          //影  响：
   1652          //说  明：
   1653          //             
   1654          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1655          uint8 BlackRightStep4BackLine(uint8 Step4StartLine)
   1656          {
   \                     BlackRightStep4BackLine: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1657            uint8 row;
   1658            uint8 i, index;
   1659            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
   1660            uint8 y[BlackBackLineNum];
   1661            uint8 j;
   1662            uint8 temp1;
   1663            float temp;
   1664              
   1665            float a0, a1;
   1666            
   1667            if(Step4StartLine - BlackBackLineNum - BlackBackLineNum < 0)
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0xF1B4 0x0008      SUBS     R0,R4,#+8
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD501             BPL.N    ??BlackRightStep4BackLine_0
   1668            {
   1669              temp1 = 0;  
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0xE001             B.N      ??BlackRightStep4BackLine_1
   1670            }
   1671            else
   1672            {
   1673              temp1 = Step4StartLine - BlackBackLineNum - BlackBackLineNum;
   \                     ??BlackRightStep4BackLine_0: (+1)
   \   00000012   0xF1B4 0x0208      SUBS     R2,R4,#+8
   1674            }
   1675            
   1676            //取BlackBackLineNum个点作为最小二乘法的基准点。
   1677            index = 0;
   \                     ??BlackRightStep4BackLine_1: (+1)
   \   00000016   0x2100             MOVS     R1,#+0
   1678            for(i = Step4StartLine; ; i--)
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xE000             B.N      ??BlackRightStep4BackLine_2
   \                     ??BlackRightStep4BackLine_3: (+1)
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   1679            {
   1680              if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightStep4BackLine_2: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2303             MOVS     R3,#+3
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable21
   \   00000026   0xFB03 0x5300      MLA      R3,R3,R0,R5
   \   0000002A   0x781B             LDRB     R3,[R3, #+0]
   \   0000002C   0x2BFF             CMP      R3,#+255
   \   0000002E   0xD00D             BEQ.N    ??BlackRightStep4BackLine_4
   1681              {
   1682                y[index] = BlackRightLoc[i][0];
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2303             MOVS     R3,#+3
   \   00000034   0x.... 0x....      LDR.W    R5,??DataTable21
   \   00000038   0xFB03 0x5300      MLA      R3,R3,R0,R5
   \   0000003C   0x781B             LDRB     R3,[R3, #+0]
   \   0000003E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000040   0xAD00             ADD      R5,SP,#+0
   \   00000042   0x554B             STRB     R3,[R1, R5]
   1683                x[index] = i;
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0xAB01             ADD      R3,SP,#+4
   \   00000048   0x54C8             STRB     R0,[R1, R3]
   1684                index++;
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   1685              }
   1686              if(index == BlackBackLineNum)
   \                     ??BlackRightStep4BackLine_4: (+1)
   \   0000004C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000004E   0x2904             CMP      R1,#+4
   \   00000050   0xD10E             BNE.N    ??BlackRightStep4BackLine_5
   1687              {
   1688                break;  
   1689              }
   1690              if(i == temp1)
   1691              {
   1692                return 0;
   1693              }
   1694            }
   1695            
   1696            //最小二乘法
   1697            //y = a0 + a1 * x
   1698            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   00000052   0x2204             MOVS     R2,#+4
   \   00000054   0xA900             ADD      R1,SP,#+0
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       LeastSquarea1
   \   0000005C   0x0006             MOVS     R6,R0
   1699            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   0000005E   0x2304             MOVS     R3,#+4
   \   00000060   0x0032             MOVS     R2,R6
   \   00000062   0xA900             ADD      R1,SP,#+0
   \   00000064   0xA801             ADD      R0,SP,#+4
   \   00000066   0x.... 0x....      BL       LeastSquarea0
   \   0000006A   0x0005             MOVS     R5,R0
   1700            
   1701            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   0000006C   0x1C64             ADDS     R4,R4,#+1
   \   0000006E   0xE00F             B.N      ??BlackRightStep4BackLine_6
   \                     ??BlackRightStep4BackLine_5: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000074   0x4290             CMP      R0,R2
   \   00000076   0xD1D1             BNE.N    ??BlackRightStep4BackLine_3
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE03D             B.N      ??BlackRightStep4BackLine_7
   1702            {
   1703              //补线也有个度，向右和向左都不能补出范围。
   1704              temp = a0 + a1 * row;
   1705              if(temp > CameraRealWidth)
   1706              {
   1707                //BlackRightLoc[row][0] = CameraRealWidth - 1;
   1708                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   1709                for(j = row; ; j++)
   1710                {
   1711                  BlackRightLoc[row][0] = MaxValUint8;
   1712                  if(j == CameraHight - 1) break;
   1713                }
   1714                break;
   1715              }
   1716              else if(temp < 0)
   1717              {
   1718                //BlackRightLoc[row][0] = 0;
   1719                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   1720                for(j = row; ; j++)
   1721                {
   1722                  BlackRightLoc[row][0] = MaxValUint8;
   1723                  if(j == CameraHight - 1) break;
   1724                }
   1725                break;
   1726              }
   1727              else
   1728              {
   1729                BlackRightLoc[row][0] = (uint8)(temp); 
   \                     ??BlackRightStep4BackLine_8: (+1)
   \   0000007C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x2103             MOVS     R1,#+3
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable21
   \   00000088   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
   1730              }
   \   0000008E   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackRightStep4BackLine_6: (+1)
   \   00000090   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000092   0x2C32             CMP      R4,#+50
   \   00000094   0xDA2F             BGE.N    ??BlackRightStep4BackLine_9
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000009E   0x0031             MOVS     R1,R6
   \   000000A0   0x.... 0x....      BL       __aeabi_fmul
   \   000000A4   0x0029             MOVS     R1,R5
   \   000000A6   0x.... 0x....      BL       __aeabi_fadd
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable22  ;; 0x437a0001
   \   000000AE   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000B2   0xD80E             BHI.N    ??BlackRightStep4BackLine_10
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xE000             B.N      ??BlackRightStep4BackLine_11
   \                     ??BlackRightStep4BackLine_12: (+1)
   \   000000B8   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_11: (+1)
   \   000000BA   0x21FF             MOVS     R1,#+255
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x2203             MOVS     R2,#+3
   \   000000C0   0x.... 0x....      LDR.W    R3,??DataTable21
   \   000000C4   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   000000C8   0x7011             STRB     R1,[R2, #+0]
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x2831             CMP      R0,#+49
   \   000000CE   0xD1F3             BNE.N    ??BlackRightStep4BackLine_12
   \   000000D0   0xE011             B.N      ??BlackRightStep4BackLine_9
   \                     ??BlackRightStep4BackLine_10: (+1)
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D8   0xD2D0             BCS.N    ??BlackRightStep4BackLine_8
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0xE000             B.N      ??BlackRightStep4BackLine_13
   \                     ??BlackRightStep4BackLine_14: (+1)
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_13: (+1)
   \   000000E0   0x21FF             MOVS     R1,#+255
   \   000000E2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000E4   0x2203             MOVS     R2,#+3
   \   000000E6   0x.... 0x....      LDR.W    R3,??DataTable21
   \   000000EA   0xFB02 0x3204      MLA      R2,R2,R4,R3
   \   000000EE   0x7011             STRB     R1,[R2, #+0]
   \   000000F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F2   0x2831             CMP      R0,#+49
   \   000000F4   0xD1F3             BNE.N    ??BlackRightStep4BackLine_14
   1731            }
   1732            
   1733            return 1;
   \                     ??BlackRightStep4BackLine_9: (+1)
   \   000000F6   0x2001             MOVS     R0,#+1
   \                     ??BlackRightStep4BackLine_7: (+1)
   \   000000F8   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1734            
   1735          }
   1736          
   1737          
   1738          //======================================================================
   1739          //函数名：BlackGetRight
   1740          //功  能：右黑线提取算法
   1741          //参  数：无
   1742          //返  回：1成功 0失败
   1743          //影  响：
   1744          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
   1745          //      
   1746          //       
   1747          //       
   1748          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1749          uint8 BlackGetRight(void)
   1750          {
   \                     BlackGetRight: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   1751              uint8 row, temp, temp1, temp2, temp3, i;
   1752              uint8 GapCount, Row1RealLastLine, index;
   1753              uint8 Step4Flag, Step4StartLine;
   1754          
   1755              Step4Flag = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1756          
   1757              //默认十字检测标志置为未进入。
   1758              BlackRightCrossDone = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   1759          
   1760              temp = BlackGetRightStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x2118             MOVS     R1,#+24
   \   00000012   0x2031             MOVS     R0,#+49
   \   00000014   0x.... 0x....      BL       BlackGetRightStep1Scan
   \   00000018   0x0007             MOVS     R7,R0
   1761              if(temp == MaxValUint8)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2FFF             CMP      R7,#+255
   \   0000001E   0xD101             BNE.N    ??BlackGetRight_0
   1762              {
   1763                return 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE13C             B.N      ??BlackGetRight_1
   1764              }
   1765              else
   1766              {
   1767                row = temp;
   \                     ??BlackGetRight_0: (+1)
   \   00000024   0x46BA             MOV      R10,R7
   1768                //起始线头的位置非常高。
   1769                if(row < CameraHight - BlackRightBackLineStart)
   \   00000026   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002A   0xF1BA 0x0F2A      CMP      R10,#+42
   \   0000002E   0xDA01             BGE.N    ??BlackGetRight_2
   1770                {
   1771                  Step4Flag = 1;
   \   00000030   0x2501             MOVS     R5,#+1
   1772                  Step4StartLine = row;
   \   00000032   0x4656             MOV      R6,R10
   1773                }
   1774              }
   1775              //上次已经处理完了第row-1行，下一次要处理第row-2行
   1776              //BlackRightSlope();
   1777              
   1778              //temp为预测的黑点位置
   1779              //对预测值进行限定。
   1780              if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) < 0)
   \                     ??BlackGetRight_2: (+1)
   \   00000034   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable21
   \   0000003C   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000040   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000044   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0x....             LDR.N    R2,??DataTable21
   \   0000004C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000050   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000054   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000058   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0x....             LDR.N    R2,??DataTable21
   \   00000060   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x1A40             SUBS     R0,R0,R1
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD501             BPL.N    ??BlackGetRight_3
   1781              {
   1782                temp = 0;
   \   0000006C   0x2700             MOVS     R7,#+0
   \   0000006E   0xE036             B.N      ??BlackGetRight_4
   1783              }
   1784              else if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) >= CameraRealWidth) 
   \                     ??BlackGetRight_3: (+1)
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x....             LDR.N    R1,??DataTable21
   \   00000078   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000007C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000080   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x....             LDR.N    R2,??DataTable21
   \   00000088   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000008C   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000090   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x....             LDR.N    R2,??DataTable21
   \   0000009C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x1A40             SUBS     R0,R0,R1
   \   000000A4   0x28FA             CMP      R0,#+250
   \   000000A6   0xDB01             BLT.N    ??BlackGetRight_5
   1785              {         
   1786                temp = CameraRealWidth - 1; 
   \   000000A8   0x27F9             MOVS     R7,#+249
   \   000000AA   0xE018             B.N      ??BlackGetRight_4
   1787              }
   1788              else
   1789              {
   1790                temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \                     ??BlackGetRight_5: (+1)
   \   000000AC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x....             LDR.N    R1,??DataTable21
   \   000000B4   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000000B8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0x2103             MOVS     R1,#+3
   \   000000C2   0x....             LDR.N    R2,??DataTable21
   \   000000C4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000C8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D2   0x2103             MOVS     R1,#+3
   \   000000D4   0x....             LDR.N    R2,??DataTable21
   \   000000D6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x1A47             SUBS     R7,R0,R1
   1791              }
   1792              
   1793              index = 0;
   \                     ??BlackGetRight_4: (+1)
   \   000000DE   0xF05F 0x0800      MOVS     R8,#+0
   1794              
   1795              GapCount = 0;
   \   000000E2   0xF05F 0x0900      MOVS     R9,#+0
   1796              //从最近的认证行到取最远的行
   1797              for(row -= 2; ; row -= 2)
   \   000000E6   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   \   000000EA   0xE001             B.N      ??BlackGetRight_6
   \                     ??BlackGetRight_7: (+1)
   \   000000EC   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   1798              {
   1799                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp);
   \                     ??BlackGetRight_6: (+1)
   \   000000F0   0x003A             MOVS     R2,R7
   \   000000F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F4   0x210F             MOVS     R1,#+15
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       BlackGetRightStep2Win
   \   000000FE   0x4683             MOV      R11,R0
   1800                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp);
   \   00000100   0x003A             MOVS     R2,R7
   \   00000102   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000104   0x210F             MOVS     R1,#+15
   \   00000106   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x.... 0x....      BL       BlackGetRightStep2Win
   1801                temp3 = (
   1802                        (!temp1)
   1803                      &&(!temp2)
   1804                      //&&(!Step4Flag)
   1805                        );
   \   00000110   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000114   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000118   0xD104             BNE.N    ??BlackGetRight_8
   \   0000011A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD101             BNE.N    ??BlackGetRight_8
   \   00000120   0x2101             MOVS     R1,#+1
   \   00000122   0xE000             B.N      ??BlackGetRight_9
   \                     ??BlackGetRight_8: (+1)
   \   00000124   0x2100             MOVS     R1,#+0
   1806                if(temp1 && temp2) 
   \                     ??BlackGetRight_9: (+1)
   \   00000126   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000012A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000012E   0xD058             BEQ.N    ??BlackGetRight_10
   \   00000130   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD055             BEQ.N    ??BlackGetRight_10
   1807                {
   1808                  //对预测值进行限定。
   1809                  if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) < 0)
   \   00000136   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x....             LDR.N    R1,??DataTable21
   \   0000013E   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000142   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000146   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000014A   0x2103             MOVS     R1,#+3
   \   0000014C   0x....             LDR.N    R2,??DataTable21
   \   0000014E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000152   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000156   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   0000015A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015E   0x2103             MOVS     R1,#+3
   \   00000160   0x....             LDR.N    R2,??DataTable21
   \   00000162   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000166   0x7809             LDRB     R1,[R1, #+0]
   \   00000168   0x1A40             SUBS     R0,R0,R1
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD501             BPL.N    ??BlackGetRight_11
   1810                  {
   1811                    temp = 0;
   \   0000016E   0x2700             MOVS     R7,#+0
   \   00000170   0xE07E             B.N      ??BlackGetRight_12
   1812                  }
   1813                  else if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) >= CameraRealWidth) 
   \                     ??BlackGetRight_11: (+1)
   \   00000172   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000176   0x2003             MOVS     R0,#+3
   \   00000178   0x....             LDR.N    R1,??DataTable21
   \   0000017A   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000017E   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000182   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000186   0x2103             MOVS     R1,#+3
   \   00000188   0x....             LDR.N    R2,??DataTable21
   \   0000018A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000018E   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000192   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000196   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000019A   0x2103             MOVS     R1,#+3
   \   0000019C   0x....             LDR.N    R2,??DataTable21
   \   0000019E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001A2   0x7809             LDRB     R1,[R1, #+0]
   \   000001A4   0x1A40             SUBS     R0,R0,R1
   \   000001A6   0x28FA             CMP      R0,#+250
   \   000001A8   0xDB01             BLT.N    ??BlackGetRight_13
   1814                  {         
   1815                    temp = CameraRealWidth - 1; 
   \   000001AA   0x27F9             MOVS     R7,#+249
   \   000001AC   0xE060             B.N      ??BlackGetRight_12
   1816                  }
   1817                  else
   1818                  {
   1819                    temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \                     ??BlackGetRight_13: (+1)
   \   000001AE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001B2   0x2003             MOVS     R0,#+3
   \   000001B4   0x....             LDR.N    R1,??DataTable21
   \   000001B6   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000001BA   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000001BE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001C2   0x2103             MOVS     R1,#+3
   \   000001C4   0x....             LDR.N    R2,??DataTable21
   \   000001C6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001CA   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000001CE   0x1808             ADDS     R0,R1,R0
   \   000001D0   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D4   0x2103             MOVS     R1,#+3
   \   000001D6   0x....             LDR.N    R2,??DataTable21
   \   000001D8   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001DC   0x7809             LDRB     R1,[R1, #+0]
   \   000001DE   0x1A47             SUBS     R7,R0,R1
   \   000001E0   0xE046             B.N      ??BlackGetRight_12
   1820                  }
   1821                }
   1822                else if(temp3)
   \                     ??BlackGetRight_10: (+1)
   \   000001E2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E4   0x2900             CMP      R1,#+0
   \   000001E6   0xD043             BEQ.N    ??BlackGetRight_12
   1823                {       
   1824                  //Row1RealLastLine记录第1段黑线的最后一行。
   1825                  if(index == 0)
   \   000001E8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001EC   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001F0   0xD118             BNE.N    ??BlackGetRight_14
   1826                  {
   1827                    //进来一次后，就再也不会进来了。
   1828                    index++;
   \   000001F2   0xF118 0x0801      ADDS     R8,R8,#+1
   1829                    for(i = row; i < (row + 5); i++)
   \   000001F6   0x4650             MOV      R0,R10
   \   000001F8   0xE000             B.N      ??BlackGetRight_15
   \                     ??BlackGetRight_16: (+1)
   \   000001FA   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRight_15: (+1)
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000202   0xF11A 0x0105      ADDS     R1,R10,#+5
   \   00000206   0x4288             CMP      R0,R1
   \   00000208   0xDA08             BGE.N    ??BlackGetRight_17
   1830                    {
   1831                      if(BlackRightLoc[i][0] != MaxValUint8)
   \   0000020A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000020C   0x2103             MOVS     R1,#+3
   \   0000020E   0x....             LDR.N    R2,??DataTable21
   \   00000210   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000214   0x7809             LDRB     R1,[R1, #+0]
   \   00000216   0x29FF             CMP      R1,#+255
   \   00000218   0xD0EF             BEQ.N    ??BlackGetRight_16
   1832                      {
   1833                        Row1RealLastLine = i;
   \   0000021A   0x0004             MOVS     R4,R0
   1834                        break;
   1835                      }
   1836                    }
   1837                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetRight_17: (+1)
   \   0000021C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021E   0x2C31             CMP      R4,#+49
   \   00000220   0xDB00             BLT.N    ??BlackGetRight_14
   1838                    {
   1839                      Row1RealLastLine = CameraHight - 1;
   \   00000222   0x2431             MOVS     R4,#+49
   1840                    }
   1841                    else
   1842                    {
   1843                    }
   1844                  }
   1845                  
   1846                  GapCount += 2;
   \                     ??BlackGetRight_14: (+1)
   \   00000224   0xF119 0x0902      ADDS     R9,R9,#+2
   1847          
   1848                  if(GapCount > BlackCrossGapLine)
   \   00000228   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000022C   0xF1B9 0x0F0B      CMP      R9,#+11
   \   00000230   0xDB1A             BLT.N    ??BlackGetRight_18
   1849                  {
   1850                    //再检测时的行太远了，就没必要检测了。
   1851                    if(row < BlackRightCrossTooLowLine)
   \   00000232   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000236   0x7800             LDRB     R0,[R0, #+0]
   \   00000238   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000023C   0x4582             CMP      R10,R0
   \   0000023E   0xD322             BCC.N    ??BlackGetRight_19
   1852                    {
   1853                      break;
   1854                    }
   1855                    else
   1856                    {
   1857                    }
   1858                    
   1859                    if(!BlackRightAgainForCross(row - 2, 1, Row1RealLastLine))
   \                     ??BlackGetRight_20: (+1)
   \   00000240   0x0022             MOVS     R2,R4
   \   00000242   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000244   0x2101             MOVS     R1,#+1
   \   00000246   0xF1BA 0x0002      SUBS     R0,R10,#+2
   \   0000024A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024C   0x.... 0x....      BL       BlackRightAgainForCross
   \   00000250   0x2800             CMP      R0,#+0
   \   00000252   0xD104             BNE.N    ??BlackGetRight_21
   1860                    {
   1861                      BlackRightCrossDone = 1;  //十字检测失败            
   \   00000254   0x2001             MOVS     R0,#+1
   \   00000256   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000025A   0x7008             STRB     R0,[R1, #+0]
   \   0000025C   0xE003             B.N      ??BlackGetRight_22
   1862                    }
   1863                    else
   1864                    {
   1865                      BlackRightCrossDone = 2;  //十字检测成功
   \                     ??BlackGetRight_21: (+1)
   \   0000025E   0x2002             MOVS     R0,#+2
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable24
   \   00000264   0x7008             STRB     R0,[R1, #+0]
   1866                    }
   1867                    break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetRight_22: (+1)
   \   00000266   0xE00E             B.N      ??BlackGetRight_19
   1868                  }
   1869                  else
   1870                  {
   1871                     BlackRightCrossDone = 0;    //十字检测未进入
   \                     ??BlackGetRight_18: (+1)
   \   00000268   0x2000             MOVS     R0,#+0
   \   0000026A   0x.... 0x....      LDR.W    R1,??DataTable24
   \   0000026E   0x7008             STRB     R0,[R1, #+0]
   1872                  }      
   1873                }
   1874                else
   1875                {       
   1876                }     
   1877                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetRight_12: (+1)
   \   00000270   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000274   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000278   0xD005             BEQ.N    ??BlackGetRight_23
   \   0000027A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000027E   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000282   0xF47F 0xAF33      BNE.W    ??BlackGetRight_7
   1878                
   1879              }    
   1880              //这里有浮点运算，要严格控制调用。
   1881              if(Step4Flag)
   \                     ??BlackGetRight_23: (+1)
   \                     ??BlackGetRight_19: (+1)
   \   00000286   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000288   0x2D00             CMP      R5,#+0
   \   0000028A   0xD007             BEQ.N    ??BlackGetRight_24
   1882              {
   1883                if(!BlackRightStep4BackLine(Step4StartLine))
   \   0000028C   0x0030             MOVS     R0,R6
   \   0000028E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000290   0x.... 0x....      BL       BlackRightStep4BackLine
   \   00000294   0x2800             CMP      R0,#+0
   \   00000296   0xD101             BNE.N    ??BlackGetRight_24
   1884                {
   1885                  return 0;  
   \   00000298   0x2000             MOVS     R0,#+0
   \   0000029A   0xE000             B.N      ??BlackGetRight_1
   1886                }
   1887              }
   1888             
   1889              return 1;
   \                     ??BlackGetRight_24: (+1)
   \   0000029C   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRight_1: (+1)
   \   0000029E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1890          
   1891            
   1892            
   1893          }
   1894          
   1895          
   1896          //======================================================================
   1897          //函数名：BlackGet
   1898          //功  能：黑线提取程序
   1899          //参  数：无
   1900          //返  回：1成功 0失败
   1901          //影  响：见具体的左、右黑线算法
   1902          //说  明：
   1903          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1904          uint8 BlackGet(void)
   1905          {
   \                     BlackGet: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1906              uint8 tempLWB, tempLW, tempLB;
   1907              uint8 tempRWB, tempRW, tempRB;
   1908              //采集成功标志位
   1909              BlackLeftDone = 1;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000008   0x7008             STRB     R0,[R1, #+0]
   1910              BlackRightDone = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   00000010   0x7008             STRB     R0,[R1, #+0]
   1911              
   1912              //左黑线提取，成功则返回1，失败则返回0.
   1913              if(!BlackGetLeft())
   \   00000012   0x.... 0x....      BL       BlackGetLeft
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD12D             BNE.N    ??BlackGet_0
   1914              {
   1915                tempLWB = LimitLeftWB;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \   0000001E   0x7804             LDRB     R4,[R0, #+0]
   1916                tempLW = LimitLeftW;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \   00000024   0x7805             LDRB     R5,[R0, #+0]
   1917                tempLB = LimitLeftB;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable25_5
   \   0000002A   0x7806             LDRB     R6,[R0, #+0]
   1918                
   1919                LimitLeftWB = LimitOriLeftWB;                 
   \   0000002C   0x2050             MOVS     R0,#+80
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable25_3
   \   00000032   0x7008             STRB     R0,[R1, #+0]
   1920                LimitLeftW = LimitOriLeftW;
   \   00000034   0x2096             MOVS     R0,#+150
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable25_4
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
   1921                LimitLeftB = LimitOriLeftB;
   \   0000003C   0x2050             MOVS     R0,#+80
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable25_5
   \   00000042   0x7008             STRB     R0,[R1, #+0]
   1922                
   1923                if(!BlackGetLeft())
   \   00000044   0x.... 0x....      BL       BlackGetLeft
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD10D             BNE.N    ??BlackGet_1
   1924                {
   1925                  LimitLeftWB = tempLWB;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable25_3
   \   00000050   0x7004             STRB     R4,[R0, #+0]
   1926                  LimitLeftW = tempLW;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable25_4
   \   00000056   0x7005             STRB     R5,[R0, #+0]
   1927                  LimitLeftB = tempLB;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable25_5
   \   0000005C   0x7006             STRB     R6,[R0, #+0]
   1928                  
   1929                  //uart_sendN(UART0, (uint8 *)"\nFailed In BlackGetLeft!", 24);  
   1930                  BlackLeftDone = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable25_1
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   \   00000066   0xE006             B.N      ??BlackGet_0
   1931                }
   1932                //的确是光线的原因。
   1933                else
   1934                {
   1935                  BlackLeft3ResetCount++;    //由于光线变化太大引起的3个关键值重置的次数。
   \                     ??BlackGet_1: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable25_6
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable25_6
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   1936                }
   1937              }   
   1938              
   1939              //右黑线提取，成功则返回1，失败则返回0.
   1940              if(!BlackGetRight())
   \                     ??BlackGet_0: (+1)
   \   00000076   0x.... 0x....      BL       BlackGetRight
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD12A             BNE.N    ??BlackGet_2
   1941              {
   1942                tempRWB = LimitRightWB;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable25_7
   \   00000082   0x7804             LDRB     R4,[R0, #+0]
   1943                tempRW = LimitRightW;
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable25_8
   \   00000088   0x7805             LDRB     R5,[R0, #+0]
   1944                tempRB = LimitRightB;
   \   0000008A   0x....             LDR.N    R0,??DataTable21_1
   \   0000008C   0x7806             LDRB     R6,[R0, #+0]
   1945                
   1946                LimitRightWB = LimitOriRightWB;                 
   \   0000008E   0x2050             MOVS     R0,#+80
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable25_7
   \   00000094   0x7008             STRB     R0,[R1, #+0]
   1947                LimitRightW = LimitOriRightW;
   \   00000096   0x2096             MOVS     R0,#+150
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable25_8
   \   0000009C   0x7008             STRB     R0,[R1, #+0]
   1948                LimitRightB = LimitOriRightB;
   \   0000009E   0x2050             MOVS     R0,#+80
   \   000000A0   0x....             LDR.N    R1,??DataTable21_1
   \   000000A2   0x7008             STRB     R0,[R1, #+0]
   1949          
   1950                //不是光线的原因的情况下，把3个关键值变回来。
   1951                if(!BlackGetRight())
   \   000000A4   0x.... 0x....      BL       BlackGetRight
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD10C             BNE.N    ??BlackGet_3
   1952                {
   1953                  LimitRightWB = tempRWB;
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable25_7
   \   000000B0   0x7004             STRB     R4,[R0, #+0]
   1954                  LimitRightW = tempRW;
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable25_8
   \   000000B6   0x7005             STRB     R5,[R0, #+0]
   1955                  LimitRightB = tempRB;
   \   000000B8   0x....             LDR.N    R0,??DataTable21_1
   \   000000BA   0x7006             STRB     R6,[R0, #+0]
   1956                
   1957                  //uart_sendN(UART0, (uint8 *)"\nFailed In BlackGetRight!", 25);  
   1958                  BlackRightDone = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable25_2
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
   \   000000C4   0xE006             B.N      ??BlackGet_2
   1959                }
   1960                //的确是光线的原因。
   1961                else
   1962                {
   1963                  BlackRight3ResetCount++;    //由于光线变化太大引起的3个关键值重置的次数。
   \                     ??BlackGet_3: (+1)
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable25_9
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable25_9
   \   000000D2   0x7008             STRB     R0,[R1, #+0]
   1964                }
   1965              }
   1966              
   1967              //左、右黑线均提取失败，则黑线提取失败。
   1968              if((BlackLeftDone == 0) && (BlackRightDone == 0))
   \                     ??BlackGet_2: (+1)
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD106             BNE.N    ??BlackGet_4
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x2800             CMP      R0,#+0
   \   000000E6   0xD101             BNE.N    ??BlackGet_4
   1969              {
   1970                return 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0xE000             B.N      ??BlackGet_5
   1971              }    
   1972              //暂时还是不采取这种向后补线的方式，因为的确存在一边是十字补线，一边是向后补线的情况。
   1973              /*
   1974              //左、右黑线均提取成功，则看一下是否需要向后补线。
   1975              else if((BlackLeftDone == 1) && (BlackRightDone == 1))
   1976              {
   1977                //左、右黑线均要求向后补线时，才执行补线程序。否则有可能是弯道使线头上浮的情况。
   1978                if((BlackLeftStep4Flag == 1) && (BlackRightStep4Flag == 1))
   1979                {
   1980                  BlackLeftStep4BackLine(BlackLeftStep4StartLine);
   1981                  BlackRightStep4BackLine(BlackRightStep4StartLine);
   1982                }
   1983                
   1984              }
   1985              */
   1986              else
   1987              {
   1988                
   1989              }
   1990              
   1991              return 1;
   \                     ??BlackGet_4: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \                     ??BlackGet_5: (+1)
   \   000000EE   0xBD70             POP      {R4-R6,PC}       ;; return
   1992          }
   1993          
   1994          
   1995          
   1996          
   1997          
   1998          
   1999          
   2000          
   2001          
   2002          /*
   2003          //======================================================================
   2004          //函数名：CenterLineGet
   2005          //功  能：中心线提取函数
   2006          //参  数：无
   2007          //返  回：1成功 0失败
   2008          //影  响：CenterLineLoc[]
   2009          //说  明：1. 暂定为取左右有效黑线的中点，为基础版本。2014.11.11
   2010          //      
   2011          //             
   2012          //======================================================================
   2013          uint8 CenterLineGet(void)
   2014          {
   2015            uint8 row;
   2016            uint8 templ, tempr;
   2017              
   2018            //左、右黑线均提取失败。
   2019            if((BlackLeftDone == 0) && (BlackRightDone ==  0))
   2020            {
   2021              return 0;  
   2022            }
   2023            
   2024            for(row = CameraHight - 1; ; row--)
   2025            {
   2026              templ = BlackLeftLoc[row][0];
   2027              tempr = BlackRightLoc[row][0];
   2028              
   2029              //左、右黑线均提取成功。
   2030              if((BlackLeftDone == 1) && (BlackRightDone ==  1))
   2031              {   
   2032                //该行左右黑线都提取到了。
   2033                if((templ != MaxValUint8) && (tempr != MaxValUint8))  
   2034                {
   2035                  CenterLineLoc[row] = (templ + tempr) / 2;
   2036                }
   2037                //该行左黑线提取到了，右黑线提取失败。
   2038                else if((templ != MaxValUint8) && (tempr == MaxValUint8))
   2039                {
   2040                  CenterLineLoc[row] = templ + CenterLineHalfWidth[row];
   2041                }
   2042                //该行右黑线提取到了，左黑线提取失败。
   2043                else if((tempr != MaxValUint8) && (templ == MaxValUint8))  
   2044                {
   2045                  CenterLineLoc[row] = tempr - CenterLineHalfWidth[row];
   2046                }
   2047                //该行左、右黑线均提取失败，该行中心点赋无效值。
   2048                else 
   2049                {
   2050                  CenterLineLoc[row] = MaxValUint8;  
   2051                }
   2052              }
   2053              //左黑线提取成功，右黑线提取失败
   2054              else if((BlackLeftDone == 1) && (BlackRightDone ==  0))
   2055              {
   2056                if(templ != MaxValUint8)
   2057                {
   2058                  CenterLineLoc[row] = templ + CenterLineHalfWidth[row];
   2059                }
   2060                else 
   2061                {
   2062                  CenterLineLoc[row] = MaxValUint8;
   2063                }
   2064              }
   2065              //右黑线提取成功，左黑线提取失败
   2066              else if((BlackLeftDone == 0) && (BlackRightDone ==  1))
   2067              {
   2068                if(tempr != MaxValUint8)
   2069                {
   2070                  CenterLineLoc[row] = tempr - CenterLineHalfWidth[row];
   2071                }
   2072                else 
   2073                {
   2074                  CenterLineLoc[row] = MaxValUint8;
   2075                }
   2076              }
   2077              else
   2078              {
   2079                
   2080              }
   2081              
   2082              //如果处理到了最后一行，就跳出for循环。
   2083              if(row == 0) break;
   2084            }
   2085            return 1;
   2086            
   2087          }
   2088          */
   2089          
   2090          //左右边界限制

   \                                 In section .text, align 2, keep-with-next
   2091          uint8 BoundaryLimitRe(int16 x, uint8 left, uint8 right)
   2092          {
   2093            if(x < left)
   \                     BoundaryLimitRe: (+1)
   \   00000000   0x000B             MOVS     R3,R1
   \   00000002   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000004   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000006   0xB21B             SXTH     R3,R3            ;; SignExt  R3,R3,#+16,#+16
   \   00000008   0x4298             CMP      R0,R3
   \   0000000A   0xDA02             BGE.N    ??BoundaryLimitRe_0
   2094            {
   2095              return left;
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0xE009             B.N      ??BoundaryLimitRe_1
   2096            }
   2097            else if(x > right)
   \                     ??BoundaryLimitRe_0: (+1)
   \   00000012   0x0011             MOVS     R1,R2
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000018   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000001A   0x4281             CMP      R1,R0
   \   0000001C   0xDA02             BGE.N    ??BoundaryLimitRe_2
   2098            {
   2099              return right;
   \   0000001E   0x0010             MOVS     R0,R2
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0xE000             B.N      ??BoundaryLimitRe_1
   2100            }
   2101            else
   2102            {
   2103              return x;
   \                     ??BoundaryLimitRe_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BoundaryLimitRe_1: (+1)
   \   00000026   0x4770             BX       LR               ;; return
   2104            }
   2105          }
   2106          
   2107          
   2108          //中心线获取函数。

   \                                 In section .text, align 2, keep-with-next
   2109          uint8 CenterLineGet(void)
   2110          {
   \                     CenterLineGet: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   2111            uint8 row, i, j;
   2112            uint8 templ, tempr;
   2113            uint8 FailCount;
   2114            uint8 tempmax;
   2115            //uint8 flag001 = 0;
   2116            //左、右黑线均提取失败。
   2117            if((BlackLeftDone == 0) && (BlackRightDone ==  0))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD107             BNE.N    ??CenterLineGet_0
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??CenterLineGet_0
   2118            {
   2119              return 0;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF000 0xBC50      B.W      ??CenterLineGet_1
   2120            }
   2121              
   2122            //左、右黑线均提取成功。
   2123            if((BlackLeftDone == 1) && (BlackRightDone ==  1))
   \                     ??CenterLineGet_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xF040 0x8297      BNE.W    ??CenterLineGet_2
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xF040 0x8291      BNE.W    ??CenterLineGet_2
   2124            {
   2125              FailCount = 0;
   \   00000034   0x2400             MOVS     R4,#+0
   2126              for(row = CameraHight - 1; ; row--)
   \   00000036   0x2531             MOVS     R5,#+49
   \   00000038   0xE000             B.N      ??CenterLineGet_3
   \                     ??CenterLineGet_4: (+1)
   \   0000003A   0x1E6D             SUBS     R5,R5,#+1
   2127              {
   2128                templ = BlackLeftLoc[row][0];
   \                     ??CenterLineGet_3: (+1)
   \   0000003C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   00000044   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000048   0x7803             LDRB     R3,[R0, #+0]
   2129                tempr = BlackRightLoc[row][0];
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2003             MOVS     R0,#+3
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable25_11
   \   00000052   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   2130                //该行左右黑线都提取到了。
   2131                if((templ != MaxValUint8) && (tempr != MaxValUint8))  
   \   00000058   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000005A   0x2BFF             CMP      R3,#+255
   \   0000005C   0xD00D             BEQ.N    ??CenterLineGet_5
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x28FF             CMP      R0,#+255
   \   00000062   0xD00A             BEQ.N    ??CenterLineGet_5
   2132                {        
   2133                  CenterLineLoc[row] = (templ + tempr) / 2;    
   \   00000064   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000066   0xFA50 0xF083      UXTAB    R0,R0,R3
   \   0000006A   0x2102             MOVS     R1,#+2
   \   0000006C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000070   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000076   0x5468             STRB     R0,[R5, R1]
   \   00000078   0xE1D7             B.N      ??CenterLineGet_6
   2134                }
   2135                //该行左黑线提取失败，右黑线提取成功。
   2136                else if((templ == MaxValUint8) && (tempr != MaxValUint8))
   \                     ??CenterLineGet_5: (+1)
   \   0000007A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000007C   0x2BFF             CMP      R3,#+255
   \   0000007E   0xF040 0x80E6      BNE.W    ??CenterLineGet_7
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x28FF             CMP      R0,#+255
   \   00000086   0xF000 0x80E2      BEQ.W    ??CenterLineGet_7
   2137                {
   2138                  if(row == CameraHight - 1)
   \   0000008A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008C   0x2D31             CMP      R5,#+49
   \   0000008E   0xD12F             BNE.N    ??CenterLineGet_8
   2139                  {
   2140                      if(CenterLocStore != MaxValUint8)
   \   00000090   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   00000094   0x7800             LDRB     R0,[R0, #+0]
   \   00000096   0x28FF             CMP      R0,#+255
   \   00000098   0xD014             BEQ.N    ??CenterLineGet_9
   2141                      {
   2142                        CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLocStore, 0, CameraRealWidth - 1);
   \   0000009A   0x22F9             MOVS     R2,#+249
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A0   0x2003             MOVS     R0,#+3
   \   000000A2   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000000A6   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   000000B0   0x781B             LDRB     R3,[R3, #+0]
   \   000000B2   0x1AC0             SUBS     R0,R0,R3
   \   000000B4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000B6   0x.... 0x....      BL       BoundaryLimitRe
   \   000000BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000000C0   0x5468             STRB     R0,[R5, R1]
   \   000000C2   0xE1B2             B.N      ??CenterLineGet_6
   2143                      }
   2144                      else
   2145                      {
   2146                        CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLineHalfWidth[row], 0, CameraRealWidth - 1);
   \                     ??CenterLineGet_9: (+1)
   \   000000C4   0x22F9             MOVS     R2,#+249
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0x2003             MOVS     R0,#+3
   \   000000CC   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000000D0   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000000D4   0x7800             LDRB     R0,[R0, #+0]
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   000000DC   0x5CEB             LDRB     R3,[R5, R3]
   \   000000DE   0x1AC0             SUBS     R0,R0,R3
   \   000000E0   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000E2   0x.... 0x....      BL       BoundaryLimitRe
   \   000000E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000000EC   0x5468             STRB     R0,[R5, R1]
   \   000000EE   0xE19C             B.N      ??CenterLineGet_6
   2147                      }
   2148                  }
   2149                  //根据右线来估计中心线的走向，前提是上一行的右黑线有有效值。
   2150                  else if((row != (CameraHight-1))&&(BlackRightLoc[row+1][0] != MaxValUint8))
   \                     ??CenterLineGet_8: (+1)
   \   000000F0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F2   0x2D31             CMP      R5,#+49
   \   000000F4   0xF000 0x80A5      BEQ.W    ??CenterLineGet_10
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x2103             MOVS     R1,#+3
   \   000000FC   0x.... 0x....      LDR.W    R2,??DataTable25_11
   \   00000100   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   00000104   0x78C9             LDRB     R1,[R1, #+3]
   \   00000106   0x29FF             CMP      R1,#+255
   \   00000108   0xF000 0x809B      BEQ.W    ??CenterLineGet_10
   2151                  { //前一行的中心线有效。
   2152                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000112   0x1869             ADDS     R1,R5,R1
   \   00000114   0x7849             LDRB     R1,[R1, #+1]
   \   00000116   0x29FF             CMP      R1,#+255
   \   00000118   0xD019             BEQ.N    ??CenterLineGet_11
   2153                    {
   2154                      CenterLineLoc[row] =  BoundaryLimitRe(CenterLineLoc[row+1] + tempr - BlackRightLoc[row+1][0], 0, CameraRealWidth - 1);
   \   0000011A   0x22F9             MOVS     R2,#+249
   \   0000011C   0x2100             MOVS     R1,#+0
   \   0000011E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000120   0x.... 0x....      LDR.W    R3,??DataTable25_12
   \   00000124   0x18EB             ADDS     R3,R5,R3
   \   00000126   0x785B             LDRB     R3,[R3, #+1]
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0xFA50 0xF083      UXTAB    R0,R0,R3
   \   0000012E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000130   0x2303             MOVS     R3,#+3
   \   00000132   0x.... 0x....      LDR.W    R6,??DataTable25_11
   \   00000136   0xFB03 0x6305      MLA      R3,R3,R5,R6
   \   0000013A   0x78DB             LDRB     R3,[R3, #+3]
   \   0000013C   0x1AC0             SUBS     R0,R0,R3
   \   0000013E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000140   0x.... 0x....      BL       BoundaryLimitRe
   \   00000144   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000014A   0x5468             STRB     R0,[R5, R1]
   \   0000014C   0xE16D             B.N      ??CenterLineGet_6
   2155                    }
   2156                    //前一行的中心线无效。
   2157                    //如果是近处的行，那就有可能是270度左右黑线错位的情况。
   2158                    else if(row > CameraHight - 5)
   \                     ??CenterLineGet_11: (+1)
   \   0000014E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000150   0x2D2E             CMP      R5,#+46
   \   00000152   0xDB2F             BLT.N    ??CenterLineGet_12
   2159                    {
   2160                      if(CenterLocStore != MaxValUint8)
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   00000158   0x7800             LDRB     R0,[R0, #+0]
   \   0000015A   0x28FF             CMP      R0,#+255
   \   0000015C   0xD014             BEQ.N    ??CenterLineGet_13
   2161                      {
   2162                        CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLocStore, 0, CameraRealWidth - 1);
   \   0000015E   0x22F9             MOVS     R2,#+249
   \   00000160   0x2100             MOVS     R1,#+0
   \   00000162   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000164   0x2003             MOVS     R0,#+3
   \   00000166   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   0000016A   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   0000016E   0x7800             LDRB     R0,[R0, #+0]
   \   00000170   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   00000174   0x781B             LDRB     R3,[R3, #+0]
   \   00000176   0x1AC0             SUBS     R0,R0,R3
   \   00000178   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000017A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000017E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000184   0x5468             STRB     R0,[R5, R1]
   \   00000186   0xE150             B.N      ??CenterLineGet_6
   2163                      }
   2164                      else
   2165                      {
   2166                        CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLineHalfWidth[row], 0, CameraRealWidth - 1);
   \                     ??CenterLineGet_13: (+1)
   \   00000188   0x22F9             MOVS     R2,#+249
   \   0000018A   0x2100             MOVS     R1,#+0
   \   0000018C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000018E   0x2003             MOVS     R0,#+3
   \   00000190   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   00000194   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   00000198   0x7800             LDRB     R0,[R0, #+0]
   \   0000019A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000019C   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   000001A0   0x5CEB             LDRB     R3,[R5, R3]
   \   000001A2   0x1AC0             SUBS     R0,R0,R3
   \   000001A4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000001A6   0x.... 0x....      BL       BoundaryLimitRe
   \   000001AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000001B0   0x5468             STRB     R0,[R5, R1]
   \   000001B2   0xE13A             B.N      ??CenterLineGet_6
   2167                      }
   2168                      //flag001 = 1; //flag001是标志位，用以防止开头几行的中心线不连续的情况。
   2169                    }
   2170                    else
   2171                    { //行数够低才处理，否则不考虑。
   2172                      if(row <= CameraHight - 3)
   \                     ??CenterLineGet_12: (+1)
   \   000001B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001B6   0x2D30             CMP      R5,#+48
   \   000001B8   0xDA3D             BGE.N    ??CenterLineGet_14
   2173                      { //找符合要求的行。
   2174                        for(i = 2; i <= 4; i++)
   \   000001BA   0x2602             MOVS     R6,#+2
   \   000001BC   0xE000             B.N      ??CenterLineGet_15
   \                     ??CenterLineGet_16: (+1)
   \   000001BE   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGet_15: (+1)
   \   000001C0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001C2   0x2E05             CMP      R6,#+5
   \   000001C4   0xDA2D             BGE.N    ??CenterLineGet_17
   2175                        {
   2176                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackRightLoc[row+i][0] != MaxValUint8))
   \   000001C6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001C8   0xFA56 0xF185      UXTAB    R1,R6,R5
   \   000001CC   0x.... 0x....      LDR.W    R2,??DataTable25_12
   \   000001D0   0x5C89             LDRB     R1,[R1, R2]
   \   000001D2   0x29FF             CMP      R1,#+255
   \   000001D4   0xD0F3             BEQ.N    ??CenterLineGet_16
   \   000001D6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001D8   0xFA56 0xF185      UXTAB    R1,R6,R5
   \   000001DC   0x2203             MOVS     R2,#+3
   \   000001DE   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   000001E2   0xFB02 0x3101      MLA      R1,R2,R1,R3
   \   000001E6   0x7809             LDRB     R1,[R1, #+0]
   \   000001E8   0x29FF             CMP      R1,#+255
   \   000001EA   0xD0E8             BEQ.N    ??CenterLineGet_16
   2177                          {
   2178                             CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+i] + tempr - BlackRightLoc[row+i][0], 0, CameraRealWidth - 1); 
   \   000001EC   0x22F9             MOVS     R2,#+249
   \   000001EE   0x2100             MOVS     R1,#+0
   \   000001F0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000001F2   0xFA56 0xF385      UXTAB    R3,R6,R5
   \   000001F6   0x.... 0x....      LDR.W    R7,??DataTable25_12
   \   000001FA   0x5DDB             LDRB     R3,[R3, R7]
   \   000001FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FE   0x18C0             ADDS     R0,R0,R3
   \   00000200   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000202   0xFA56 0xF385      UXTAB    R3,R6,R5
   \   00000206   0x2703             MOVS     R7,#+3
   \   00000208   0x.... 0x....      LDR.W    R12,??DataTable25_11
   \   0000020C   0xFB07 0xC303      MLA      R3,R7,R3,R12
   \   00000210   0x781B             LDRB     R3,[R3, #+0]
   \   00000212   0x1AC0             SUBS     R0,R0,R3
   \   00000214   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000216   0x.... 0x....      BL       BoundaryLimitRe
   \   0000021A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000021C   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000220   0x5468             STRB     R0,[R5, R1]
   2179                             break;
   2180                          }
   2181                        }
   2182                        //没有找到符合要求的行。
   2183                        if(i == 5) CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_17: (+1)
   \   00000222   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000224   0x2E05             CMP      R6,#+5
   \   00000226   0xF040 0x8100      BNE.W    ??CenterLineGet_6
   \   0000022A   0x20FF             MOVS     R0,#+255
   \   0000022C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000232   0x5468             STRB     R0,[R5, R1]
   \   00000234   0xE0F9             B.N      ??CenterLineGet_6
   2184                      }        
   2185                      else
   2186                      {   //行数过高，不考虑这种情况。
   2187                          CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_14: (+1)
   \   00000236   0x20FF             MOVS     R0,#+255
   \   00000238   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000023E   0x5468             STRB     R0,[R5, R1]
   \   00000240   0xE0F3             B.N      ??CenterLineGet_6
   2188                      }
   2189                    }
   2190                  }
   2191                  else
   2192                  {
   2193                    CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_10: (+1)
   \   00000242   0x20FF             MOVS     R0,#+255
   \   00000244   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000246   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000024A   0x5468             STRB     R0,[R5, R1]
   \   0000024C   0xE0ED             B.N      ??CenterLineGet_6
   2194                  }
   2195                }
   2196                //该行右黑线提取失败，左黑线提取成功。
   2197                else if((templ != MaxValUint8) && (tempr == MaxValUint8))
   \                     ??CenterLineGet_7: (+1)
   \   0000024E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000250   0x2BFF             CMP      R3,#+255
   \   00000252   0xF000 0x80E5      BEQ.W    ??CenterLineGet_18
   \   00000256   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000258   0x28FF             CMP      R0,#+255
   \   0000025A   0xF040 0x80E1      BNE.W    ??CenterLineGet_18
   2198                {
   2199                  if(row == CameraHight - 1)
   \   0000025E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000260   0x2D31             CMP      R5,#+49
   \   00000262   0xD12F             BNE.N    ??CenterLineGet_19
   2200                  {
   2201                      if(CenterLocStore != MaxValUint8)
   \   00000264   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   00000268   0x7800             LDRB     R0,[R0, #+0]
   \   0000026A   0x28FF             CMP      R0,#+255
   \   0000026C   0xD014             BEQ.N    ??CenterLineGet_20
   2202                      {
   2203                        CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLocStore, 0, CameraRealWidth - 1); 
   \   0000026E   0x22F9             MOVS     R2,#+249
   \   00000270   0x2100             MOVS     R1,#+0
   \   00000272   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000274   0x2003             MOVS     R0,#+3
   \   00000276   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   0000027A   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   0000027E   0x7800             LDRB     R0,[R0, #+0]
   \   00000280   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   00000284   0x781B             LDRB     R3,[R3, #+0]
   \   00000286   0x1818             ADDS     R0,R3,R0
   \   00000288   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000028A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000028E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000294   0x5468             STRB     R0,[R5, R1]
   \   00000296   0xE0C8             B.N      ??CenterLineGet_6
   2204                      }
   2205                      else
   2206                      {
   2207                        CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLineHalfWidth[row], 0, CameraRealWidth - 1); 
   \                     ??CenterLineGet_20: (+1)
   \   00000298   0x22F9             MOVS     R2,#+249
   \   0000029A   0x2100             MOVS     R1,#+0
   \   0000029C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000029E   0x2003             MOVS     R0,#+3
   \   000002A0   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   000002A4   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000002A8   0x7800             LDRB     R0,[R0, #+0]
   \   000002AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002AC   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   000002B0   0x5CEB             LDRB     R3,[R5, R3]
   \   000002B2   0x1818             ADDS     R0,R3,R0
   \   000002B4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000002B6   0x.... 0x....      BL       BoundaryLimitRe
   \   000002BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002BC   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000002C0   0x5468             STRB     R0,[R5, R1]
   \   000002C2   0xE0B2             B.N      ??CenterLineGet_6
   2208                      }
   2209                  }
   2210                  //根据左线来估计中心线的走向，前提是上一行的左黑线有有效值。
   2211                  else if((row != CameraHight - 1)&&(BlackLeftLoc[row+1][0] != MaxValUint8))
   \                     ??CenterLineGet_19: (+1)
   \   000002C4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002C6   0x2D31             CMP      R5,#+49
   \   000002C8   0xF000 0x80A4      BEQ.W    ??CenterLineGet_21
   \   000002CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002CE   0x2003             MOVS     R0,#+3
   \   000002D0   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   000002D4   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000002D8   0x78C0             LDRB     R0,[R0, #+3]
   \   000002DA   0x28FF             CMP      R0,#+255
   \   000002DC   0xF000 0x809A      BEQ.W    ??CenterLineGet_21
   2212                  {  //上一行的中心线有效。
   2213                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   000002E0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002E2   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   000002E6   0x1828             ADDS     R0,R5,R0
   \   000002E8   0x7840             LDRB     R0,[R0, #+1]
   \   000002EA   0x28FF             CMP      R0,#+255
   \   000002EC   0xD019             BEQ.N    ??CenterLineGet_22
   2214                    {
   2215                      CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row + 1] + templ - BlackLeftLoc[row+1][0], 0, CameraRealWidth - 1);
   \   000002EE   0x22F9             MOVS     R2,#+249
   \   000002F0   0x2100             MOVS     R1,#+0
   \   000002F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002F4   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   000002F8   0x1828             ADDS     R0,R5,R0
   \   000002FA   0x7840             LDRB     R0,[R0, #+1]
   \   000002FC   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000002FE   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   00000302   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000304   0x2303             MOVS     R3,#+3
   \   00000306   0x.... 0x....      LDR.W    R6,??DataTable25_10
   \   0000030A   0xFB03 0x6305      MLA      R3,R3,R5,R6
   \   0000030E   0x78DB             LDRB     R3,[R3, #+3]
   \   00000310   0x1AC0             SUBS     R0,R0,R3
   \   00000312   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000314   0x.... 0x....      BL       BoundaryLimitRe
   \   00000318   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000031A   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000031E   0x5468             STRB     R0,[R5, R1]
   \   00000320   0xE083             B.N      ??CenterLineGet_6
   2216                    }
   2217                    //上一行的中心线无效。
   2218                    //如果是近处的行，那就有可能是270度左右黑线错位的情况。
   2219                    else if(row > CameraHight - 3)
   \                     ??CenterLineGet_22: (+1)
   \   00000322   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000324   0x2D30             CMP      R5,#+48
   \   00000326   0xDB2F             BLT.N    ??CenterLineGet_23
   2220                    { 
   2221                      if(CenterLocStore != MaxValUint8)
   \   00000328   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   0000032C   0x7800             LDRB     R0,[R0, #+0]
   \   0000032E   0x28FF             CMP      R0,#+255
   \   00000330   0xD014             BEQ.N    ??CenterLineGet_24
   2222                      {
   2223                        CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLocStore, 0, CameraRealWidth - 1);
   \   00000332   0x22F9             MOVS     R2,#+249
   \   00000334   0x2100             MOVS     R1,#+0
   \   00000336   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000338   0x2003             MOVS     R0,#+3
   \   0000033A   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   0000033E   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   00000342   0x7800             LDRB     R0,[R0, #+0]
   \   00000344   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   00000348   0x781B             LDRB     R3,[R3, #+0]
   \   0000034A   0x1818             ADDS     R0,R3,R0
   \   0000034C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000034E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000352   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000354   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000358   0x5468             STRB     R0,[R5, R1]
   \   0000035A   0xE066             B.N      ??CenterLineGet_6
   2224                      }
   2225                      else
   2226                      {
   2227                        CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLineHalfWidth[row], 0, CameraRealWidth - 1);
   \                     ??CenterLineGet_24: (+1)
   \   0000035C   0x22F9             MOVS     R2,#+249
   \   0000035E   0x2100             MOVS     R1,#+0
   \   00000360   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000362   0x2003             MOVS     R0,#+3
   \   00000364   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   00000368   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   0000036C   0x7800             LDRB     R0,[R0, #+0]
   \   0000036E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000370   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   00000374   0x5CEB             LDRB     R3,[R5, R3]
   \   00000376   0x1818             ADDS     R0,R3,R0
   \   00000378   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000037A   0x.... 0x....      BL       BoundaryLimitRe
   \   0000037E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000384   0x5468             STRB     R0,[R5, R1]
   \   00000386   0xE050             B.N      ??CenterLineGet_6
   2228                      }
   2229                      //flag001 = 1; //flag001是标志位，用以防止开头几行的中心线不连续的情况。
   2230                    }
   2231                    else
   2232                    { //找符合条件的行
   2233                      if(row <= CameraHight - 5)
   \                     ??CenterLineGet_23: (+1)
   \   00000388   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000038A   0x2D2E             CMP      R5,#+46
   \   0000038C   0xDA3C             BGE.N    ??CenterLineGet_25
   2234                      {
   2235                        for(i = 2; i <= 4; i++)
   \   0000038E   0x2602             MOVS     R6,#+2
   \   00000390   0xE000             B.N      ??CenterLineGet_26
   \                     ??CenterLineGet_27: (+1)
   \   00000392   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGet_26: (+1)
   \   00000394   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000396   0x2E05             CMP      R6,#+5
   \   00000398   0xDA2D             BGE.N    ??CenterLineGet_28
   2236                        {
   2237                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackLeftLoc[row+i][0] != MaxValUint8))
   \   0000039A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000039C   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   000003A0   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000003A4   0x5C40             LDRB     R0,[R0, R1]
   \   000003A6   0x28FF             CMP      R0,#+255
   \   000003A8   0xD0F3             BEQ.N    ??CenterLineGet_27
   \   000003AA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003AC   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   000003B0   0x2103             MOVS     R1,#+3
   \   000003B2   0x.... 0x....      LDR.W    R2,??DataTable25_10
   \   000003B6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000003BA   0x7800             LDRB     R0,[R0, #+0]
   \   000003BC   0x28FF             CMP      R0,#+255
   \   000003BE   0xD0E8             BEQ.N    ??CenterLineGet_27
   2238                          { //找到了符合条件的行。
   2239                            CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+i] + templ - BlackLeftLoc[row+i][0], 0, CameraRealWidth - 1);
   \   000003C0   0x22F9             MOVS     R2,#+249
   \   000003C2   0x2100             MOVS     R1,#+0
   \   000003C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003C6   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   000003CA   0x.... 0x....      LDR.W    R7,??DataTable25_12
   \   000003CE   0x5DC0             LDRB     R0,[R0, R7]
   \   000003D0   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003D2   0x1818             ADDS     R0,R3,R0
   \   000003D4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003D6   0xFA56 0xF385      UXTAB    R3,R6,R5
   \   000003DA   0x2703             MOVS     R7,#+3
   \   000003DC   0x.... 0x....      LDR.W    R12,??DataTable25_10
   \   000003E0   0xFB07 0xC303      MLA      R3,R7,R3,R12
   \   000003E4   0x781B             LDRB     R3,[R3, #+0]
   \   000003E6   0x1AC0             SUBS     R0,R0,R3
   \   000003E8   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000003EA   0x.... 0x....      BL       BoundaryLimitRe
   \   000003EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003F0   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000003F4   0x5468             STRB     R0,[R5, R1]
   2240                            break;
   2241                          }
   2242                        }
   2243                        if(i == 5) CenterLineLoc[row] = MaxValUint8; ////置无效值
   \                     ??CenterLineGet_28: (+1)
   \   000003F6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000003F8   0x2E05             CMP      R6,#+5
   \   000003FA   0xD116             BNE.N    ??CenterLineGet_6
   \   000003FC   0x20FF             MOVS     R0,#+255
   \   000003FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000400   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000404   0x5468             STRB     R0,[R5, R1]
   \   00000406   0xE010             B.N      ??CenterLineGet_6
   2244                      }
   2245                      else
   2246                      { //行数太高，不考虑这种情况。 
   2247                        CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_25: (+1)
   \   00000408   0x20FF             MOVS     R0,#+255
   \   0000040A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000040C   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000410   0x5468             STRB     R0,[R5, R1]
   \   00000412   0xE00A             B.N      ??CenterLineGet_6
   2248                      }
   2249                    }
   2250                  }
   2251                  else
   2252                  {
   2253                    CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_21: (+1)
   \   00000414   0x20FF             MOVS     R0,#+255
   \   00000416   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000418   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000041C   0x5468             STRB     R0,[R5, R1]
   \   0000041E   0xE004             B.N      ??CenterLineGet_6
   2254                  }
   2255                }
   2256                //该行左右线均提取失败。
   2257                else 
   2258                {
   2259                  CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_18: (+1)
   \   00000420   0x20FF             MOVS     R0,#+255
   \   00000422   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000424   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000428   0x5468             STRB     R0,[R5, R1]
   2260                }
   2261              if(CenterLineLoc[row] == MaxValUint8) 
   \                     ??CenterLineGet_6: (+1)
   \   0000042A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000042C   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   00000430   0x5C28             LDRB     R0,[R5, R0]
   \   00000432   0x28FF             CMP      R0,#+255
   \   00000434   0xD14D             BNE.N    ??CenterLineGet_29
   2262              {
   2263                FailCount++;
   \   00000436   0x1C64             ADDS     R4,R4,#+1
   2264                //对无效值的再处理。
   2265                tempmax = MinRe(BlackLeftHeadLine, BlackRightHeadLine);
   \   00000438   0x.... 0x....      LDR.W    R0,??DataTable26
   \   0000043C   0x7801             LDRB     R1,[R0, #+0]
   \   0000043E   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000442   0x7800             LDRB     R0,[R0, #+0]
   \   00000444   0x.... 0x....      BL       MinRe
   2266                if(row <= CameraHight-3 && CenterLineLoc[row+1] != MaxValUint8 && CenterLineLoc[row+2] != MaxValUint8)
   \   00000448   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000044A   0x2D30             CMP      R5,#+48
   \   0000044C   0xDA41             BGE.N    ??CenterLineGet_29
   \   0000044E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000450   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000454   0x1869             ADDS     R1,R5,R1
   \   00000456   0x7849             LDRB     R1,[R1, #+1]
   \   00000458   0x29FF             CMP      R1,#+255
   \   0000045A   0xD03A             BEQ.N    ??CenterLineGet_29
   \   0000045C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000045E   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000462   0x1869             ADDS     R1,R5,R1
   \   00000464   0x7889             LDRB     R1,[R1, #+2]
   \   00000466   0x29FF             CMP      R1,#+255
   \   00000468   0xD033             BEQ.N    ??CenterLineGet_29
   2267                {
   2268                  if(row >= tempmax)
   \   0000046A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000046C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000046E   0x4285             CMP      R5,R0
   \   00000470   0xD32F             BCC.N    ??CenterLineGet_29
   2269                  {
   2270                    if(CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2] < 0
   2271                     ||CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2] > CameraRealWidth - 1)
   \   00000472   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000474   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   00000478   0x1828             ADDS     R0,R5,R0
   \   0000047A   0x7840             LDRB     R0,[R0, #+1]
   \   0000047C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000047E   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000482   0x1869             ADDS     R1,R5,R1
   \   00000484   0x7849             LDRB     R1,[R1, #+1]
   \   00000486   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   0000048A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048C   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000490   0x1869             ADDS     R1,R5,R1
   \   00000492   0x7889             LDRB     R1,[R1, #+2]
   \   00000494   0x1A40             SUBS     R0,R0,R1
   \   00000496   0x1E00             SUBS     R0,R0,#+0
   \   00000498   0x28FA             CMP      R0,#+250
   \   0000049A   0xD21A             BCS.N    ??CenterLineGet_29
   2272                    {           
   2273                    }
   2274                    else
   2275                    {
   2276                      //条件均满足
   2277                      CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2], 0, CameraRealWidth - 1);
   \   0000049C   0x22F9             MOVS     R2,#+249
   \   0000049E   0x2100             MOVS     R1,#+0
   \   000004A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A2   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   000004A6   0x1828             ADDS     R0,R5,R0
   \   000004A8   0x7840             LDRB     R0,[R0, #+1]
   \   000004AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004AC   0x.... 0x....      LDR.W    R3,??DataTable25_12
   \   000004B0   0x18EB             ADDS     R3,R5,R3
   \   000004B2   0x785B             LDRB     R3,[R3, #+1]
   \   000004B4   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000004B8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004BA   0x.... 0x....      LDR.W    R3,??DataTable25_12
   \   000004BE   0x18EB             ADDS     R3,R5,R3
   \   000004C0   0x789B             LDRB     R3,[R3, #+2]
   \   000004C2   0x1AC0             SUBS     R0,R0,R3
   \   000004C4   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000004C6   0x.... 0x....      BL       BoundaryLimitRe
   \   000004CA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004CC   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000004D0   0x5468             STRB     R0,[R5, R1]
   2278                    }
   2279                  }
   2280                  else
   2281                  {
   2282                  }
   2283                }
   2284                else
   2285                {
   2286                }
   2287              }
   2288              if(row == 0) break;
   \                     ??CenterLineGet_29: (+1)
   \   000004D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004D4   0x2D00             CMP      R5,#+0
   \   000004D6   0xF47F 0xADB0      BNE.W    ??CenterLineGet_4
   2289              }// end of for 
   2290              
   2291              if(FailCount >= CameraHight) return 0;
   \   000004DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000004DC   0x2C32             CMP      R4,#+50
   \   000004DE   0xDB01             BLT.N    ??CenterLineGet_30
   \   000004E0   0x2000             MOVS     R0,#+0
   \   000004E2   0xE1EB             B.N      ??CenterLineGet_1
   2292              //中心线提取成功，记录线头，作为后面的单线线头。
   2293              if(row == 0) 
   \                     ??CenterLineGet_30: (+1)
   \   000004E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004E6   0x2D00             CMP      R5,#+0
   \   000004E8   0xD135             BNE.N    ??CenterLineGet_2
   2294              {
   2295                for(j = CameraHight - 1; ; j--)
   \   000004EA   0x2031             MOVS     R0,#+49
   \   000004EC   0xE000             B.N      ??CenterLineGet_31
   \                     ??CenterLineGet_32: (+1)
   \   000004EE   0x1E40             SUBS     R0,R0,#+1
   2296                { //最近的3行找线头。
   2297                  if(CenterLineLoc[j] != MaxValUint8 && BlackLeftLoc[j][0] != MaxValUint8 && BlackRightLoc[j][0] != MaxValUint8)
   \                     ??CenterLineGet_31: (+1)
   \   000004F0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004F2   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000004F6   0x5C41             LDRB     R1,[R0, R1]
   \   000004F8   0x29FF             CMP      R1,#+255
   \   000004FA   0xD027             BEQ.N    ??CenterLineGet_33
   \   000004FC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000004FE   0x2103             MOVS     R1,#+3
   \   00000500   0x.... 0x....      LDR.W    R2,??DataTable25_10
   \   00000504   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000508   0x7809             LDRB     R1,[R1, #+0]
   \   0000050A   0x29FF             CMP      R1,#+255
   \   0000050C   0xD01E             BEQ.N    ??CenterLineGet_33
   \   0000050E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000510   0x2103             MOVS     R1,#+3
   \   00000512   0x.... 0x....      LDR.W    R2,??DataTable25_11
   \   00000516   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000051A   0x7809             LDRB     R1,[R1, #+0]
   \   0000051C   0x29FF             CMP      R1,#+255
   \   0000051E   0xD015             BEQ.N    ??CenterLineGet_33
   2298                  {
   2299                    CenterLocStore = (BlackRightLoc[j][0] - BlackLeftLoc[j][0]) / 2;
   \   00000520   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000522   0x2103             MOVS     R1,#+3
   \   00000524   0x.... 0x....      LDR.W    R2,??DataTable25_11
   \   00000528   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000052C   0x7809             LDRB     R1,[R1, #+0]
   \   0000052E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000530   0x2203             MOVS     R2,#+3
   \   00000532   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   00000536   0xFB02 0x3000      MLA      R0,R2,R0,R3
   \   0000053A   0x7800             LDRB     R0,[R0, #+0]
   \   0000053C   0x1A08             SUBS     R0,R1,R0
   \   0000053E   0x2102             MOVS     R1,#+2
   \   00000540   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000544   0x.... 0x....      LDR.W    R1,??DataTable25_13
   \   00000548   0x7008             STRB     R0,[R1, #+0]
   2300                    break;
   \   0000054A   0xE002             B.N      ??CenterLineGet_34
   2301                  }
   2302                  if(j <= CameraHight - 4)
   \                     ??CenterLineGet_33: (+1)
   \   0000054C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000054E   0x282F             CMP      R0,#+47
   \   00000550   0xDACD             BGE.N    ??CenterLineGet_32
   2303                  {
   2304                    //CenterLocStore = MaxValUint8;
   2305                    break;
   2306                  }
   2307                }
   2308                return 1;
   \                     ??CenterLineGet_34: (+1)
   \   00000552   0x2001             MOVS     R0,#+1
   \   00000554   0xE1B2             B.N      ??CenterLineGet_1
   2309              }
   2310            } // end of if
   2311            
   2312            //左黑线提取成功，右黑线提取失败。就基本上按左线来估计中心线。
   2313            if((BlackLeftDone == 1) && (BlackRightDone == 0))
   \                     ??CenterLineGet_2: (+1)
   \   00000556   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000055A   0x7800             LDRB     R0,[R0, #+0]
   \   0000055C   0x2801             CMP      R0,#+1
   \   0000055E   0xF040 0x80DB      BNE.W    ??CenterLineGet_35
   \   00000562   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000566   0x7800             LDRB     R0,[R0, #+0]
   \   00000568   0x2800             CMP      R0,#+0
   \   0000056A   0xF040 0x80D5      BNE.W    ??CenterLineGet_35
   2314            {
   2315              for(row = CameraHight - 1; row > CameraHight - BlackStep1Size; row --)
   \   0000056E   0x2531             MOVS     R5,#+49
   \   00000570   0xE005             B.N      ??CenterLineGet_36
   2316              {
   2317                //找左线有效值。 //原为连续两行找有效值，现改为一行。
   2318                if(BlackLeftLoc[row][0] != MaxValUint8)
   2319                {
   2320                  if(CenterLocStore != MaxValUint8)
   2321                  {
   2322                    CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLocStore, 0, CameraRealWidth - 1);
   2323                  }
   2324                  else
   2325                  {
   2326                    CenterLineLoc[row] = BoundaryLimitRe(BlackLeftLoc[row][0] + CenterLineHalfWidth[row], 0, CameraRealWidth - 1);
   2327                  }
   2328                  break;
   2329                }
   2330                else
   2331                {
   2332                  CenterLineLoc[row] = MaxValUint8;
   \                     ??CenterLineGet_37: (+1)
   \   00000572   0x20FF             MOVS     R0,#+255
   \   00000574   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000576   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000057A   0x5468             STRB     R0,[R5, R1]
   2333                }
   \   0000057C   0x1E6D             SUBS     R5,R5,#+1
   \                     ??CenterLineGet_36: (+1)
   \   0000057E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000580   0x2D1A             CMP      R5,#+26
   \   00000582   0xDB37             BLT.N    ??CenterLineGet_38
   \   00000584   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000586   0x2003             MOVS     R0,#+3
   \   00000588   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   0000058C   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000590   0x7800             LDRB     R0,[R0, #+0]
   \   00000592   0x28FF             CMP      R0,#+255
   \   00000594   0xD0ED             BEQ.N    ??CenterLineGet_37
   \   00000596   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   0000059A   0x7800             LDRB     R0,[R0, #+0]
   \   0000059C   0x28FF             CMP      R0,#+255
   \   0000059E   0xD014             BEQ.N    ??CenterLineGet_39
   \   000005A0   0x22F9             MOVS     R2,#+249
   \   000005A2   0x2100             MOVS     R1,#+0
   \   000005A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005A6   0x2003             MOVS     R0,#+3
   \   000005A8   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   000005AC   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000005B0   0x7800             LDRB     R0,[R0, #+0]
   \   000005B2   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   000005B6   0x781B             LDRB     R3,[R3, #+0]
   \   000005B8   0x1818             ADDS     R0,R3,R0
   \   000005BA   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000005BC   0x.... 0x....      BL       BoundaryLimitRe
   \   000005C0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005C2   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000005C6   0x5468             STRB     R0,[R5, R1]
   \   000005C8   0xE014             B.N      ??CenterLineGet_40
   \                     ??CenterLineGet_39: (+1)
   \   000005CA   0x22F9             MOVS     R2,#+249
   \   000005CC   0x2100             MOVS     R1,#+0
   \   000005CE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005D0   0x2003             MOVS     R0,#+3
   \   000005D2   0x.... 0x....      LDR.W    R3,??DataTable25_10
   \   000005D6   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   000005DA   0x7800             LDRB     R0,[R0, #+0]
   \   000005DC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005DE   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   000005E2   0x5CEB             LDRB     R3,[R5, R3]
   \   000005E4   0x1818             ADDS     R0,R3,R0
   \   000005E6   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000005E8   0x.... 0x....      BL       BoundaryLimitRe
   \   000005EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005EE   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000005F2   0x5468             STRB     R0,[R5, R1]
   2334              }
   2335              //中心线提取失败。
   2336              if(row <= CameraHight - BlackStep1Size) return 0;
   \                     ??CenterLineGet_40: (+1)
   \                     ??CenterLineGet_38: (+1)
   \   000005F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005F6   0x2D1A             CMP      R5,#+26
   \   000005F8   0xDA01             BGE.N    ??CenterLineGet_41
   \   000005FA   0x2000             MOVS     R0,#+0
   \   000005FC   0xE15E             B.N      ??CenterLineGet_1
   2337              
   2338              //按照左线的趋势进行中心线的估计。
   2339              for(row --; ; row--)
   \                     ??CenterLineGet_41: (+1)
   \   000005FE   0x1E6D             SUBS     R5,R5,#+1
   \   00000600   0xE000             B.N      ??CenterLineGet_42
   \                     ??CenterLineGet_43: (+1)
   \   00000602   0x1E6D             SUBS     R5,R5,#+1
   2340              {
   2341                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGet_42: (+1)
   \   00000604   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000606   0x2003             MOVS     R0,#+3
   \   00000608   0x.... 0x....      LDR.W    R1,??DataTable25_10
   \   0000060C   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000610   0x7800             LDRB     R0,[R0, #+0]
   \   00000612   0x28FF             CMP      R0,#+255
   \   00000614   0xD072             BEQ.N    ??CenterLineGet_44
   2342                {   //上一行的中心线有效。
   2343                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   00000616   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000618   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   0000061C   0x1828             ADDS     R0,R5,R0
   \   0000061E   0x7840             LDRB     R0,[R0, #+1]
   \   00000620   0x28FF             CMP      R0,#+255
   \   00000622   0xD01F             BEQ.N    ??CenterLineGet_45
   2344                    {
   2345                      CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row + 1] + BlackLeftLoc[row][0] - BlackLeftLoc[row+1][0], 0, CameraRealWidth - 1);
   \   00000624   0x22F9             MOVS     R2,#+249
   \   00000626   0x2100             MOVS     R1,#+0
   \   00000628   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000062A   0x.... 0x....      LDR.W    R0,??DataTable25_12
   \   0000062E   0x1828             ADDS     R0,R5,R0
   \   00000630   0x7840             LDRB     R0,[R0, #+1]
   \   00000632   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000634   0x2303             MOVS     R3,#+3
   \   00000636   0x.... 0x....      LDR.W    R4,??DataTable25_10
   \   0000063A   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   0000063E   0x781B             LDRB     R3,[R3, #+0]
   \   00000640   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   00000644   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000646   0x2303             MOVS     R3,#+3
   \   00000648   0x.... 0x....      LDR.W    R4,??DataTable25_10
   \   0000064C   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   00000650   0x78DB             LDRB     R3,[R3, #+3]
   \   00000652   0x1AC0             SUBS     R0,R0,R3
   \   00000654   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000656   0x.... 0x....      BL       BoundaryLimitRe
   \   0000065A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000065C   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000660   0x5468             STRB     R0,[R5, R1]
   \   00000662   0xE050             B.N      ??CenterLineGet_46
   2346                    }
   2347                    //上一行的中心线无效。
   2348                    else
   2349                    { //找符合条件的行
   2350                      if(row <= CameraHight - 5)
   \                     ??CenterLineGet_45: (+1)
   \   00000664   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000666   0x2D2E             CMP      R5,#+46
   \   00000668   0xDA42             BGE.N    ??CenterLineGet_47
   2351                      {
   2352                        for(i = 2; i <= 4; i++)
   \   0000066A   0x2602             MOVS     R6,#+2
   \   0000066C   0xE000             B.N      ??CenterLineGet_48
   \                     ??CenterLineGet_49: (+1)
   \   0000066E   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGet_48: (+1)
   \   00000670   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000672   0x2E05             CMP      R6,#+5
   \   00000674   0xDA33             BGE.N    ??CenterLineGet_50
   2353                        {
   2354                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackLeftLoc[row+i][0] != MaxValUint8))
   \   00000676   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000678   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   0000067C   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000680   0x5C40             LDRB     R0,[R0, R1]
   \   00000682   0x28FF             CMP      R0,#+255
   \   00000684   0xD0F3             BEQ.N    ??CenterLineGet_49
   \   00000686   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000688   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   0000068C   0x2103             MOVS     R1,#+3
   \   0000068E   0x.... 0x....      LDR.W    R2,??DataTable25_10
   \   00000692   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000696   0x7800             LDRB     R0,[R0, #+0]
   \   00000698   0x28FF             CMP      R0,#+255
   \   0000069A   0xD0E8             BEQ.N    ??CenterLineGet_49
   2355                          { //找到了符合条件的行。
   2356                            CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+i] + BlackLeftLoc[row][0] - BlackLeftLoc[row+i][0], 0, CameraRealWidth - 1);
   \   0000069C   0x22F9             MOVS     R2,#+249
   \   0000069E   0x2100             MOVS     R1,#+0
   \   000006A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000006A2   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   000006A6   0x.... 0x....      LDR.W    R3,??DataTable25_12
   \   000006AA   0x5CC0             LDRB     R0,[R0, R3]
   \   000006AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006AE   0x2303             MOVS     R3,#+3
   \   000006B0   0x.... 0x....      LDR.W    R4,??DataTable25_10
   \   000006B4   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   000006B8   0x781B             LDRB     R3,[R3, #+0]
   \   000006BA   0x1818             ADDS     R0,R3,R0
   \   000006BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000006BE   0xFA56 0xF385      UXTAB    R3,R6,R5
   \   000006C2   0x2403             MOVS     R4,#+3
   \   000006C4   0x.... 0x....      LDR.W    R7,??DataTable25_10
   \   000006C8   0xFB04 0x7303      MLA      R3,R4,R3,R7
   \   000006CC   0x781B             LDRB     R3,[R3, #+0]
   \   000006CE   0x1AC0             SUBS     R0,R0,R3
   \   000006D0   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000006D2   0x.... 0x....      BL       BoundaryLimitRe
   \   000006D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006D8   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000006DC   0x5468             STRB     R0,[R5, R1]
   2357                            break;
   2358                          }
   2359                        }
   2360                        if(i == 5) CenterLineLoc[row] = MaxValUint8; ////置无效值
   \                     ??CenterLineGet_50: (+1)
   \   000006DE   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000006E0   0x2E05             CMP      R6,#+5
   \   000006E2   0xD110             BNE.N    ??CenterLineGet_46
   \   000006E4   0x20FF             MOVS     R0,#+255
   \   000006E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006E8   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000006EC   0x5468             STRB     R0,[R5, R1]
   \   000006EE   0xE00A             B.N      ??CenterLineGet_46
   2361                      }
   2362                      else
   2363                      { //行数太高，不考虑这种情况。 
   2364                        CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_47: (+1)
   \   000006F0   0x20FF             MOVS     R0,#+255
   \   000006F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006F4   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000006F8   0x5468             STRB     R0,[R5, R1]
   \   000006FA   0xE004             B.N      ??CenterLineGet_46
   2365                      }
   2366                    }
   2367                }
   2368                else
   2369                {
   2370                  CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_44: (+1)
   \   000006FC   0x20FF             MOVS     R0,#+255
   \   000006FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000700   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000704   0x5468             STRB     R0,[R5, R1]
   2371                }
   2372                
   2373                if(row == 0) break;
   \                     ??CenterLineGet_46: (+1)
   \   00000706   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000708   0x2D00             CMP      R5,#+0
   \   0000070A   0xF47F 0xAF7A      BNE.W    ??CenterLineGet_43
   2374              }       
   2375              if(row == 0) return 1;
   \   0000070E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000710   0x2D00             CMP      R5,#+0
   \   00000712   0xD101             BNE.N    ??CenterLineGet_35
   \   00000714   0x2001             MOVS     R0,#+1
   \   00000716   0xE0D1             B.N      ??CenterLineGet_1
   2376            } // end of if
   2377            
   2378            //右黑线提取成功，左黑线提取失败。就基本上按右线来估计中心线。
   2379            if((BlackLeftDone == 0) && (BlackRightDone == 1))
   \                     ??CenterLineGet_35: (+1)
   \   00000718   0x.... 0x....      LDR.W    R0,??DataTable25_1
   \   0000071C   0x7800             LDRB     R0,[R0, #+0]
   \   0000071E   0x2800             CMP      R0,#+0
   \   00000720   0xF040 0x80CB      BNE.W    ??CenterLineGet_51
   \   00000724   0x.... 0x....      LDR.W    R0,??DataTable25_2
   \   00000728   0x7800             LDRB     R0,[R0, #+0]
   \   0000072A   0x2801             CMP      R0,#+1
   \   0000072C   0xF040 0x80C5      BNE.W    ??CenterLineGet_51
   2380            {
   2381              //找中心线的线头。
   2382              for(row = CameraHight - 1; row > CameraHight - BlackStep1Size; row --)
   \   00000730   0x2531             MOVS     R5,#+49
   \   00000732   0xE005             B.N      ??CenterLineGet_52
   2383              {
   2384                //找右线有效值。 //原为连续两行找有效值，现改为一行。
   2385                if(BlackRightLoc[row][0] != MaxValUint8)
   2386                {
   2387                  if(CenterLocStore != MaxValUint8)
   2388                  {
   2389                    CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLocStore, 0, CameraRealWidth - 1);
   2390                  }
   2391                  else
   2392                  {
   2393                    CenterLineLoc[row] = BoundaryLimitRe(BlackRightLoc[row][0] - CenterLineHalfWidth[row], 0, CameraRealWidth - 1);
   2394                  }
   2395                  break;
   2396                }
   2397                else
   2398                {
   2399                  CenterLineLoc[row] = MaxValUint8;
   \                     ??CenterLineGet_53: (+1)
   \   00000734   0x20FF             MOVS     R0,#+255
   \   00000736   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000738   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   0000073C   0x5468             STRB     R0,[R5, R1]
   2400                }
   \   0000073E   0x1E6D             SUBS     R5,R5,#+1
   \                     ??CenterLineGet_52: (+1)
   \   00000740   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000742   0x2D1A             CMP      R5,#+26
   \   00000744   0xDB37             BLT.N    ??CenterLineGet_54
   \   00000746   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000748   0x2003             MOVS     R0,#+3
   \   0000074A   0x.... 0x....      LDR.W    R1,??DataTable25_11
   \   0000074E   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000752   0x7800             LDRB     R0,[R0, #+0]
   \   00000754   0x28FF             CMP      R0,#+255
   \   00000756   0xD0ED             BEQ.N    ??CenterLineGet_53
   \   00000758   0x.... 0x....      LDR.W    R0,??DataTable25_13
   \   0000075C   0x7800             LDRB     R0,[R0, #+0]
   \   0000075E   0x28FF             CMP      R0,#+255
   \   00000760   0xD014             BEQ.N    ??CenterLineGet_55
   \   00000762   0x22F9             MOVS     R2,#+249
   \   00000764   0x2100             MOVS     R1,#+0
   \   00000766   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000768   0x2003             MOVS     R0,#+3
   \   0000076A   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   0000076E   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   00000772   0x7800             LDRB     R0,[R0, #+0]
   \   00000774   0x.... 0x....      LDR.W    R3,??DataTable25_13
   \   00000778   0x781B             LDRB     R3,[R3, #+0]
   \   0000077A   0x1AC0             SUBS     R0,R0,R3
   \   0000077C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000077E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000782   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000784   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   00000788   0x5468             STRB     R0,[R5, R1]
   \   0000078A   0xE014             B.N      ??CenterLineGet_56
   \                     ??CenterLineGet_55: (+1)
   \   0000078C   0x22F9             MOVS     R2,#+249
   \   0000078E   0x2100             MOVS     R1,#+0
   \   00000790   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000792   0x2003             MOVS     R0,#+3
   \   00000794   0x.... 0x....      LDR.W    R3,??DataTable25_11
   \   00000798   0xFB00 0x3005      MLA      R0,R0,R5,R3
   \   0000079C   0x7800             LDRB     R0,[R0, #+0]
   \   0000079E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007A0   0x.... 0x....      LDR.W    R3,??DataTable25_14
   \   000007A4   0x5CEB             LDRB     R3,[R5, R3]
   \   000007A6   0x1AC0             SUBS     R0,R0,R3
   \   000007A8   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000007AA   0x.... 0x....      BL       BoundaryLimitRe
   \   000007AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007B0   0x.... 0x....      LDR.W    R1,??DataTable25_12
   \   000007B4   0x5468             STRB     R0,[R5, R1]
   2401              }
   2402              //没有找到中心线线头，中心线提取失败。
   2403              if(row <= CameraHight - BlackStep1Size) return 0;
   \                     ??CenterLineGet_56: (+1)
   \                     ??CenterLineGet_54: (+1)
   \   000007B6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007B8   0x2D1A             CMP      R5,#+26
   \   000007BA   0xDA01             BGE.N    ??CenterLineGet_57
   \   000007BC   0x2000             MOVS     R0,#+0
   \   000007BE   0xE07D             B.N      ??CenterLineGet_1
   2404              
   2405              //找到线头，按照左线的趋势进行中心线的估计。
   2406              for(row--; ; row--)
   \                     ??CenterLineGet_57: (+1)
   \   000007C0   0x1E6D             SUBS     R5,R5,#+1
   \   000007C2   0xE000             B.N      ??CenterLineGet_58
   \                     ??CenterLineGet_59: (+1)
   \   000007C4   0x1E6D             SUBS     R5,R5,#+1
   2407              {
   2408                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGet_58: (+1)
   \   000007C6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007C8   0x2003             MOVS     R0,#+3
   \   000007CA   0x....             LDR.N    R1,??DataTable25_11
   \   000007CC   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000007D0   0x7800             LDRB     R0,[R0, #+0]
   \   000007D2   0x28FF             CMP      R0,#+255
   \   000007D4   0xD065             BEQ.N    ??CenterLineGet_60
   2409                {
   2410                  //前一行的中心点有效的情况。
   2411                  if(CenterLineLoc[row+1] != MaxValUint8)
   \   000007D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007D8   0x....             LDR.N    R0,??DataTable25_12
   \   000007DA   0x1828             ADDS     R0,R5,R0
   \   000007DC   0x7840             LDRB     R0,[R0, #+1]
   \   000007DE   0x28FF             CMP      R0,#+255
   \   000007E0   0xD01B             BEQ.N    ??CenterLineGet_61
   2412                  {
   2413                    CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+1] + BlackRightLoc[row][0] - BlackRightLoc[row+1][0], 0, CameraRealWidth - 1);
   \   000007E2   0x22F9             MOVS     R2,#+249
   \   000007E4   0x2100             MOVS     R1,#+0
   \   000007E6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007E8   0x....             LDR.N    R0,??DataTable25_12
   \   000007EA   0x1828             ADDS     R0,R5,R0
   \   000007EC   0x7840             LDRB     R0,[R0, #+1]
   \   000007EE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000007F0   0x2303             MOVS     R3,#+3
   \   000007F2   0x....             LDR.N    R4,??DataTable25_11
   \   000007F4   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   000007F8   0x781B             LDRB     R3,[R3, #+0]
   \   000007FA   0xFA53 0xF080      UXTAB    R0,R3,R0
   \   000007FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000800   0x2303             MOVS     R3,#+3
   \   00000802   0x....             LDR.N    R4,??DataTable25_11
   \   00000804   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   00000808   0x78DB             LDRB     R3,[R3, #+3]
   \   0000080A   0x1AC0             SUBS     R0,R0,R3
   \   0000080C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000080E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000812   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000814   0x....             LDR.N    R1,??DataTable25_12
   \   00000816   0x5468             STRB     R0,[R5, R1]
   \   00000818   0xE047             B.N      ??CenterLineGet_62
   2414                  }
   2415                  //前一行的中心点无效的情况。
   2416                  else
   2417                  { //首先行数要够小。
   2418                    if(row <= CameraHight - 5)
   \                     ??CenterLineGet_61: (+1)
   \   0000081A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000081C   0x2D2E             CMP      R5,#+46
   \   0000081E   0xDA3B             BGE.N    ??CenterLineGet_63
   2419                    { //查找是否有中心线有效的行。
   2420                      for(i = 2; i <= 4; i++)
   \   00000820   0x2602             MOVS     R6,#+2
   \   00000822   0xE000             B.N      ??CenterLineGet_64
   \                     ??CenterLineGet_65: (+1)
   \   00000824   0x1C76             ADDS     R6,R6,#+1
   \                     ??CenterLineGet_64: (+1)
   \   00000826   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000828   0x2E05             CMP      R6,#+5
   \   0000082A   0xDA2D             BGE.N    ??CenterLineGet_66
   2421                      {
   2422                        if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackRightLoc[row+i][0] != MaxValUint8))
   \   0000082C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000082E   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   00000832   0x....             LDR.N    R1,??DataTable25_12
   \   00000834   0x5C40             LDRB     R0,[R0, R1]
   \   00000836   0x28FF             CMP      R0,#+255
   \   00000838   0xD0F4             BEQ.N    ??CenterLineGet_65
   \   0000083A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000083C   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   00000840   0x2103             MOVS     R1,#+3
   \   00000842   0x....             LDR.N    R2,??DataTable25_11
   \   00000844   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000848   0x7800             LDRB     R0,[R0, #+0]
   \   0000084A   0x28FF             CMP      R0,#+255
   \   0000084C   0xD0EA             BEQ.N    ??CenterLineGet_65
   2423                        {
   2424                          CenterLineLoc[row] = BoundaryLimitRe(CenterLineLoc[row+i] + BlackRightLoc[row][0] - BlackRightLoc[row+i][0], 0, CameraRealWidth - 1);
   \   0000084E   0x22F9             MOVS     R2,#+249
   \   00000850   0x2100             MOVS     R1,#+0
   \   00000852   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000854   0xFA56 0xF085      UXTAB    R0,R6,R5
   \   00000858   0x....             LDR.N    R3,??DataTable25_12
   \   0000085A   0x5CC0             LDRB     R0,[R0, R3]
   \   0000085C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000085E   0x2303             MOVS     R3,#+3
   \   00000860   0x....             LDR.N    R4,??DataTable25_11
   \   00000862   0xFB03 0x4305      MLA      R3,R3,R5,R4
   \   00000866   0x781B             LDRB     R3,[R3, #+0]
   \   00000868   0x1818             ADDS     R0,R3,R0
   \   0000086A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000086C   0xFA56 0xF385      UXTAB    R3,R6,R5
   \   00000870   0x2403             MOVS     R4,#+3
   \   00000872   0x....             LDR.N    R7,??DataTable25_11
   \   00000874   0xFB04 0x7303      MLA      R3,R4,R3,R7
   \   00000878   0x781B             LDRB     R3,[R3, #+0]
   \   0000087A   0x1AC0             SUBS     R0,R0,R3
   \   0000087C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000087E   0x.... 0x....      BL       BoundaryLimitRe
   \   00000882   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000884   0x....             LDR.N    R1,??DataTable25_12
   \   00000886   0x5468             STRB     R0,[R5, R1]
   2425                          break;
   2426                        }
   2427                      }
   2428                      //连续3行没找到符合要求的行，置无效值。
   2429                      if(i == 5) CenterLineLoc[row] = MaxValUint8; 
   \                     ??CenterLineGet_66: (+1)
   \   00000888   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000088A   0x2E05             CMP      R6,#+5
   \   0000088C   0xD10D             BNE.N    ??CenterLineGet_62
   \   0000088E   0x20FF             MOVS     R0,#+255
   \   00000890   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000892   0x....             LDR.N    R1,??DataTable25_12
   \   00000894   0x5468             STRB     R0,[R5, R1]
   \   00000896   0xE008             B.N      ??CenterLineGet_62
   2430                    }
   2431                    //行数太高，处理不了。
   2432                    else
   2433                    {
   2434                      CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_63: (+1)
   \   00000898   0x20FF             MOVS     R0,#+255
   \   0000089A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000089C   0x....             LDR.N    R1,??DataTable25_12
   \   0000089E   0x5468             STRB     R0,[R5, R1]
   \   000008A0   0xE003             B.N      ??CenterLineGet_62
   2435                    }
   2436                  }
   2437                }
   2438                else
   2439                {
   2440                  CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_60: (+1)
   \   000008A2   0x20FF             MOVS     R0,#+255
   \   000008A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000008A6   0x....             LDR.N    R1,??DataTable25_12
   \   000008A8   0x5468             STRB     R0,[R5, R1]
   2441                }
   2442                
   2443                if(row == 0) break;
   \                     ??CenterLineGet_62: (+1)
   \   000008AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000008AC   0x2D00             CMP      R5,#+0
   \   000008AE   0xD189             BNE.N    ??CenterLineGet_59
   2444              }       
   2445              if(row == 0) return 1;
   \   000008B0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000008B2   0x2D00             CMP      R5,#+0
   \   000008B4   0xD101             BNE.N    ??CenterLineGet_51
   \   000008B6   0x2001             MOVS     R0,#+1
   \   000008B8   0xE000             B.N      ??CenterLineGet_1
   2446            } // end of if
   2447            
   2448            return 0; 
   \                     ??CenterLineGet_51: (+1)
   \   000008BA   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_1: (+1)
   \   000008BC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2449          }
   2450          
   2451          //中心线补充处理，若到不了第25行，就补到第25行。超过250就置成250。

   \                                 In section .text, align 2, keep-with-next
   2452          uint8 CenterLineGetCom(void)
   2453          {
   \                     CenterLineGetCom: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2454            uint8 row;
   2455            
   2456            for(row = 0; ; row++)
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE000             B.N      ??CenterLineGetCom_0
   \                     ??CenterLineGetCom_1: (+1)
   \   00000006   0x1C64             ADDS     R4,R4,#+1
   2457            {
   2458              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CenterLineGetCom_0: (+1)
   \   00000008   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000A   0x....             LDR.N    R0,??DataTable25_12
   \   0000000C   0x5C20             LDRB     R0,[R4, R0]
   \   0000000E   0x28FF             CMP      R0,#+255
   \   00000010   0xD0F9             BEQ.N    ??CenterLineGetCom_1
   2459              {
   2460                if(row < CenterKeyLine)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001A   0x4284             CMP      R4,R0
   \   0000001C   0xD201             BCS.N    ??CenterLineGetCom_2
   2461                {
   2462                  break;
   \   0000001E   0xE01C             B.N      ??CenterLineGetCom_3
   2463                }
   2464                else
   2465                {
   2466                  for(; ; row--)
   \                     ??CenterLineGetCom_4: (+1)
   \   00000020   0x1E64             SUBS     R4,R4,#+1
   2467                  {
   2468                    CenterLineLoc[row-1] = BoundaryLimitRe(CenterLineLoc[row] + CenterLineLoc[row] - CenterLineLoc[row+1], 0, CameraRealWidth - 1);
   \                     ??CenterLineGetCom_2: (+1)
   \   00000022   0x22F9             MOVS     R2,#+249
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000028   0x....             LDR.N    R0,??DataTable25_12
   \   0000002A   0x5C20             LDRB     R0,[R4, R0]
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x....             LDR.N    R3,??DataTable25_12
   \   00000030   0x5CE3             LDRB     R3,[R4, R3]
   \   00000032   0x1818             ADDS     R0,R3,R0
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x....             LDR.N    R3,??DataTable25_12
   \   00000038   0x18E3             ADDS     R3,R4,R3
   \   0000003A   0x785B             LDRB     R3,[R3, #+1]
   \   0000003C   0x1AC0             SUBS     R0,R0,R3
   \   0000003E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000040   0x.... 0x....      BL       BoundaryLimitRe
   \   00000044   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000046   0x....             LDR.N    R1,??DataTable25_12
   \   00000048   0x1861             ADDS     R1,R4,R1
   \   0000004A   0xF801 0x0C01      STRB     R0,[R1, #-1]
   2469                    if(row <= CenterKeyLine) break;          
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable29
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000056   0x42A0             CMP      R0,R4
   \   00000058   0xD3E2             BCC.N    ??CenterLineGetCom_4
   2470                  }
   2471                  break;
   2472                }
   2473              }
   2474            }
   2475            
   2476            return 1;
   \                     ??CenterLineGetCom_3: (+1)
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   2477          }
   2478          
   2479          
   2480          
   2481          
   2482          
   2483          //图像重新赋值,行不变（行中DMA中变化，选取需要的行），列无法在DMA中变化，就在这里变化。

   \                                 In section .text, align 2, keep-with-next
   2484          void ImgPut(void)
   2485          {
   \                     ImgPut: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2486              uint16 i, j, k, temp1, temp2;   
   2487              
   2488              temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
   \   00000002   0x2322             MOVS     R3,#+34
   2489              temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
   \   00000004   0xF44F 0x748E      MOV      R4,#+284
   2490              
   2491              for(i = 0; i < CameraHight; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE017             B.N      ??ImgPut_0
   2492              {
   2493                k = 0;
   2494                for(j = temp1; j < temp2; j++)
   2495                {
   2496                  ImgNew[i][k] = ImgRaw[i][j];
   \                     ??ImgPut_1: (+1)
   \   0000000C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x25FA             MOVS     R5,#+250
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable29_1
   \   00000016   0xFB05 0x6500      MLA      R5,R5,R0,R6
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0xF44F 0x76A0      MOV      R6,#+320
   \   00000022   0x.... 0x....      LDR.W    R7,??DataTable29_2
   \   00000026   0xFB06 0x7600      MLA      R6,R6,R0,R7
   \   0000002A   0x5D8E             LDRB     R6,[R1, R6]
   \   0000002C   0x5556             STRB     R6,[R2, R5]
   2497                  k++;
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   2498                }
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \                     ??ImgPut_2: (+1)
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x42A1             CMP      R1,R4
   \   00000038   0xD3E8             BCC.N    ??ImgPut_1
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \                     ??ImgPut_0: (+1)
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x2832             CMP      R0,#+50
   \   00000040   0xDA02             BGE.N    ??ImgPut_3
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x0019             MOVS     R1,R3
   \   00000046   0xE7F4             B.N      ??ImgPut_2
   2499              }
   2500          }
   \                     ??ImgPut_3: (+1)
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
   2501          
   2502          
   2503          //开根号运算
   2504          //本来传进来传出去都是uint16型的，但是我调用的时候只会用到uint8型的，且不会超出255.

   \                                 In section .text, align 2, keep-with-next
   2505          uint16 MathSqrt(uint16 x1)
   2506          {
   2507            uint8 ans = 0, p = 0x80;
   \                     MathSqrt: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2280             MOVS     R2,#+128
   2508            uint16 x = x1;
   \   00000004   0xE00C             B.N      ??MathSqrt_0
   2509            
   2510            while(p!=0)
   2511            {
   2512              ans += p;
   \                     ??MathSqrt_1: (+1)
   \   00000006   0x1851             ADDS     R1,R2,R1
   2513              if(ans * ans > x) ans -=p;
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xFB01 0xF301      MUL      R3,R1,R1
   \   00000012   0x4298             CMP      R0,R3
   \   00000014   0xDA00             BGE.N    ??MathSqrt_2
   \   00000016   0x1A89             SUBS     R1,R1,R2
   2514              p = (uint8)(p / 2);
   \                     ??MathSqrt_2: (+1)
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2302             MOVS     R3,#+2
   \   0000001C   0xFB92 0xF2F3      SDIV     R2,R2,R3
   2515            }
   \                     ??MathSqrt_0: (+1)
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD1EF             BNE.N    ??MathSqrt_1
   2516            return ans;  
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x0008             MOVS     R0,R1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4770             BX       LR               ;; return
   2517          }
   2518          
   2519          //曲线的曲率求取，曲线向右拐（三点为顺时针方向分布），曲率为负，曲线向左拐（三点为逆时钟方向分布），曲率为正
   2520          //K = 4*SABC/AB/BC/AC

   \                                 In section .text, align 2, keep-with-next
   2521          int16 CurveGet(uint8 AX, uint8 AY, uint8 BX, uint8 BY, uint8 CX, uint8 CY)
   2522          {
   \                     CurveGet: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x469B             MOV      R11,R3
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
   \   0000000E   0x9D0B             LDR      R5,[SP, #+44]
   2523            int16 SABC_temp; //三角形的面积，有正负。
   2524            int16 tempab, tempbc, tempac;
   2525            int16 AB, BC, AC; //三角形的边长，均为正。
   2526            //int16 K;        //曲率结果，有正负。
   2527            
   2528            SABC_temp = ((BX - AX) * (CY - AY) - (CX - AX) * (BY - AY));
   \   00000010   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000014   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000018   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000022   0xEBB5 0x010A      SUBS     R1,R5,R10
   \   00000026   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000002A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002E   0xEBBB 0x020A      SUBS     R2,R11,R10
   \   00000032   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xEBB9 0x0304      SUBS     R3,R9,R4
   \   0000003C   0x435A             MULS     R2,R3,R2
   \   0000003E   0xFB01 0x2600      MLA      R6,R1,R0,R2
   2529            
   2530            tempab = (BX - AX) * (BX - AX) + (BY - AY) * (BY - AY);
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000004A   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000056   0xEBB8 0x0109      SUBS     R1,R8,R9
   \   0000005A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000005E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000062   0xEBBB 0x020A      SUBS     R2,R11,R10
   \   00000066   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000006A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006E   0xEBBB 0x030A      SUBS     R3,R11,R10
   \   00000072   0x435A             MULS     R2,R3,R2
   \   00000074   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2531            if(tempab > 100) 
   \   00000078   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000007A   0x2865             CMP      R0,#+101
   \   0000007C   0xDB0A             BLT.N    ??CurveGet_0
   2532            {
   2533              AB = MathSqrt(tempab / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   0000007E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000080   0x2164             MOVS     R1,#+100
   \   00000082   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0x.... 0x....      BL       MathSqrt
   \   0000008C   0x210A             MOVS     R1,#+10
   \   0000008E   0xFB10 0xF701      SMULBB   R7,R0,R1
   \   00000092   0xE003             B.N      ??CurveGet_1
   2534            }
   2535            else
   2536            {
   2537              AB = MathSqrt(tempab);
   \                     ??CurveGet_0: (+1)
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x.... 0x....      BL       MathSqrt
   \   0000009A   0x0007             MOVS     R7,R0
   2538            }
   2539            
   2540            tempbc = (BX - CX) * (BX - CX) + (BY - CY) * (BY - CY);
   \                     ??CurveGet_1: (+1)
   \   0000009C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0xEBB8 0x0004      SUBS     R0,R8,R4
   \   000000A6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   0xEBB8 0x0104      SUBS     R1,R8,R4
   \   000000B0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B6   0xEBBB 0x0205      SUBS     R2,R11,R5
   \   000000BA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0xEBBB 0x0305      SUBS     R3,R11,R5
   \   000000C4   0x435A             MULS     R2,R3,R2
   \   000000C6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2541            if(tempbc > 100) 
   \   000000CA   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000CC   0x2865             CMP      R0,#+101
   \   000000CE   0xDB0A             BLT.N    ??CurveGet_2
   2542            {
   2543              BC = MathSqrt(tempbc / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   000000D0   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000D2   0x2164             MOVS     R1,#+100
   \   000000D4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000D8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DA   0x.... 0x....      BL       MathSqrt
   \   000000DE   0x210A             MOVS     R1,#+10
   \   000000E0   0xFB10 0xF801      SMULBB   R8,R0,R1
   \   000000E4   0xE003             B.N      ??CurveGet_3
   2544            }
   2545            else
   2546            {
   2547              BC = MathSqrt(tempbc);
   \                     ??CurveGet_2: (+1)
   \   000000E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E8   0x.... 0x....      BL       MathSqrt
   \   000000EC   0x4680             MOV      R8,R0
   2548            }
   2549            
   2550            tempac = (CX - AX) * (CX - AX) + (CY - AY) * (CY - AY);
   \                     ??CurveGet_3: (+1)
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F4   0xEBB4 0x0009      SUBS     R0,R4,R9
   \   000000F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000FE   0xEBB4 0x0109      SUBS     R1,R4,R9
   \   00000102   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000104   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000108   0xEBB5 0x020A      SUBS     R2,R5,R10
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000112   0xEBB5 0x030A      SUBS     R3,R5,R10
   \   00000116   0x435A             MULS     R2,R3,R2
   \   00000118   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2551            if(tempac > 100) 
   \   0000011C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000011E   0x2865             CMP      R0,#+101
   \   00000120   0xDB0A             BLT.N    ??CurveGet_4
   2552            {
   2553              AC = MathSqrt(tempac / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   00000122   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000124   0x2164             MOVS     R1,#+100
   \   00000126   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000012A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000012C   0x.... 0x....      BL       MathSqrt
   \   00000130   0x210A             MOVS     R1,#+10
   \   00000132   0xFB10 0xF001      SMULBB   R0,R0,R1
   \   00000136   0xE002             B.N      ??CurveGet_5
   2554            }
   2555            else
   2556            {
   2557              AC = MathSqrt(tempac);
   \                     ??CurveGet_4: (+1)
   \   00000138   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000013A   0x.... 0x....      BL       MathSqrt
   2558            }
   2559            
   2560            return (CurveGetCompen * SABC_temp / AB / BC / AC);
   \                     ??CurveGet_5: (+1)
   \   0000013E   0x.... 0x....      LDR.W    R1,??DataTable29_3
   \   00000142   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000146   0xFB11 0xF106      SMULBB   R1,R1,R6
   \   0000014A   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000014C   0xFB91 0xF1F7      SDIV     R1,R1,R7
   \   00000150   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000154   0xFB91 0xF1F8      SDIV     R1,R1,R8
   \   00000158   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000015A   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000015E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000160   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2561          }
   2562          
   2563          
   2564          
   2565          //SABC的面积求取，顺时针则返回负值，逆时针则返回正值。
   2566          //以左下角为原点，向右为x轴正方向(0~249)，向上为y轴正方向(0~49)。

   \                                 In section .text, align 2, keep-with-next
   2567          int16 SABCGet(uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 x3, uint8 y3)
   2568          {
   \                     SABCGet: (+1)
   \   00000000   0xB410             PUSH     {R4}
   2569            int16 SABC_temp;
   2570            
   2571            SABC_temp = ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / 2;
   \   00000002   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x1A14             SUBS     R4,R2,R0
   \   00000008   0x9A02             LDR      R2,[SP, #+8]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0x1A52             SUBS     R2,R2,R1
   \   0000000E   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000010   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000012   0x1A5B             SUBS     R3,R3,R1
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x9901             LDR      R1,[SP, #+4]
   \   00000018   0x1A40             SUBS     R0,R0,R1
   \   0000001A   0xFB00 0xF003      MUL      R0,R0,R3
   \   0000001E   0xFB02 0x0004      MLA      R0,R2,R4,R0
   \   00000022   0x2102             MOVS     R1,#+2
   \   00000024   0xFB90 0xF0F1      SDIV     R0,R0,R1
   2572            
   2573            return SABC_temp;
   \   00000028   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002A   0xBC10             POP      {R4}
   \   0000002C   0x4770             BX       LR               ;; return
   2574          }
   2575          
   2576          
   2577          //曲率符号求取
   2578          //影响：CurveSL, CurveSC, CurveSR, 0无效，1正，2负
   2579          //      SABCL, SABCC, SABCR

   \                                 In section .text, align 2, keep-with-next
   2580          uint8 CurveSignGet(void)
   2581          {
   \                     CurveSignGet: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2582            uint8 row;
   2583            uint8 temp;
   2584            
   2585            //1. 中心线曲率符号求取
   2586            //曲率符号预先清零。
   2587            CurveLineChosenC1 = MaxValUint8;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
   2588            CurveLineChosenC2 = MaxValUint8;
   \   0000000C   0x20FF             MOVS     R0,#+255
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   2589            CurveLineChosenC3 = MaxValUint8;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable29_6
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   2590            
   2591            //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2592            for(row = 0; ; row++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE000             B.N      ??CurveSignGet_0
   \                     ??CurveSignGet_1: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   2593            {
   2594              if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x2830             CMP      R0,#+48
   \   00000026   0xDB05             BLT.N    ??CurveSignGet_2
   2595              {
   2596                CurveLineChosenC1 = MaxValUint8;
   \   00000028   0x20FF             MOVS     R0,#+255
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
   2597                return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE1DD             B.N      ??CurveSignGet_3
   2598              }
   2599              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_2: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   0000003A   0x5C41             LDRB     R1,[R0, R1]
   \   0000003C   0x29FF             CMP      R1,#+255
   \   0000003E   0xD0EF             BEQ.N    ??CurveSignGet_1
   2600              {
   2601                CurveLineChosenC1 = row;
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   2602                break;
   2603              }   
   2604            }
   2605            //把第1个有效值到CameraHight-1的距离分成2段。
   2606            temp = (CameraHight - 1 - row) / 2;
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2607            if(temp == 0) 
   \   00000052   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD105             BNE.N    ??CurveSignGet_4
   2608            {
   2609              CurveLineChosenC1 = MaxValUint8;
   \   00000058   0x20FF             MOVS     R0,#+255
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   0000005E   0x7008             STRB     R0,[R1, #+0]
   2610              return 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE1C5             B.N      ??CurveSignGet_3
   2611            }
   2612            
   2613            //曲率基于的行2 CurveLineChosen2
   2614            for(row = CurveLineChosenC1 + temp; ; row++)
   \                     ??CurveSignGet_4: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable29_4
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0xE000             B.N      ??CurveSignGet_5
   \                     ??CurveSignGet_6: (+1)
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   2615            {
   2616              if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_5: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2831             CMP      R0,#+49
   \   00000074   0xDB09             BLT.N    ??CurveSignGet_7
   2617              {
   2618                CurveLineChosenC1 = MaxValUint8;
   \   00000076   0x20FF             MOVS     R0,#+255
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
   2619                CurveLineChosenC2 = MaxValUint8;
   \   0000007E   0x20FF             MOVS     R0,#+255
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   00000084   0x7008             STRB     R0,[R1, #+0]
   2620                return 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE1B2             B.N      ??CurveSignGet_3
   2621              }
   2622              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_7: (+1)
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable29_7
   \   00000090   0x5C82             LDRB     R2,[R0, R2]
   \   00000092   0x2AFF             CMP      R2,#+255
   \   00000094   0xD0EB             BEQ.N    ??CurveSignGet_6
   2623              {
   2624                CurveLineChosenC2 = row;
   \   00000096   0x.... 0x....      LDR.W    R2,??DataTable29_5
   \   0000009A   0x7010             STRB     R0,[R2, #+0]
   2625                break;
   2626              }
   2627            }
   2628            
   2629            //曲率基于的行3 CurveLineChosen3
   2630            for(row = CurveLineChosenC2 + temp; ; row++)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable29_5
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x1808             ADDS     R0,R1,R0
   \   000000A4   0xE000             B.N      ??CurveSignGet_8
   \                     ??CurveSignGet_9: (+1)
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   2631            {
   2632              if(row >= CameraHight) 
   \                     ??CurveSignGet_8: (+1)
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x2832             CMP      R0,#+50
   \   000000AC   0xDB0D             BLT.N    ??CurveSignGet_10
   2633              {
   2634                CurveLineChosenC1 = MaxValUint8;
   \   000000AE   0x20FF             MOVS     R0,#+255
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable29_4
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
   2635                CurveLineChosenC2 = MaxValUint8;
   \   000000B6   0x20FF             MOVS     R0,#+255
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable29_5
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
   2636                CurveLineChosenC3 = MaxValUint8;
   \   000000BE   0x20FF             MOVS     R0,#+255
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable29_6
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   2637                return 0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xE192             B.N      ??CurveSignGet_3
   2638              }
   2639              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_10: (+1)
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   000000D0   0x5C41             LDRB     R1,[R0, R1]
   \   000000D2   0x29FF             CMP      R1,#+255
   \   000000D4   0xD0E7             BEQ.N    ??CurveSignGet_9
   2640              {
   2641                CurveLineChosenC3 = row;
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable29_6
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   2642                break;
   2643              }
   2644            } 
   2645            //SABCC中心线曲率三角形面积的求取
   2646            //SABCC = SABCGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
   2647            //                CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
   2648            //                CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
   2649            //                );
   2650            CURVEC = CurveGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
   2651                             CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
   2652                             CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
   2653                             );    
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable29_6
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable29_6
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   000000F4   0x5C40             LDRB     R0,[R0, R1]
   \   000000F6   0x9000             STR      R0,[SP, #+0]
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable29_5
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   00000102   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable29_5
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable29_7
   \   0000010E   0x5C42             LDRB     R2,[R0, R1]
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable29_4
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   0000011A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable29_4
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x.... 0x....      LDR.W    R4,??DataTable29_7
   \   00000126   0x5D00             LDRB     R0,[R0, R4]
   \   00000128   0x.... 0x....      BL       CurveGet
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable29_8
   \   00000130   0x8008             STRH     R0,[R1, #+0]
   2654            
   2655            
   2656            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
   2657            if(BlackLeftDone == 1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable29_9
   \   00000136   0x7800             LDRB     R0,[R0, #+0]
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xF040 0x80A9      BNE.W    ??CurveSignGet_11
   2658            {
   2659              //2. 左黑线曲率符号求取
   2660              //曲率符号预先清零。
   2661              CurveLineChosenL1 = MaxValUint8;
   \   0000013E   0x20FF             MOVS     R0,#+255
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   00000144   0x7008             STRB     R0,[R1, #+0]
   2662              CurveLineChosenL2 = MaxValUint8;
   \   00000146   0x20FF             MOVS     R0,#+255
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable29_11
   \   0000014C   0x7008             STRB     R0,[R1, #+0]
   2663              CurveLineChosenL3 = MaxValUint8;
   \   0000014E   0x20FF             MOVS     R0,#+255
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable29_12
   \   00000154   0x7008             STRB     R0,[R1, #+0]
   2664              
   2665              //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2666              for(row = 0; ; row++)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xE000             B.N      ??CurveSignGet_12
   \                     ??CurveSignGet_13: (+1)
   \   0000015A   0x1C40             ADDS     R0,R0,#+1
   2667              {
   2668                if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_12: (+1)
   \   0000015C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015E   0x2830             CMP      R0,#+48
   \   00000160   0xDB05             BLT.N    ??CurveSignGet_14
   2669                {
   2670                  CurveLineChosenL1 = MaxValUint8;
   \   00000162   0x20FF             MOVS     R0,#+255
   \   00000164   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   00000168   0x7008             STRB     R0,[R1, #+0]
   2671                  return 0;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0xE140             B.N      ??CurveSignGet_3
   2672                }
   2673                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_14: (+1)
   \   0000016E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000170   0x2103             MOVS     R1,#+3
   \   00000172   0x.... 0x....      LDR.W    R2,??DataTable29_13
   \   00000176   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000017A   0x7809             LDRB     R1,[R1, #+0]
   \   0000017C   0x29FF             CMP      R1,#+255
   \   0000017E   0xD0EC             BEQ.N    ??CurveSignGet_13
   2674                {
   2675                  CurveLineChosenL1 = row;
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   00000184   0x7008             STRB     R0,[R1, #+0]
   2676                  break;
   2677                }   
   2678              }
   2679              //把第1个有效值到CameraHight-1的距离分成2段。
   2680              temp = (CameraHight - 1 - row) / 2;
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   0000018C   0x2102             MOVS     R1,#+2
   \   0000018E   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2681              if(temp == 0) 
   \   00000192   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000194   0x2900             CMP      R1,#+0
   \   00000196   0xD105             BNE.N    ??CurveSignGet_15
   2682              {
   2683                CurveLineChosenL1 = MaxValUint8;
   \   00000198   0x20FF             MOVS     R0,#+255
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   0000019E   0x7008             STRB     R0,[R1, #+0]
   2684                return 0;
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE125             B.N      ??CurveSignGet_3
   2685              }
   2686              
   2687              //曲率基于的行2 CurveLineChosen2
   2688              for(row = CurveLineChosenL1 + temp; ; row++)
   \                     ??CurveSignGet_15: (+1)
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable29_10
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0x1808             ADDS     R0,R1,R0
   \   000001AC   0xE000             B.N      ??CurveSignGet_16
   \                     ??CurveSignGet_17: (+1)
   \   000001AE   0x1C40             ADDS     R0,R0,#+1
   2689              {
   2690                if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_16: (+1)
   \   000001B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B2   0x2831             CMP      R0,#+49
   \   000001B4   0xDB09             BLT.N    ??CurveSignGet_18
   2691                {
   2692                  CurveLineChosenL1 = MaxValUint8;
   \   000001B6   0x20FF             MOVS     R0,#+255
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   000001BC   0x7008             STRB     R0,[R1, #+0]
   2693                  CurveLineChosenL2 = MaxValUint8;
   \   000001BE   0x20FF             MOVS     R0,#+255
   \   000001C0   0x.... 0x....      LDR.W    R1,??DataTable29_11
   \   000001C4   0x7008             STRB     R0,[R1, #+0]
   2694                  return 0;
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0xE112             B.N      ??CurveSignGet_3
   2695                }
   2696                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_18: (+1)
   \   000001CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CC   0x2203             MOVS     R2,#+3
   \   000001CE   0x.... 0x....      LDR.W    R3,??DataTable29_13
   \   000001D2   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   000001D6   0x7812             LDRB     R2,[R2, #+0]
   \   000001D8   0x2AFF             CMP      R2,#+255
   \   000001DA   0xD0E8             BEQ.N    ??CurveSignGet_17
   2697                {
   2698                  CurveLineChosenL2 = row;
   \   000001DC   0x.... 0x....      LDR.W    R2,??DataTable29_11
   \   000001E0   0x7010             STRB     R0,[R2, #+0]
   2699                  break;
   2700                }
   2701              }
   2702              
   2703              //曲率基于的行3 CurveLineChosen3
   2704              for(row = CurveLineChosenL2 + temp; ; row++)
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable29_11
   \   000001E6   0x7800             LDRB     R0,[R0, #+0]
   \   000001E8   0x1808             ADDS     R0,R1,R0
   \   000001EA   0xE000             B.N      ??CurveSignGet_19
   \                     ??CurveSignGet_20: (+1)
   \   000001EC   0x1C40             ADDS     R0,R0,#+1
   2705              {
   2706                if(row >= CameraHight) 
   \                     ??CurveSignGet_19: (+1)
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x2832             CMP      R0,#+50
   \   000001F2   0xDB0D             BLT.N    ??CurveSignGet_21
   2707                {
   2708                  CurveLineChosenL1 = MaxValUint8;
   \   000001F4   0x20FF             MOVS     R0,#+255
   \   000001F6   0x.... 0x....      LDR.W    R1,??DataTable29_10
   \   000001FA   0x7008             STRB     R0,[R1, #+0]
   2709                  CurveLineChosenL2 = MaxValUint8;
   \   000001FC   0x20FF             MOVS     R0,#+255
   \   000001FE   0x.... 0x....      LDR.W    R1,??DataTable29_11
   \   00000202   0x7008             STRB     R0,[R1, #+0]
   2710                  CurveLineChosenL3 = MaxValUint8;
   \   00000204   0x20FF             MOVS     R0,#+255
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable29_12
   \   0000020A   0x7008             STRB     R0,[R1, #+0]
   2711                  return 0;
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0xE0EF             B.N      ??CurveSignGet_3
   2712                }
   2713                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_21: (+1)
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0x2103             MOVS     R1,#+3
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable29_13
   \   00000218   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000021C   0x7809             LDRB     R1,[R1, #+0]
   \   0000021E   0x29FF             CMP      R1,#+255
   \   00000220   0xD0E4             BEQ.N    ??CurveSignGet_20
   2714                {
   2715                  CurveLineChosenL3 = row;
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable29_12
   \   00000226   0x7008             STRB     R0,[R1, #+0]
   2716                  break;
   2717                }
   2718              }      
   2719              //SABCL左黑线曲率三角形面积的求取
   2720              //SABCL = SABCGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
   2721              //               BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
   2722              //               BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
   2723              //               );
   2724              CURVEL = CurveGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
   2725                                BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
   2726                                BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
   2727                                );
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable29_12
   \   0000022C   0x7800             LDRB     R0,[R0, #+0]
   \   0000022E   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   00000232   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000234   0x9001             STR      R0,[SP, #+4]
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable29_12
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   \   0000023C   0x2103             MOVS     R1,#+3
   \   0000023E   0x.... 0x....      LDR.W    R2,??DataTable29_13
   \   00000242   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x9000             STR      R0,[SP, #+0]
   \   0000024A   0x.... 0x....      LDR.W    R0,??DataTable29_11
   \   0000024E   0x7800             LDRB     R0,[R0, #+0]
   \   00000250   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   00000254   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable29_11
   \   0000025A   0x7800             LDRB     R0,[R0, #+0]
   \   0000025C   0x2103             MOVS     R1,#+3
   \   0000025E   0x.... 0x....      LDR.W    R2,??DataTable29_13
   \   00000262   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000266   0x7802             LDRB     R2,[R0, #+0]
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable29_10
   \   0000026C   0x7800             LDRB     R0,[R0, #+0]
   \   0000026E   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   00000272   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000274   0x.... 0x....      LDR.W    R0,??DataTable29_10
   \   00000278   0x7800             LDRB     R0,[R0, #+0]
   \   0000027A   0x2403             MOVS     R4,#+3
   \   0000027C   0x.... 0x....      LDR.W    R5,??DataTable29_13
   \   00000280   0xFB04 0x5000      MLA      R0,R4,R0,R5
   \   00000284   0x7800             LDRB     R0,[R0, #+0]
   \   00000286   0x.... 0x....      BL       CurveGet
   \   0000028A   0x.... 0x....      LDR.W    R1,??DataTable29_14
   \   0000028E   0x8008             STRH     R0,[R1, #+0]
   2728              
   2729            }
   2730            
   2731            
   2732            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
   2733            if(BlackRightDone == 1)
   \                     ??CurveSignGet_11: (+1)
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable29_15
   \   00000294   0x7800             LDRB     R0,[R0, #+0]
   \   00000296   0x2801             CMP      R0,#+1
   \   00000298   0xF040 0x80A9      BNE.W    ??CurveSignGet_22
   2734            {
   2735              //3. 右黑线曲率符号求取
   2736              //曲率符号预先清零。
   2737              CurveLineChosenR1 = MaxValUint8;
   \   0000029C   0x20FF             MOVS     R0,#+255
   \   0000029E   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   000002A2   0x7008             STRB     R0,[R1, #+0]
   2738              CurveLineChosenR2 = MaxValUint8;
   \   000002A4   0x20FF             MOVS     R0,#+255
   \   000002A6   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   000002AA   0x7008             STRB     R0,[R1, #+0]
   2739              CurveLineChosenR3 = MaxValUint8;
   \   000002AC   0x20FF             MOVS     R0,#+255
   \   000002AE   0x.... 0x....      LDR.W    R1,??DataTable29_18
   \   000002B2   0x7008             STRB     R0,[R1, #+0]
   2740              
   2741              //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2742              for(row = 0; ; row++)
   \   000002B4   0x2000             MOVS     R0,#+0
   \   000002B6   0xE000             B.N      ??CurveSignGet_23
   \                     ??CurveSignGet_24: (+1)
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   2743              {
   2744                if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_23: (+1)
   \   000002BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002BC   0x2830             CMP      R0,#+48
   \   000002BE   0xDB05             BLT.N    ??CurveSignGet_25
   2745                {
   2746                  CurveLineChosenR1 = MaxValUint8;
   \   000002C0   0x20FF             MOVS     R0,#+255
   \   000002C2   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   000002C6   0x7008             STRB     R0,[R1, #+0]
   2747                  return 0;
   \   000002C8   0x2000             MOVS     R0,#+0
   \   000002CA   0xE091             B.N      ??CurveSignGet_3
   2748                }
   2749                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_25: (+1)
   \   000002CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002CE   0x2103             MOVS     R1,#+3
   \   000002D0   0x.... 0x....      LDR.W    R2,??DataTable29_19
   \   000002D4   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   000002D8   0x7809             LDRB     R1,[R1, #+0]
   \   000002DA   0x29FF             CMP      R1,#+255
   \   000002DC   0xD0EC             BEQ.N    ??CurveSignGet_24
   2750                {
   2751                  CurveLineChosenR1 = row;
   \   000002DE   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   000002E2   0x7008             STRB     R0,[R1, #+0]
   2752                  break;
   2753                }   
   2754              }
   2755              //把第1个有效值到CameraHight-1的距离分成2段。
   2756              temp = (CameraHight - 1 - row) / 2;
   \   000002E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002E6   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   000002EA   0x2102             MOVS     R1,#+2
   \   000002EC   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2757              if(temp == 0) 
   \   000002F0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002F2   0x2900             CMP      R1,#+0
   \   000002F4   0xD105             BNE.N    ??CurveSignGet_26
   2758              {
   2759                CurveLineChosenR1 = MaxValUint8;
   \   000002F6   0x20FF             MOVS     R0,#+255
   \   000002F8   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   000002FC   0x7008             STRB     R0,[R1, #+0]
   2760                return 0;
   \   000002FE   0x2000             MOVS     R0,#+0
   \   00000300   0xE076             B.N      ??CurveSignGet_3
   2761              }
   2762              
   2763              //曲率基于的行2 CurveLineChosen2
   2764              for(row = CurveLineChosenR1 + temp; ; row++)
   \                     ??CurveSignGet_26: (+1)
   \   00000302   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   00000306   0x7800             LDRB     R0,[R0, #+0]
   \   00000308   0x1808             ADDS     R0,R1,R0
   \   0000030A   0xE000             B.N      ??CurveSignGet_27
   \                     ??CurveSignGet_28: (+1)
   \   0000030C   0x1C40             ADDS     R0,R0,#+1
   2765              {
   2766                if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_27: (+1)
   \   0000030E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000310   0x2831             CMP      R0,#+49
   \   00000312   0xDB09             BLT.N    ??CurveSignGet_29
   2767                {
   2768                  CurveLineChosenR1 = MaxValUint8;
   \   00000314   0x20FF             MOVS     R0,#+255
   \   00000316   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   0000031A   0x7008             STRB     R0,[R1, #+0]
   2769                  CurveLineChosenR2 = MaxValUint8;
   \   0000031C   0x20FF             MOVS     R0,#+255
   \   0000031E   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000322   0x7008             STRB     R0,[R1, #+0]
   2770                  return 0;
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0xE063             B.N      ??CurveSignGet_3
   2771                }
   2772                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_29: (+1)
   \   00000328   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000032A   0x2203             MOVS     R2,#+3
   \   0000032C   0x.... 0x....      LDR.W    R3,??DataTable29_19
   \   00000330   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000334   0x7812             LDRB     R2,[R2, #+0]
   \   00000336   0x2AFF             CMP      R2,#+255
   \   00000338   0xD0E8             BEQ.N    ??CurveSignGet_28
   2773                {
   2774                  CurveLineChosenR2 = row;
   \   0000033A   0x.... 0x....      LDR.W    R2,??DataTable29_17
   \   0000033E   0x7010             STRB     R0,[R2, #+0]
   2775                  break;
   2776                }
   2777              }
   2778              
   2779              //曲率基于的行3 CurveLineChosen3
   2780              for(row = CurveLineChosenR2 + temp; ; row++)
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable29_17
   \   00000344   0x7800             LDRB     R0,[R0, #+0]
   \   00000346   0x1808             ADDS     R0,R1,R0
   \   00000348   0xE000             B.N      ??CurveSignGet_30
   \                     ??CurveSignGet_31: (+1)
   \   0000034A   0x1C40             ADDS     R0,R0,#+1
   2781              {
   2782                if(row >= CameraHight) 
   \                     ??CurveSignGet_30: (+1)
   \   0000034C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000034E   0x2832             CMP      R0,#+50
   \   00000350   0xDB0D             BLT.N    ??CurveSignGet_32
   2783                {
   2784                  CurveLineChosenR1 = MaxValUint8;
   \   00000352   0x20FF             MOVS     R0,#+255
   \   00000354   0x.... 0x....      LDR.W    R1,??DataTable29_16
   \   00000358   0x7008             STRB     R0,[R1, #+0]
   2785                  CurveLineChosenR2 = MaxValUint8;
   \   0000035A   0x20FF             MOVS     R0,#+255
   \   0000035C   0x.... 0x....      LDR.W    R1,??DataTable29_17
   \   00000360   0x7008             STRB     R0,[R1, #+0]
   2786                  CurveLineChosenR3 = MaxValUint8;
   \   00000362   0x20FF             MOVS     R0,#+255
   \   00000364   0x.... 0x....      LDR.W    R1,??DataTable29_18
   \   00000368   0x7008             STRB     R0,[R1, #+0]
   2787                  return 0;
   \   0000036A   0x2000             MOVS     R0,#+0
   \   0000036C   0xE040             B.N      ??CurveSignGet_3
   2788                }
   2789                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_32: (+1)
   \   0000036E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000370   0x2103             MOVS     R1,#+3
   \   00000372   0x.... 0x....      LDR.W    R2,??DataTable29_19
   \   00000376   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000037A   0x7809             LDRB     R1,[R1, #+0]
   \   0000037C   0x29FF             CMP      R1,#+255
   \   0000037E   0xD0E4             BEQ.N    ??CurveSignGet_31
   2790                {
   2791                  CurveLineChosenR3 = row;
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable29_18
   \   00000384   0x7008             STRB     R0,[R1, #+0]
   2792                  break;
   2793                }
   2794              }   
   2795              //SABCR右黑线曲率三角形面积的求取
   2796              //SABCR = SABCGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1, 
   2797              //                BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2, 
   2798              //                BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
   2799              //                );
   2800              CURVER = CurveGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1, 
   2801                                BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2, 
   2802                                BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
   2803                                );
   \   00000386   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   0000038A   0x7800             LDRB     R0,[R0, #+0]
   \   0000038C   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   00000390   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000392   0x9001             STR      R0,[SP, #+4]
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable29_18
   \   00000398   0x7800             LDRB     R0,[R0, #+0]
   \   0000039A   0x2103             MOVS     R1,#+3
   \   0000039C   0x.... 0x....      LDR.W    R2,??DataTable29_19
   \   000003A0   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000003A4   0x7800             LDRB     R0,[R0, #+0]
   \   000003A6   0x9000             STR      R0,[SP, #+0]
   \   000003A8   0x.... 0x....      LDR.W    R0,??DataTable29_17
   \   000003AC   0x7800             LDRB     R0,[R0, #+0]
   \   000003AE   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   000003B2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003B4   0x.... 0x....      LDR.W    R0,??DataTable29_17
   \   000003B8   0x7800             LDRB     R0,[R0, #+0]
   \   000003BA   0x2103             MOVS     R1,#+3
   \   000003BC   0x.... 0x....      LDR.W    R2,??DataTable29_19
   \   000003C0   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000003C4   0x7802             LDRB     R2,[R0, #+0]
   \   000003C6   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000003CA   0x7800             LDRB     R0,[R0, #+0]
   \   000003CC   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   000003D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003D2   0x.... 0x....      LDR.W    R0,??DataTable29_16
   \   000003D6   0x7800             LDRB     R0,[R0, #+0]
   \   000003D8   0x2403             MOVS     R4,#+3
   \   000003DA   0x.... 0x....      LDR.W    R5,??DataTable29_19
   \   000003DE   0xFB04 0x5000      MLA      R0,R4,R0,R5
   \   000003E2   0x7800             LDRB     R0,[R0, #+0]
   \   000003E4   0x.... 0x....      BL       CurveGet
   \   000003E8   0x.... 0x....      LDR.W    R1,??DataTable29_20
   \   000003EC   0x8008             STRH     R0,[R1, #+0]
   2804               
   2805            }
   2806            
   2807            return 1;
   \                     ??CurveSignGet_22: (+1)
   \   000003EE   0x2001             MOVS     R0,#+1
   \                     ??CurveSignGet_3: (+1)
   \   000003F0   0xBD3E             POP      {R1-R5,PC}       ;; return
   2808            
   2809          }
   2810          
   2811          
   2812          //赛道类型判断
   2813          //======================================================================
   2814          //函数名：PathJudge
   2815          //功  能：赛道类型判断
   2816          //参  数：无
   2817          //返  回：1成功 0失败
   2818          //影  响：PathType
   2819          //说  明：
   2820          //             
   2821          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2822          uint8 PathJudge(void)
   2823          {
   \                     PathJudge: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2824            //赛道类型PathType: 0未知 1直道 2左中 3右中 4左内 5左外 6右内 7右外
   2825            PathType = 0;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable29_21
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   2826            //uint8 row;
   2827            
   2828            //曲率符号获取成功
   2829            if(CurveSignGet())
   \   00000008   0x.... 0x....      BL       CurveSignGet
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x80D3      BEQ.W    ??PathJudge_0
   2830            {
   2831              //左右黑线均提取成功，的情况。
   2832              if(BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000012   0x....             LDR.N    R0,??DataTable29_9
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD14E             BNE.N    ??PathJudge_1
   \   0000001A   0x....             LDR.N    R0,??DataTable29_15
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD14A             BNE.N    ??PathJudge_1
   2833              { //全部逆时针，为左弯。而且是小车走在左弯道较为中心的情况。
   2834                if(CURVEL < 0 && CURVEC < 0 && CURVER < 0)
   \   00000022   0x....             LDR.N    R0,??DataTable29_14
   \   00000024   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD50D             BPL.N    ??PathJudge_2
   \   0000002C   0x....             LDR.N    R0,??DataTable29_8
   \   0000002E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD508             BPL.N    ??PathJudge_2
   \   00000036   0x....             LDR.N    R0,??DataTable29_20
   \   00000038   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD503             BPL.N    ??PathJudge_2
   2835                { 
   2836                  PathType = 2;
   \   00000040   0x2002             MOVS     R0,#+2
   \   00000042   0x....             LDR.N    R1,??DataTable29_21
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   \   00000046   0xE037             B.N      ??PathJudge_1
   2837                }
   2838                //全部顺时针，为右弯。而且是小车走在右弯道较为中心的情况。
   2839                else if(CURVEL > 0 && CURVEC > 0 && CURVER > 0)
   \                     ??PathJudge_2: (+1)
   \   00000048   0x....             LDR.N    R0,??DataTable29_14
   \   0000004A   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xDB0D             BLT.N    ??PathJudge_3
   \   00000052   0x....             LDR.N    R0,??DataTable29_8
   \   00000054   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDB08             BLT.N    ??PathJudge_3
   \   0000005C   0x....             LDR.N    R0,??DataTable29_20
   \   0000005E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xDB03             BLT.N    ??PathJudge_3
   2840                {        
   2841                  PathType = 3;
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x....             LDR.N    R1,??DataTable29_21
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   \   0000006C   0xE024             B.N      ??PathJudge_1
   2842                }
   2843                else
   2844                {
   2845                  if(
   2846                    (AbsSelf(CURVEL) < PathStraightLimitL)
   2847                  &&(AbsSelf(CURVEC) < PathStraightLimitC)
   2848                  &&(AbsSelf(CURVER) < PathStraightLimitR)
   2849                    )
   \                     ??PathJudge_3: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable29_14
   \   00000070   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000074   0x.... 0x....      BL       AbsSelf
   \   00000078   0x....             LDR.N    R1,??DataTable29_22
   \   0000007A   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xDA17             BGE.N    ??PathJudge_4
   \   00000082   0x....             LDR.N    R0,??DataTable29_8
   \   00000084   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       AbsSelf
   \   0000008C   0x....             LDR.N    R1,??DataTable29_23
   \   0000008E   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDA0D             BGE.N    ??PathJudge_4
   \   00000096   0x....             LDR.N    R0,??DataTable29_20
   \   00000098   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000009C   0x.... 0x....      BL       AbsSelf
   \   000000A0   0x....             LDR.N    R1,??DataTable29_24
   \   000000A2   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xDA03             BGE.N    ??PathJudge_4
   2850                  { //均小于阈值，为直道。
   2851                    PathType = 1;  
   \   000000AA   0x2001             MOVS     R0,#+1
   \   000000AC   0x....             LDR.N    R1,??DataTable29_21
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   \   000000B0   0xE002             B.N      ??PathJudge_1
   2852                  }
   2853                  else
   2854                  {
   2855                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_4: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x....             LDR.N    R1,??DataTable29_21
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
   2856                  }
   2857                }
   2858              }
   2859              
   2860              //左黑线提取失败，右黑线提取成功，的情况。
   2861              if(BlackLeftDone == 0 && BlackRightDone == 1)
   \                     ??PathJudge_1: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable29_9
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD13A             BNE.N    ??PathJudge_5
   \   000000C0   0x....             LDR.N    R0,??DataTable29_15
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD136             BNE.N    ??PathJudge_5
   2862              { //左弯道，外道。
   2863                if(CURVEC < 0 && CURVER < 0)
   \   000000C8   0x....             LDR.N    R0,??DataTable29_8
   \   000000CA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD508             BPL.N    ??PathJudge_6
   \   000000D2   0x....             LDR.N    R0,??DataTable29_20
   \   000000D4   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD503             BPL.N    ??PathJudge_6
   2864                {
   2865                  PathType = 5;
   \   000000DC   0x2005             MOVS     R0,#+5
   \   000000DE   0x....             LDR.N    R1,??DataTable29_21
   \   000000E0   0x7008             STRB     R0,[R1, #+0]
   \   000000E2   0xE028             B.N      ??PathJudge_5
   2866                }
   2867                //右弯道，内道。
   2868                else if(CURVEC > 0 && CURVER > 0)
   \                     ??PathJudge_6: (+1)
   \   000000E4   0x....             LDR.N    R0,??DataTable29_8
   \   000000E6   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xDB08             BLT.N    ??PathJudge_7
   \   000000EE   0x....             LDR.N    R0,??DataTable29_20
   \   000000F0   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xDB03             BLT.N    ??PathJudge_7
   2869                {
   2870                  PathType = 6;
   \   000000F8   0x2006             MOVS     R0,#+6
   \   000000FA   0x....             LDR.N    R1,??DataTable29_21
   \   000000FC   0x7008             STRB     R0,[R1, #+0]
   \   000000FE   0xE01A             B.N      ??PathJudge_5
   2871                }
   2872                else
   2873                {
   2874                  if(
   2875                    (AbsSelf(CURVEC) < PathStraightLimitC)
   2876                  &&(AbsSelf(CURVER) < PathStraightLimitR)
   2877                    )
   \                     ??PathJudge_7: (+1)
   \   00000100   0x....             LDR.N    R0,??DataTable29_8
   \   00000102   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000106   0x.... 0x....      BL       AbsSelf
   \   0000010A   0x....             LDR.N    R1,??DataTable29_23
   \   0000010C   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xDA0D             BGE.N    ??PathJudge_8
   \   00000114   0x....             LDR.N    R0,??DataTable29_20
   \   00000116   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000011A   0x.... 0x....      BL       AbsSelf
   \   0000011E   0x....             LDR.N    R1,??DataTable29_24
   \   00000120   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000124   0x4288             CMP      R0,R1
   \   00000126   0xDA03             BGE.N    ??PathJudge_8
   2878                  { //均小于阈值，为直道。
   2879                    PathType = 1;  
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0x....             LDR.N    R1,??DataTable29_21
   \   0000012C   0x7008             STRB     R0,[R1, #+0]
   \   0000012E   0xE002             B.N      ??PathJudge_5
   2880                  }
   2881                  else
   2882                  {
   2883                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_8: (+1)
   \   00000130   0x2000             MOVS     R0,#+0
   \   00000132   0x....             LDR.N    R1,??DataTable29_21
   \   00000134   0x7008             STRB     R0,[R1, #+0]
   2884                  }
   2885                }
   2886              }
   2887              
   2888              //右黑线提取失败，左黑线提取成功，的情况。
   2889              if(BlackLeftDone == 1 && BlackRightDone == 0)
   \                     ??PathJudge_5: (+1)
   \   00000136   0x....             LDR.N    R0,??DataTable29_9
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD13A             BNE.N    ??PathJudge_9
   \   0000013E   0x....             LDR.N    R0,??DataTable29_15
   \   00000140   0x7800             LDRB     R0,[R0, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD136             BNE.N    ??PathJudge_9
   2890              { //左弯道，内道。
   2891                if(CURVEC < 0 && CURVEL < 0)
   \   00000146   0x....             LDR.N    R0,??DataTable29_8
   \   00000148   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD508             BPL.N    ??PathJudge_10
   \   00000150   0x....             LDR.N    R0,??DataTable29_14
   \   00000152   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD503             BPL.N    ??PathJudge_10
   2892                {
   2893                  PathType = 4;
   \   0000015A   0x2004             MOVS     R0,#+4
   \   0000015C   0x....             LDR.N    R1,??DataTable29_21
   \   0000015E   0x7008             STRB     R0,[R1, #+0]
   \   00000160   0xE028             B.N      ??PathJudge_9
   2894                }
   2895                //右弯道，外道。
   2896                else if(CURVEC > 0 && CURVEL > 0)
   \                     ??PathJudge_10: (+1)
   \   00000162   0x....             LDR.N    R0,??DataTable29_8
   \   00000164   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xDB08             BLT.N    ??PathJudge_11
   \   0000016C   0x....             LDR.N    R0,??DataTable29_14
   \   0000016E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000172   0x2801             CMP      R0,#+1
   \   00000174   0xDB03             BLT.N    ??PathJudge_11
   2897                {
   2898                  PathType = 7;
   \   00000176   0x2007             MOVS     R0,#+7
   \   00000178   0x....             LDR.N    R1,??DataTable29_21
   \   0000017A   0x7008             STRB     R0,[R1, #+0]
   \   0000017C   0xE01A             B.N      ??PathJudge_9
   2899                }
   2900                else
   2901                {
   2902                  if(
   2903                    (AbsSelf(CURVEC) < PathStraightLimitC)
   2904                  &&(AbsSelf(CURVEL) < PathStraightLimitL)
   2905                    )
   \                     ??PathJudge_11: (+1)
   \   0000017E   0x....             LDR.N    R0,??DataTable29_8
   \   00000180   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000184   0x.... 0x....      BL       AbsSelf
   \   00000188   0x....             LDR.N    R1,??DataTable29_23
   \   0000018A   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xDA0D             BGE.N    ??PathJudge_12
   \   00000192   0x....             LDR.N    R0,??DataTable29_14
   \   00000194   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000198   0x.... 0x....      BL       AbsSelf
   \   0000019C   0x....             LDR.N    R1,??DataTable29_22
   \   0000019E   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   000001A2   0x4288             CMP      R0,R1
   \   000001A4   0xDA03             BGE.N    ??PathJudge_12
   2906                  { //均小于阈值，为直道。
   2907                    PathType = 1;  
   \   000001A6   0x2001             MOVS     R0,#+1
   \   000001A8   0x....             LDR.N    R1,??DataTable29_21
   \   000001AA   0x7008             STRB     R0,[R1, #+0]
   \   000001AC   0xE002             B.N      ??PathJudge_9
   2908                  }
   2909                  else
   2910                  {
   2911                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_12: (+1)
   \   000001AE   0x2000             MOVS     R0,#+0
   \   000001B0   0x....             LDR.N    R1,??DataTable29_21
   \   000001B2   0x7008             STRB     R0,[R1, #+0]
   2912                  }
   2913                }
   2914              }
   2915              
   2916              return 1;
   \                     ??PathJudge_9: (+1)
   \   000001B4   0x2001             MOVS     R0,#+1
   \   000001B6   0xE003             B.N      ??PathJudge_13
   2917            }
   2918            //曲率符号获取失败
   2919            else
   2920            {
   2921              PathType = 0;  
   \                     ??PathJudge_0: (+1)
   \   000001B8   0x2000             MOVS     R0,#+0
   \   000001BA   0x....             LDR.N    R1,??DataTable29_21
   \   000001BC   0x7008             STRB     R0,[R1, #+0]
   2922              return 0;
   \   000001BE   0x2000             MOVS     R0,#+0
   \                     ??PathJudge_13: (+1)
   \   000001C0   0xBD02             POP      {R1,PC}          ;; return
   2923            }
   2924            
   2925          }
   2926          
   2927          
   2928          
   2929          
   2930          
   2931          //======================================================================
   2932          //函数名：ImagePro
   2933          //功  能：
   2934          //参  数：无
   2935          //返  回：1成功 0失败
   2936          //影  响：
   2937          //说  明：
   2938          //             
   2939          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2940          uint8 ImagePro(void)
   2941          {
   \                     ImagePro: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   2942              uint8 i;
   2943              //图像取需要的列，重新赋值是为了后面的编程方便。
   2944              ImgPut();
   \   00000002   0x.... 0x....      BL       ImgPut
   2945            
   2946              //ImageExtract(ImgSend, ImgStore, CameraSize);  
   2947          
   2948              
   2949              //发送图像存储数组到上位机
   2950              //SendImage(ImgNew);       
   2951              //黑线提取函数
   2952              if(!BlackGet())        
   \   00000006   0x.... 0x....      BL       BlackGet
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD10D             BNE.N    ??ImagePro_0
   2953              {
   2954                  //uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
   2955                  CenterLineResult = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable29_25
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   2956                  PathType = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable29_21
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   2957                  BlackLeftHeadLine = MaxValUint8;
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x....             LDR.N    R1,??DataTable29_26
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   2958                  BlackRightHeadLine = MaxValUint8;
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x....             LDR.N    R1,??DataTable29_27
   \   00000024   0x7008             STRB     R0,[R1, #+0]
   2959                  return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE04D             B.N      ??ImagePro_1
   2960              }
   2961              else
   2962              { //黑线提取成功，找两边黑线的线头
   2963                //左线线头的查找
   2964                if(BlackLeftDone == 1)
   \                     ??ImagePro_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable29_9
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD114             BNE.N    ??ImagePro_2
   2965                {
   2966                  for(i = 0; ; i++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE000             B.N      ??ImagePro_3
   \                     ??ImagePro_4: (+1)
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   2967                  {
   2968                    if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??ImagePro_3: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x....             LDR.N    R2,??DataTable29_13
   \   0000003E   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x29FF             CMP      R1,#+255
   \   00000046   0xD002             BEQ.N    ??ImagePro_5
   2969                    {
   2970                      BlackLeftHeadLine = i;
   \   00000048   0x....             LDR.N    R1,??DataTable29_26
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   2971                      break;
   \   0000004C   0xE009             B.N      ??ImagePro_6
   2972                    }
   2973                    if(i == CameraHight - 1) 
   \                     ??ImagePro_5: (+1)
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2831             CMP      R0,#+49
   \   00000052   0xD1F0             BNE.N    ??ImagePro_4
   2974                    {
   2975                      BlackLeftHeadLine = MaxValUint8;
   \   00000054   0x20FF             MOVS     R0,#+255
   \   00000056   0x....             LDR.N    R1,??DataTable29_26
   \   00000058   0x7008             STRB     R0,[R1, #+0]
   2976                      break;
   \   0000005A   0xE002             B.N      ??ImagePro_6
   2977                    }
   2978                  }
   2979                }
   2980                else
   2981                {
   2982                  BlackLeftHeadLine = MaxValUint8;
   \                     ??ImagePro_2: (+1)
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0x....             LDR.N    R1,??DataTable29_26
   \   00000060   0x7008             STRB     R0,[R1, #+0]
   2983                }
   2984                
   2985                //右线线头的查找
   2986                if(BlackRightDone == 1)
   \                     ??ImagePro_6: (+1)
   \   00000062   0x....             LDR.N    R0,??DataTable29_15
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD114             BNE.N    ??ImagePro_7
   2987                {
   2988                  for(i = 0; ; i++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE000             B.N      ??ImagePro_8
   \                     ??ImagePro_9: (+1)
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   2989                  {
   2990                    if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??ImagePro_8: (+1)
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2103             MOVS     R1,#+3
   \   00000074   0x....             LDR.N    R2,??DataTable29_19
   \   00000076   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000007A   0x7809             LDRB     R1,[R1, #+0]
   \   0000007C   0x29FF             CMP      R1,#+255
   \   0000007E   0xD002             BEQ.N    ??ImagePro_10
   2991                    {
   2992                      BlackRightHeadLine = i;
   \   00000080   0x....             LDR.N    R1,??DataTable29_27
   \   00000082   0x7008             STRB     R0,[R1, #+0]
   2993                      break;
   \   00000084   0xE009             B.N      ??ImagePro_11
   2994                    }
   2995                    if(i == CameraHight - 1) 
   \                     ??ImagePro_10: (+1)
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2831             CMP      R0,#+49
   \   0000008A   0xD1F0             BNE.N    ??ImagePro_9
   2996                    {
   2997                      BlackRightHeadLine = MaxValUint8;
   \   0000008C   0x20FF             MOVS     R0,#+255
   \   0000008E   0x....             LDR.N    R1,??DataTable29_27
   \   00000090   0x7008             STRB     R0,[R1, #+0]
   2998                      break;
   \   00000092   0xE002             B.N      ??ImagePro_11
   2999                    }
   3000                  }
   3001                }
   3002                else
   3003                {
   3004                  BlackRightHeadLine = MaxValUint8;
   \                     ??ImagePro_7: (+1)
   \   00000094   0x20FF             MOVS     R0,#+255
   \   00000096   0x....             LDR.N    R1,??DataTable29_27
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   3005                }
   3006              }
   3007              
   3008              //中心线提取函数
   3009              CenterLineResult = 1;
   \                     ??ImagePro_11: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x....             LDR.N    R1,??DataTable29_25
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   3010              if(!CenterLineGet())
   \   000000A0   0x.... 0x....      BL       CenterLineGet
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD107             BNE.N    ??ImagePro_12
   3011              {
   3012                //uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
   3013                CenterLineResult = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x....             LDR.N    R1,??DataTable29_25
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   3014                PathType = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x....             LDR.N    R1,??DataTable29_21
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
   3015                return 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE006             B.N      ??ImagePro_1
   3016              }
   3017              else
   3018              {
   3019                //CenterLineGetCom();  
   3020              }
   3021              
   3022              //赛道类型判断
   3023              //到这里时，中心线提取成功，左右黑线至少有一个提取成功。
   3024              if(!PathJudge())
   \                     ??ImagePro_12: (+1)
   \   000000B8   0x.... 0x....      BL       PathJudge
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD101             BNE.N    ??ImagePro_13
   3025              {
   3026                //uart_sendN(UART0, (uint8 *)"\nPathJudge Failed!", 18);
   3027                return 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??ImagePro_1
   3028              }
   3029              //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
   3030              //SendCenterLineLoc(CenterLineLoc);
   3031              
   3032              //SendImage(ImgNew);  
   3033              
   3034              return 1;
   \                     ??ImagePro_13: (+1)
   \   000000C4   0x2001             MOVS     R0,#+1
   \                     ??ImagePro_1: (+1)
   \   000000C6   0xBD02             POP      {R1,PC}          ;; return
   3035          }
   3036          
   3037          

   \                                 In section .text, align 2, keep-with-next
   3038          uint8 ImageProSend(void)
   3039          {
   \                     ImageProSend: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3040              //图像取需要的列，重新赋值是为了后面的编程方便。
   3041              ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。
   3042              ImgPut();
   \   00000002   0x.... 0x....      BL       ImgPut
   3043            
   3044              //ImageExtract(ImgSend, ImgStore, CameraSize);  
   3045              /*
   3046              //黑线提取函数
   3047              if(!BlackGet())         ////////////////////////////如果黑线提取失败，这里最好给个灯来指示
   3048              {
   3049                  uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
   3050                  return 0;
   3051              }
   3052              
   3053              //中心线提取函数
   3054              CenterLineResult = 1;
   3055              if(!CenterLineGet())
   3056              {
   3057                uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
   3058                CenterLineResult = 0;
   3059                return 0;
   3060              }
   3061              
   3062              //PathJudge();
   3063          
   3064              */
   3065              //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
   3066              //SendCenterLineLoc(CenterLineLoc);
   3067              
   3068              //发送图像存储数组到上位机
   3069              SendImage(ImgNew);      
   \   00000006   0x....             LDR.N    R0,??DataTable29_1
   \   00000008   0x.... 0x....      BL       SendImage
   3070              
   3071              return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   3072          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     `?<Constant {0, 255, 1, 255}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     `?<Constant {0, 255, 1, 0}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     `?<Constant "\\nError In BlackLeftCr...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x43790001         DC32     0x43790001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xC1200000         DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x437A0000         DC32     0x437a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     BlackLeftCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     `?<Constant "\\nError In BlackRightC...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x43790001         DC32     0x43790001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0xC1200000         DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   0x437A0001         DC32     0x437a0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     BlackRightCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_1:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_2:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_3:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_4:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_5:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_6:
   \   00000000   0x........         DC32     BlackLeft3ResetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_7:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_8:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_9:
   \   00000000   0x........         DC32     BlackRight3ResetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_10:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_11:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_12:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_13:
   \   00000000   0x........         DC32     CenterLocStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25_14:
   \   00000000   0x........         DC32     CenterLineHalfWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   0x........         DC32     CenterKeyLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_1:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_2:
   \   00000000   0x........         DC32     ImgRaw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_3:
   \   00000000   0x........         DC32     CurveGetCompen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_4:
   \   00000000   0x........         DC32     CurveLineChosenC1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_5:
   \   00000000   0x........         DC32     CurveLineChosenC2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_6:
   \   00000000   0x........         DC32     CurveLineChosenC3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_7:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_8:
   \   00000000   0x........         DC32     CURVEC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_9:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_10:
   \   00000000   0x........         DC32     CurveLineChosenL1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_11:
   \   00000000   0x........         DC32     CurveLineChosenL2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_12:
   \   00000000   0x........         DC32     CurveLineChosenL3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_13:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_14:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_15:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_16:
   \   00000000   0x........         DC32     CurveLineChosenR1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_17:
   \   00000000   0x........         DC32     CurveLineChosenR2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_18:
   \   00000000   0x........         DC32     CurveLineChosenR3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_19:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_20:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_21:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_22:
   \   00000000   0x........         DC32     PathStraightLimitL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_23:
   \   00000000   0x........         DC32     PathStraightLimitC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_24:
   \   00000000   0x........         DC32     PathStraightLimitR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_25:
   \   00000000   0x........         DC32     CenterLineResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_26:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable29_27:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .rodata, align 4
   \                     `?<Constant {0, 255, 1, 255}>`:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 255
   \              0x01 0xFF    

   \                                 In section .rodata, align 4
   \                     `?<Constant {0, 255, 1, 0}>`:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 0
   \              0x01 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nError In BlackLeftCr...">`:
   \   00000000   0x0A 0x45          DC8 "\012Error In BlackLeftCrossStep3!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x42 0x6C    
   \              0x61 0x63    
   \              0x6B 0x4C    
   \              0x65 0x66    
   \              0x74 0x43    
   \              0x72 0x6F    
   \              0x73 0x73    
   \              0x53 0x74    
   \              0x65 0x70    
   \              0x33 0x21    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nError In BlackRightC...">`:
   \   00000000   0x0A 0x45          DC8 "\012Error In BlackRightCrossStep3!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x42 0x6C    
   \              0x61 0x63    
   \              0x6B 0x52    
   \              0x69 0x67    
   \              0x68 0x74    
   \              0x43 0x72    
   \              0x6F 0x73    
   \              0x73 0x53    
   \              0x74 0x65    
   \              0x70 0x33    
   \              0x21 0x00    
   3073          
   3074          
   3075          
   3076          
   3077          
   3078          
   3079          
   3080          
   3081          
   3082          
   3083          
   3084          
   3085          
   3086          
   3087          
   3088          
   3089          
   3090          
   3091          
   3092          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AbsRe
       0   AbsSelf
      16   BlackGet
        16   -> BlackGetLeft
        16   -> BlackGetRight
      40   BlackGetLeft
        40   -> BlackGetLeftStep1Scan
        40   -> BlackGetLeftStep2Win
        40   -> BlackLeftAgainForCross
        40   -> BlackLeftStep4BackLine
      24   BlackGetLeftStep1Edge
        24   -> AbsRe
        24   -> BlackLeftRealClear
      24   BlackGetLeftStep1Scan
        24   -> AbsRe
        24   -> BlackGetLeftStep1Edge
      16   BlackGetLeftStep2Win
        16   -> AbsRe
      40   BlackGetRight
        40   -> BlackGetRightStep1Scan
        40   -> BlackGetRightStep2Win
        40   -> BlackRightAgainForCross
        40   -> BlackRightStep4BackLine
      24   BlackGetRightStep1Edge
        24   -> AbsRe
        24   -> BlackRightRealClear
        24   -> MaxRe
        24   -> MinRe
      24   BlackGetRightStep1Scan
        24   -> AbsRe
        24   -> BlackGetRightStep1Edge
      16   BlackGetRightStep2Win
        16   -> AbsRe
      32   BlackLeftAgainForCross
        32   -> BlackGetLeftStep1Scan
        32   -> BlackGetLeftStep2Win
        32   -> BlackLeftCrossConfirm
        32   -> BlackLeftCrossStep3
      24   BlackLeftCrossConfirm
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> __aeabi_cfcmple
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
      32   BlackLeftCrossStep3
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_f2d
        32   -> __aeabi_f2iz
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
        32   -> uart_sendN
       0   BlackLeftRealClear
      24   BlackLeftStep4BackLine
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> __aeabi_cfcmple
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
      32   BlackRightAgainForCross
        32   -> BlackGetRightStep1Scan
        32   -> BlackGetRightStep2Win
        32   -> BlackRightCrossConfirm
        32   -> BlackRightCrossStep3
      24   BlackRightCrossConfirm
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> __aeabi_cfcmple
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
      32   BlackRightCrossStep3
        32   -> __aeabi_d2f
        32   -> __aeabi_dadd
        32   -> __aeabi_f2d
        32   -> __aeabi_f2iz
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> __aeabi_ui2f
        32   -> uart_sendN
       0   BlackRightRealClear
      24   BlackRightStep4BackLine
        24   -> LeastSquarea0
        24   -> LeastSquarea1
        24   -> __aeabi_cfcmple
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_f2iz
        24   -> __aeabi_fadd
        24   -> __aeabi_fmul
        24   -> __aeabi_ui2f
       0   BoundaryLimitRe
      24   CenterLineGet
        24   -> BoundaryLimitRe
        24   -> MinRe
       8   CenterLineGetCom
         8   -> BoundaryLimitRe
      40   CurveGet
        40   -> MathSqrt
      24   CurveSignGet
        24   -> CurveGet
       8   ImagePro
         8   -> BlackGet
         8   -> CenterLineGet
         8   -> ImgPut
         8   -> PathJudge
       8   ImageProSend
         8   -> ImgPut
         8   -> SendImage
      16   ImgPut
      32   LeastSquarea0
        32   -> __aeabi_fadd
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_ui2f
      40   LeastSquarea1
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
       0   MathSqrt
       0   MaxRe
       0   MinRe
       8   PathJudge
         8   -> AbsSelf
         8   -> CurveSignGet
       4   SABCGet
      16   SendCenterLineLoc
        16   -> uart_send1
        16   -> uart_sendN
      24   SendImage
        24   -> uart_send1
        24   -> uart_sendN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "\nError In BlackLeftCr...">
      32  ?<Constant "\nError In BlackRightC...">
       4  ?<Constant {0, 255, 1, 0}>
       4  ?<Constant {0, 255, 1, 255}>
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_10
       4  ??DataTable25_11
       4  ??DataTable25_12
       4  ??DataTable25_13
       4  ??DataTable25_14
       4  ??DataTable25_2
       4  ??DataTable25_3
       4  ??DataTable25_4
       4  ??DataTable25_5
       4  ??DataTable25_6
       4  ??DataTable25_7
       4  ??DataTable25_8
       4  ??DataTable25_9
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable29_10
       4  ??DataTable29_11
       4  ??DataTable29_12
       4  ??DataTable29_13
       4  ??DataTable29_14
       4  ??DataTable29_15
       4  ??DataTable29_16
       4  ??DataTable29_17
       4  ??DataTable29_18
       4  ??DataTable29_19
       4  ??DataTable29_2
       4  ??DataTable29_20
       4  ??DataTable29_21
       4  ??DataTable29_22
       4  ??DataTable29_23
       4  ??DataTable29_24
       4  ??DataTable29_25
       4  ??DataTable29_26
       4  ??DataTable29_27
       4  ??DataTable29_3
       4  ??DataTable29_4
       4  ??DataTable29_5
       4  ??DataTable29_6
       4  ??DataTable29_7
       4  ??DataTable29_8
       4  ??DataTable29_9
      20  AbsRe
      18  AbsSelf
     240  BlackGet
     674  BlackGetLeft
     744  BlackGetLeftStep1Edge
     264  BlackGetLeftStep1Scan
     426  BlackGetLeftStep2Win
     674  BlackGetRight
     794  BlackGetRightStep1Edge
     264  BlackGetRightStep1Scan
     402  BlackGetRightStep2Win
       1  BlackLeft3ResetCount
     316  BlackLeftAgainForCross
     244  BlackLeftCrossConfirm
       1  BlackLeftCrossDone
     364  BlackLeftCrossStep3
       1  BlackLeftCrossTooLowLine
       1  BlackLeftDone
       1  BlackLeftHeadLine
     152  BlackLeftLoc
       2  BlackLeftRealB
      50  BlackLeftRealClear
       2  BlackLeftRealW
       2  BlackLeftRealWB
     250  BlackLeftStep4BackLine
       1  BlackRight3ResetCount
     316  BlackRightAgainForCross
     244  BlackRightCrossConfirm
       1  BlackRightCrossDone
     366  BlackRightCrossStep3
       1  BlackRightCrossTooLowLine
       1  BlackRightDone
       1  BlackRightHeadLine
     152  BlackRightLoc
       2  BlackRightRealB
      50  BlackRightRealClear
       2  BlackRightRealW
       2  BlackRightRealWB
     250  BlackRightStep4BackLine
      40  BoundaryLimitRe
       2  CURVEC
       2  CURVEL
       2  CURVER
       1  CenterKeyLine
    2238  CenterLineGet
      94  CenterLineGetCom
      52  CenterLineHalfWidth
      52  CenterLineHalfWidth02
      52  CenterLineLoc
       1  CenterLineResult
       1  CenterLocStore
     356  CurveGet
       2  CurveGetCompen
       1  CurveLineChosenC1
       1  CurveLineChosenC2
       1  CurveLineChosenC3
       1  CurveLineChosenL1
       1  CurveLineChosenL2
       1  CurveLineChosenL3
       1  CurveLineChosenR1
       1  CurveLineChosenR2
       1  CurveLineChosenR3
    1010  CurveSignGet
       1  ErrorGetCen
       1  ErrorGetSelf
     200  ImagePro
      16  ImageProSend
   12500  ImgNew
      76  ImgPut
     136  LeastSquarea0
     248  LeastSquarea1
       1  LimitLeftB
       1  LimitLeftW
       1  LimitLeftWB
       1  LimitRightB
       1  LimitRightW
       1  LimitRightWB
      46  MathSqrt
      18  MaxRe
      18  MinRe
     450  PathJudge
       2  PathStraightLimitC
       2  PathStraightLimitL
       2  PathStraightLimitR
       1  PathType
       2  SABCC
      46  SABCGet
       2  SABCL
       2  SABCR
      52  SendCenterLineLoc
      74  SendImage

 
 12 896 bytes in section .bss
     23 bytes in section .data
    176 bytes in section .rodata
 12 416 bytes in section .text
 
 12 416 bytes of CODE  memory
    176 bytes of CONST memory
 12 919 bytes of DATA  memory

Errors: none
Warnings: none
