###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     06/Dec/2014  16:42:33 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C\ #
#                    ImagePro.c                                               #
#    Command line =  "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C #
#                    \ImagePro.c" -D IAR -D TWR_K60N512 -lCN                  #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\" -lB       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\" -o        #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\Obj\" --no_cse   #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.3\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\" -I       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\Component_ #
#                    H\" -I "D:\IAR_TEST\Sirius\Sirius                        #
#                    V2.3\src\Sources\H\Frame_H\" -I                          #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\Function_H #
#                    \" -I "D:\IAR_TEST\Sirius\Sirius                         #
#                    V2.3\src\Sources\H\SD_H\" -Ol --use_c++_inline           #
#    List file    =  D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\ImagePro.lst #
#    Object file  =  D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\Obj\ImagePro.o    #
#                                                                             #
#                                                                             #
###############################################################################

D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C\ImagePro.c
      1          /******************************************************************************/
      2          /*******************************************************************************
      3            文件名：图像处理程序文件ImagePro.c
      4            功  能：图像处理
      5            日  期：2014.10.09
      6            作  者：HJZ
      7            备  注：
      8          *******************************************************************************/
      9          /******************************************************************************/
     10          
     11          #include "ImagePro.h"
     12          
     13          //中心线提取时，实际赛道宽度的一半对应的像素点数。是固定角度后测得的值。

   \                                 In section .rodata, align 4
     14          uint8 const CenterLineHalfWidth[CameraHight] =  
   \                     CenterLineHalfWidth:
   \   00000000   0x1A 0x1B          DC8 26, 27, 28, 30, 31, 33, 34, 36, 37, 38, 40, 41, 43, 44, 46, 47, 48
   \              0x1C 0x1E    
   \              0x1F 0x21    
   \              0x22 0x24    
   \              0x25 0x26    
   \              0x28 0x29    
   \              0x2B 0x2C    
   \              0x2E 0x2F    
   \              0x30         
   \   00000011   0x31 0x33          DC8 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x39 0x3A    
   \              0x3B 0x3C    
   \              0x3D 0x3E    
   \              0x3F 0x41    
   \              0x42 0x43    
   \              0x44         
   \   00000022   0x45 0x46          DC8 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84
   \              0x47 0x48    
   \              0x49 0x4A    
   \              0x4B 0x4C    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x54    
   \   00000032   0x00 0x00          DC8 0, 0
     15          {
     16          26,27,28,30,31,33,34,36,37,38,40,41,43,44,46,47,48,49,51,52,53,54,55,57,58,
     17          59,60,61,62,63,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84
     18          };
     19          

   \                                 In section .rodata, align 4
     20          uint8 const CenterLineHalfWidth02[CameraHight] =  
   \                     CenterLineHalfWidth02:
   \   00000000   0x2E 0x2F          DC8 46, 47, 48, 50, 51, 53, 54, 56, 57, 58, 60, 61, 63, 64, 66, 67, 68
   \              0x30 0x32    
   \              0x33 0x35    
   \              0x36 0x38    
   \              0x39 0x3A    
   \              0x3C 0x3D    
   \              0x3F 0x40    
   \              0x42 0x43    
   \              0x44         
   \   00000011   0x45 0x47          DC8 69, 71, 72, 73, 74, 75, 77, 78, 79, 80, 81, 82, 83, 85, 86, 87, 88
   \              0x48 0x49    
   \              0x4A 0x4B    
   \              0x4D 0x4E    
   \              0x4F 0x50    
   \              0x51 0x52    
   \              0x53 0x55    
   \              0x56 0x57    
   \              0x58         
   \   00000022   0x59 0x5A          DC8 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104
   \              0x5B 0x5C    
   \              0x5D 0x5E    
   \              0x5F 0x60    
   \              0x61 0x62    
   \              0x63 0x64    
   \              0x65 0x66    
   \              0x67 0x68    
   \   00000032   0x00 0x00          DC8 0, 0
     21          {
     22          46,47,48,50,51,53,54,56,57,58,60,61,63,64,66,67,68,69,71,72,73,74,75,77,78,
     23          79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104
     24          };
     25          

   \                                 In section .bss, align 4
     26          uint8 ImgNew[CameraHight][CameraRealWidth];       //重新处理后的数据储存数组
   \                     ImgNew:
   \   00000000                      DS8 12500

   \                                 In section .bss, align 4
     27          uint8 BlackLeftLoc[CameraHight][3];       //左黑线位置存储数组,每行3个可疑点， 255为无效值
   \                     BlackLeftLoc:
   \   00000000                      DS8 152

   \                                 In section .bss, align 4
     28          uint8 BlackRightLoc[CameraHight][3];      //右黑线位置存储数组,每行3个可疑点， 255为无效值
   \                     BlackRightLoc:
   \   00000000                      DS8 152

   \                                 In section .bss, align 4
     29          uint8 CenterLineLoc[CameraHight];      //中心线位置存储数组, 255为无效值
   \                     CenterLineLoc:
   \   00000000                      DS8 52
     30          //uint8 MaxValUint8 = 255;             //自定义的无效值

   \                                 In section .data, align 1
     31          uint8 CenterLineResult = 1;             //中心线提取成功标志
   \                     CenterLineResult:
   \   00000000   0x01               DC8 1

   \                                 In section .data, align 1
     32          uint8 CenterKeyLine = 25;                  //固定的要选取的行。
   \                     CenterKeyLine:
   \   00000000   0x19               DC8 25

   \                                 In section .data, align 1
     33          uint8 CenterLocStore = MaxValUint8;         //左右黑线都提取到的时候，保存的CenterLineLoc[CameraHight - 1]。
   \                     CenterLocStore:
   \   00000000   0xFF               DC8 255
     34          

   \                                 In section .bss, align 1
     35          uint8 PathType = 0;                       //0未知 1直道 2左中 3右中 4左内 5左外 6右内 7右外
   \                     PathType:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     36          uint8 CurveLineChosenC1 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     37          uint8 CurveLineChosenC2 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     38          uint8 CurveLineChosenC3 = 0;               //曲率求取时，中心线选取的第1行。
   \                     CurveLineChosenC3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     39          uint8 CurveLineChosenL1 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     40          uint8 CurveLineChosenL2 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     41          uint8 CurveLineChosenL3 = 0;               //曲率求取时，左黑线选取的第1行。
   \                     CurveLineChosenL3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     42          uint8 CurveLineChosenR1 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     43          uint8 CurveLineChosenR2 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     44          uint8 CurveLineChosenR3 = 0;               //曲率求取时，右黑线选取的第1行。
   \                     CurveLineChosenR3:
   \   00000000                      DS8 1

   \                                 In section .bss, align 2
     45          int16 SABCL = 0;                          //曲率求取时，左黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     46          int16 SABCC = 0;                          //曲率求取时，中心线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     47          int16 SABCR = 0;                          //曲率求取时，右黑线曲率三角形的面积，顺时针为负，逆时针为正。
   \                     SABCR:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     48          int16 CURVEL = 0;                          //曲率求取时，左黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEL:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     49          int16 CURVEC = 0;                          //曲率求取时，中心线的曲率，顺时钟为负，逆时针为正。
   \                     CURVEC:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     50          int16 CURVER = 0;                          //曲率求取时，右黑线的曲率，顺时钟为负，逆时针为正。
   \                     CURVER:
   \   00000000                      DS8 2

   \                                 In section .data, align 2
     51          int16 PathStraightLimitL = 20;           //赛道类型判断时，左黑线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitL:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     52          int16 PathStraightLimitC = 20;           //赛道类型判断时，中心线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitC:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     53          int16 PathStraightLimitR = 20;           //赛道类型判断时，右黑线判断为直线的阈值，这里乱写的，需要用C#测定。
   \                     PathStraightLimitR:
   \   00000000   0x0014             DC16 20

   \                                 In section .data, align 2
     54          int16 CurveGetCompen = 2000;             //曲率求取时，为了不使数太小，乘的补偿量。
   \                     CurveGetCompen:
   \   00000000   0x07D0             DC16 2000
     55          

   \                                 In section .bss, align 1
     56          uint8 ErrorGetSelf;                 //平均值与自身的偏差，也就是curve
   \                     ErrorGetSelf:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     57          uint8 ErrorGetCen;                 //平均值与物理中心线的偏差。
   \                     ErrorGetCen:
   \   00000000                      DS8 1
     58          
     59          //左

   \                                 In section .bss, align 2
     60          uint8 BlackLeftRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitLeftWB
   \                     BlackLeftRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     61          uint8 BlackLeftRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitLeftB
   \                     BlackLeftRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     62          uint8 BlackLeftRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitLeftW
   \                     BlackLeftRealW:
   \   00000000                      DS8 2
     63          //右

   \                                 In section .bss, align 2
     64          uint8 BlackRightRealWB[2];                  //黑线的实际黑白差值的存储数组，用于计算实际黑白差值的阈值。替代LimitRightWB
   \                     BlackRightRealWB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     65          uint8 BlackRightRealB[2];                   //黑线的实际黑点值存储数组，用于计算实际黑点阈值。替代LimitRightB
   \                     BlackRightRealB:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     66          uint8 BlackRightRealW[2];                   //黑线的实际白点值存储数组，用于计算实际白点阈值。替代LimitRightW
   \                     BlackRightRealW:
   \   00000000                      DS8 2
     67          
     68          
     69          //左
     70          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .data, align 1
     71          uint8 LimitLeftWB = LimitOriLeftWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitLeftWB:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
     72          uint8 LimitLeftW = LimitOriLeftW;      //白点必须要大于此值
   \                     LimitLeftW:
   \   00000000   0x96               DC8 150

   \                                 In section .data, align 1
     73          uint8 LimitLeftB = LimitOriLeftB;      //黑点必须要小于此值
   \                     LimitLeftB:
   \   00000000   0x50               DC8 80
     74          

   \                                 In section .bss, align 1
     75          uint8 BlackLeftCrossDone = 0;    //左黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackLeftCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     76          uint8 BlackLeftDone = 1;          //左黑线提取成功标示位 1成功 0失败
   \                     BlackLeftDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
     77          uint8 BlackLeft3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackLeft3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     78          uint8 BlackLeftCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackLeftCrossTooLowLine:
   \   00000000   0x03               DC8 3
     79          //uint8 BlackLeftStep4Flag = 0;          //左黑线需要执行第4阶段的标志位，1需执行，0不需执行。
     80          //uint8 BlackLeftStep4StartLine = 0;     //左黑线第4阶段起始行

   \                                 In section .data, align 1
     81          uint8 BlackLeftHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
   \                     BlackLeftHeadLine:
   \   00000000   0xFF               DC8 255
     82          
     83          //右
     84          //3个关键值的可改值，可由自适应性算法更改。

   \                                 In section .data, align 1
     85          uint8 LimitRightWB = LimitOriRightWB;    //黑白像素点的差值，两个点的差必须要大于这个值，才能认为有跳变。
   \                     LimitRightWB:
   \   00000000   0x50               DC8 80

   \                                 In section .data, align 1
     86          uint8 LimitRightW = LimitOriRightW;      //白点必须要大于此值
   \                     LimitRightW:
   \   00000000   0x96               DC8 150

   \                                 In section .data, align 1
     87          uint8 LimitRightB = LimitOriRightB;      //黑点必须要小于此值
   \                     LimitRightB:
   \   00000000   0x50               DC8 80
     88          

   \                                 In section .bss, align 1
     89          uint8 BlackRightCrossDone = 0;   //右黑线十字检测标志位 0未进入 1失败 2成功
   \                     BlackRightCrossDone:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     90          uint8 BlackRightDone = 1;          //右黑线提取成功标示位 1成功 0失败
   \                     BlackRightDone:
   \   00000000   0x01               DC8 1

   \                                 In section .bss, align 1
     91          uint8 BlackRight3ResetCount = 0;       //由于光线变化太大引起的3个关键值重置的次数。
   \                     BlackRight3ResetCount:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     92          uint8 BlackRightCrossTooLowLine = 3;    //十字再检测时，低于该行就没必要启动再检测程序了。
   \                     BlackRightCrossTooLowLine:
   \   00000000   0x03               DC8 3
     93          //uint8 BlackRightStep4Flag = 0;          //右黑线需要执行第4阶段的标志位，1需执行，0不需执行。
     94          //uint8 BlackRightStep4StartLine = 0;     //右黑线第4阶段起始行

   \                                 In section .data, align 1
     95          uint8 BlackRightHeadLine = MaxValUint8;   //左黑线的线头，从上往下。
   \                     BlackRightHeadLine:
   \   00000000   0xFF               DC8 255
     96          
     97          
     98          
     99          //自身绝对值求值，只适合于int16型变量，返回int16型变量。

   \                                 In section .text, align 2, keep-with-next
    100          int16 AbsSelf(int16 x)
    101          {
    102            if(x < 0) return (0-x);
   \                     AbsSelf:
   \   00000000   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD503             BPL.N    ??AbsSelf_0
   \   00000006   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000008   0x4240             RSBS     R0,R0,#+0
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xE000             B.N      ??AbsSelf_1
    103            else return x;  
   \                     ??AbsSelf_0:
   \   0000000E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??AbsSelf_1:
   \   00000010   0x4770             BX       LR               ;; return
    104          }
    105          
    106          
    107          //======================================================================
    108          //函数名：MaxRe
    109          //功  能：求取两数最大值
    110          //参  数：第1个数num1, 第2个数num2。
    111          //返  回：2个数中的最大值
    112          //影  响：无
    113          //说  明：1. 两个输入参数无先后顺序。
    114          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    115          //        3. 返回值的类型也是uint8.
    116          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    117          uint8 MaxRe(uint8 num1, uint8 num2)
    118          {
    119            if(num1 >= num2)
   \                     MaxRe:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD301             BCC.N    ??MaxRe_0
    120            {
    121              return num1;
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE001             B.N      ??MaxRe_1
    122            }
    123            else
    124            {
    125              return num2;
   \                     ??MaxRe_0:
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MaxRe_1:
   \   00000010   0x4770             BX       LR               ;; return
    126            }
    127          }
    128          
    129          //======================================================================
    130          //函数名：MinRe
    131          //功  能：求取两数最小值
    132          //参  数：第1个数num1, 第2个数num2。
    133          //返  回：2个数中的最小值
    134          //影  响：无
    135          //说  明：1. 两个输入参数无先后顺序。
    136          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    137          //        3. 返回值的类型也是uint8.     
    138          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    139          uint8 MinRe(uint8 num1, uint8 num2)
    140          {
    141            if(num1 <= num2)
   \                     MinRe:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x4281             CMP      R1,R0
   \   00000006   0xD301             BCC.N    ??MinRe_0
    142            {
    143              return num1;  
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0xE001             B.N      ??MinRe_1
    144            }
    145            else
    146            {
    147              return num2;  
   \                     ??MinRe_0:
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??MinRe_1:
   \   00000010   0x4770             BX       LR               ;; return
    148            }
    149          }
    150          
    151          //======================================================================
    152          //函数名：AbsRe
    153          //功  能：求取两数差值的绝对值
    154          //参  数：第1个数num1, 第2个数num2。
    155          //返  回：2个数的绝对值。
    156          //影  响：无
    157          //说  明：1. 两个输入参数无先后顺序。
    158          //        2. 只能处理两个uint8型的数据，其它数据类型会出错。
    159          //        3. 返回值的类型也是uint8.     
    160          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    161          uint8 AbsRe(uint8 num1, uint8 num2)
    162          {
    163            if(num1 >= num2)
   \                     AbsRe:
   \   00000000   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000002   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD302             BCC.N    ??AbsRe_0
    164            {
    165              return (num1 - num2);  
   \   00000008   0x1A40             SUBS     R0,R0,R1
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0xE001             B.N      ??AbsRe_1
    166            }
    167            else
    168            {
    169              return (num2 - num1);  
   \                     ??AbsRe_0:
   \   0000000E   0x1A08             SUBS     R0,R1,R0
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??AbsRe_1:
   \   00000012   0x4770             BX       LR               ;; return
    170            }
    171          }
    172          
    173          
    174          //======================================================================
    175          //函数名：LeastSquarea1
    176          //功  能：最小二乘法的a1值的求取
    177          //参  数：x数组，y数组，num基于的有效数据个数
    178          //返  回：a1
    179          //影  响：无
    180          //说  明：1. y = a0 + a1 * x;
    181          //        2. a1 = (N * Σxy - Σx * Σy) / (N * Σx^2 - Σx * Σx);
    182          //        ////////////////////////////////////////////////////////////////////可以考虑把所有有float型的地方乘以1000改成int     
    183          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    184          float LeastSquarea1(uint8 x[], uint8 y[], uint8 num)
    185          {
   \                     LeastSquarea1:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x0007             MOVS     R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x0014             MOVS     R4,R2
    186            float andxy = 0, andx = 0, andy = 0, andx2 = 0;
   \   0000000A   0xF05F 0x0900      MOVS     R9,#+0
   \   0000000E   0x2500             MOVS     R5,#+0
   \   00000010   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000014   0x2600             MOVS     R6,#+0
    187            float a1;
    188            uint8 i;
    189           
    190            for(i = 0; i < num; i++)
   \   00000016   0xF05F 0x0B00      MOVS     R11,#+0
   \   0000001A   0xE033             B.N      ??LeastSquarea1_0
    191            {
    192              andxy += x[i] * y[i];
   \                     ??LeastSquarea1_1:
   \   0000001C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000020   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   00000024   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000028   0xF81B 0x1008      LDRB     R1,[R11, R8]
   \   0000002C   0x4348             MULS     R0,R1,R0
   \   0000002E   0x.... 0x....      BL       __aeabi_i2f
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4681             MOV      R9,R0
    193              andx += x[i];
   \   0000003A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000003E   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   00000042   0x.... 0x....      BL       __aeabi_ui2f
   \   00000046   0x0029             MOVS     R1,R5
   \   00000048   0x.... 0x....      BL       __aeabi_fadd
   \   0000004C   0x0005             MOVS     R5,R0
    194              andy += y[i];
   \   0000004E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000052   0xF81B 0x0008      LDRB     R0,[R11, R8]
   \   00000056   0x.... 0x....      BL       __aeabi_ui2f
   \   0000005A   0x4651             MOV      R1,R10
   \   0000005C   0x.... 0x....      BL       __aeabi_fadd
   \   00000060   0x4682             MOV      R10,R0
    195              andx2 += x[i] * x[i];
   \   00000062   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000066   0xF81B 0x0007      LDRB     R0,[R11, R7]
   \   0000006A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000006E   0xF81B 0x1007      LDRB     R1,[R11, R7]
   \   00000072   0x4348             MULS     R0,R1,R0
   \   00000074   0x.... 0x....      BL       __aeabi_i2f
   \   00000078   0x0031             MOVS     R1,R6
   \   0000007A   0x.... 0x....      BL       __aeabi_fadd
   \   0000007E   0x0006             MOVS     R6,R0
    196            }
   \   00000080   0xF11B 0x0B01      ADDS     R11,R11,#+1
   \                     ??LeastSquarea1_0:
   \   00000084   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000088   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008A   0x45A3             CMP      R11,R4
   \   0000008C   0xD3C6             BCC.N    ??LeastSquarea1_1
    197            
    198            a1 = (num * andxy - andx * andy) * 1.0 / (num * andx2 - andx * andx);
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       __aeabi_ui2f
   \   00000096   0x4649             MOV      R1,R9
   \   00000098   0x.... 0x....      BL       __aeabi_fmul
   \   0000009C   0x0007             MOVS     R7,R0
   \   0000009E   0x0028             MOVS     R0,R5
   \   000000A0   0x4651             MOV      R1,R10
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x0001             MOVS     R1,R0
   \   000000A8   0x0038             MOVS     R0,R7
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x.... 0x....      BL       __aeabi_f2d
   \   000000B2   0x2200             MOVS     R2,#+0
   \   000000B4   0x.... 0x....      LDR.W    R3,??DataTable10  ;; 0x3ff00000
   \   000000B8   0x.... 0x....      BL       __aeabi_dmul
   \   000000BC   0x4680             MOV      R8,R0
   \   000000BE   0x4689             MOV      R9,R1
   \   000000C0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C2   0x0020             MOVS     R0,R4
   \   000000C4   0x.... 0x....      BL       __aeabi_ui2f
   \   000000C8   0x0031             MOVS     R1,R6
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x0004             MOVS     R4,R0
   \   000000D0   0x0028             MOVS     R0,R5
   \   000000D2   0x0029             MOVS     R1,R5
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x0001             MOVS     R1,R0
   \   000000DA   0x0020             MOVS     R0,R4
   \   000000DC   0x.... 0x....      BL       __aeabi_fsub
   \   000000E0   0x.... 0x....      BL       __aeabi_f2d
   \   000000E4   0x0002             MOVS     R2,R0
   \   000000E6   0x000B             MOVS     R3,R1
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x4649             MOV      R1,R9
   \   000000EC   0x.... 0x....      BL       __aeabi_ddiv
   \   000000F0   0x.... 0x....      BL       __aeabi_d2f
    199            return a1;  
   \   000000F4   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    200          }
    201          
    202          
    203          //======================================================================
    204          //函数名：LeastSquarea0
    205          //功  能：最小二乘法的a0值的求取
    206          //参  数：x数组，y数组，a1参数，num基于的有效数据个数
    207          //返  回：a0
    208          //影  响：无
    209          //说  明：1. y = a0 + a1 * x;
    210          //        2. a0 = Σy / N - a1 * Σx / N;
    211          //             
    212          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    213          float LeastSquarea0(uint8 x[], uint8 y[], float a1, uint8 num)
    214          {
   \                     LeastSquarea0:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0017             MOVS     R7,R2
   \   0000000A   0x001C             MOVS     R4,R3
    215            float andx = 0, andy = 0;
   \   0000000C   0xF05F 0x0800      MOVS     R8,#+0
   \   00000010   0xF05F 0x0900      MOVS     R9,#+0
    216            float a0;
    217            uint8 i;
    218            for(i = 0; i < num; i++)
   \   00000014   0xF05F 0x0A00      MOVS     R10,#+0
   \   00000018   0xE015             B.N      ??LeastSquarea0_0
    219            {
    220              andx += x[i];
   \                     ??LeastSquarea0_1:
   \   0000001A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000001E   0xF81A 0x0005      LDRB     R0,[R10, R5]
   \   00000022   0x.... 0x....      BL       __aeabi_ui2f
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fadd
   \   0000002C   0x4680             MOV      R8,R0
    221              andy += y[i];
   \   0000002E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000032   0xF81A 0x0006      LDRB     R0,[R10, R6]
   \   00000036   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003A   0x4649             MOV      R1,R9
   \   0000003C   0x.... 0x....      BL       __aeabi_fadd
   \   00000040   0x4681             MOV      R9,R0
    222            }
   \   00000042   0xF11A 0x0A01      ADDS     R10,R10,#+1
   \                     ??LeastSquarea0_0:
   \   00000046   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x45A2             CMP      R10,R4
   \   0000004E   0xD3E4             BCC.N    ??LeastSquarea0_1
    223            
    224            a0 = andy / num - a1 * andx / num;
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0x.... 0x....      BL       __aeabi_ui2f
   \   00000058   0x0001             MOVS     R1,R0
   \   0000005A   0x4648             MOV      R0,R9
   \   0000005C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000060   0x0005             MOVS     R5,R0
   \   00000062   0x0038             MOVS     R0,R7
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x0006             MOVS     R6,R0
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x0020             MOVS     R0,R4
   \   00000070   0x.... 0x....      BL       __aeabi_ui2f
   \   00000074   0x0001             MOVS     R1,R0
   \   00000076   0x0030             MOVS     R0,R6
   \   00000078   0x.... 0x....      BL       __aeabi_fdiv
   \   0000007C   0x0001             MOVS     R1,R0
   \   0000007E   0x0028             MOVS     R0,R5
   \   00000080   0x.... 0x....      BL       __aeabi_fsub
    225            return a0;
   \   00000084   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    226          }
    227          
    228          
    229          
    230          
    231          /*
    232          //二值化图像解压函数
    233          //dst             图像解压目的地址
    234          //src             图像解压源地址
    235          //srclen          二值化图像的占用空间大小
    236          void ImageExtract(uint8 *dst, uint8 *src, uint32 srclen)
    237          {
    238              uint8 colour[2] = {255, 0}; //0 和 1 分别对应的颜色
    239              //注：山外的摄像头 0 表示 白色，1表示 黑色
    240              uint8 tmpsrc;
    241              while(srclen --)
    242              {
    243                  tmpsrc = *src++;
    244                  *dst++ = colour[ (tmpsrc >> 7 ) & 0x01 ];
    245                  *dst++ = colour[ (tmpsrc >> 6 ) & 0x01 ];
    246                  *dst++ = colour[ (tmpsrc >> 5 ) & 0x01 ];
    247                  *dst++ = colour[ (tmpsrc >> 4 ) & 0x01 ];
    248                  *dst++ = colour[ (tmpsrc >> 3 ) & 0x01 ];
    249                  *dst++ = colour[ (tmpsrc >> 2 ) & 0x01 ];
    250                  *dst++ = colour[ (tmpsrc >> 1 ) & 0x01 ];
    251                  *dst++ = colour[ (tmpsrc >> 0 ) & 0x01 ];
    252              }
    253          }
    254          
    255          
    256          */
    257          
    258          /*          //OV7725的图像发送函数
    259          //图像发送到上位机
    260          void SendImage(uint8 *imgaddr, uint32 imgsize)
    261          {                                                                                   
    262              uint8 cmd[4] = {0, 255, 1, 0 };    //yy_摄像头串口调试 使用的命令
    263          
    264              //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
    265            
    266              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
    267          
    268              uart_sendN(UART0, imgaddr, imgsize); //再发送图像
    269          }
    270          
    271          */
    272          
    273          //======================================================================
    274          //函数名：SendCenterLineLoc
    275          //功  能：中心线数组发送函数
    276          //参  数：img待发送的一维图像数组
    277          //返  回：无
    278          //影  响：无
    279          //说  明：1. 这里的命令头和图像数组发送函数的命令头不一样。
    280          //      
    281          //          
    282          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    283          void SendCenterLineLoc(uint8 img[CameraHight])
    284          {
   \                     SendCenterLineLoc:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    285              uint8 i;
    286              uint8 cmd[4] = {0, 255, 1, 255 };   //中心线数组的数据头
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable10_1
   \   0000000A   0x680A             LDR      R2,[R1, #0]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
    287              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
   \   0000000E   0x2204             MOVS     R2,#+4
   \   00000010   0xA900             ADD      R1,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000016   0x.... 0x....      BL       uart_sendN
    288              for(i = 0; i < CameraHight; i++)
   \   0000001A   0x2500             MOVS     R5,#+0
   \   0000001C   0xE006             B.N      ??SendCenterLineLoc_0
    289              {
    290                uart_send1(UART0, img[i]); //发送中心线数组
   \                     ??SendCenterLineLoc_1:
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x5D29             LDRB     R1,[R5, R4]
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000026   0x.... 0x....      BL       uart_send1
    291              }
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendCenterLineLoc_0:
   \   0000002C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002E   0x2D32             CMP      R5,#+50
   \   00000030   0xD3F5             BCC.N    ??SendCenterLineLoc_1
    292              
    293          }
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    294          
    295          
    296          
    297          
    298          //======================================================================
    299          //函数名：SendImage
    300          //功  能：OV7620的图像发送函数
    301          //参  数：待发送的二维图像数组imgaddr
    302          //返  回：无
    303          //影  响：无
    304          //说  明：1. 修改图像数组大小时需要把内部两个for的内容也改掉
    305          //        2. 这里的命令头与中心线数组发送函数的命令头不一样。
    306          //          
    307          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    308          void SendImage(uint8 imgaddr[CameraHight][CameraRealWidth])
    309          {                            
   \                     SendImage:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    310              uint8 i, j;
    311              uint8 cmd[4] = {0, 255, 1, 0 };    //图像数组的数据头
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    312          
    313              //uint8 cmd[1] = {255};       //DEMOK上位机使用的命令   
    314            
    315              uart_sendN(UART0, cmd, sizeof(cmd));    //先发送命令
   \   00000010   0x2204             MOVS     R2,#+4
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000018   0x.... 0x....      BL       uart_sendN
    316              
    317              //这里不能用uart_sendN(UART0, imgaddr, CameraSize)来代替，因为uart_sendN函数里的buff[i].
    318              for(i = 0; i < CameraHight; i++)
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0xE00E             B.N      ??SendImage_0
    319                  for(j = 0; j < CameraRealWidth; j++)
    320                      uart_send1(UART0, imgaddr[i][j]); //发送图像
   \                     ??SendImage_1:
   \   00000020   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x20FA             MOVS     R0,#+250
   \   00000026   0xFB00 0x4005      MLA      R0,R0,R5,R4
   \   0000002A   0x5C31             LDRB     R1,[R6, R0]
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   00000030   0x.... 0x....      BL       uart_send1
   \   00000034   0x1C76             ADDS     R6,R6,#+1
   \                     ??SendImage_2:
   \   00000036   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000038   0x2EFA             CMP      R6,#+250
   \   0000003A   0xD3F1             BCC.N    ??SendImage_1
   \   0000003C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??SendImage_0:
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2D32             CMP      R5,#+50
   \   00000042   0xD201             BCS.N    ??SendImage_3
   \   00000044   0x2600             MOVS     R6,#+0
   \   00000046   0xE7F6             B.N      ??SendImage_2
    321          }
   \                     ??SendImage_3:
   \   00000048   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    322          
    323          
    324          
    325          //====================================左左左左左左左左左左左左左左左左左============================
    326          
    327          //======================================================================
    328          //函数名：BlackLeftRealClear
    329          //功  能：左黑线提取中，对3个关键值的实际值清零
    330          //参  数：无
    331          //返  回：无
    332          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
    333          //说  明：
    334          //      
    335          //             
    336          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    337          void BlackLeftRealClear(void)
    338          {
    339              BlackLeftRealWB[0] = 0;
   \                     BlackLeftRealClear:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
    340              BlackLeftRealWB[1] = 0;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
    341              BlackLeftRealW[0] = 0;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
    342              BlackLeftRealW[1] = 0;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7041             STRB     R1,[R0, #+1]
    343              BlackLeftRealB[0] = 0;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    344              BlackLeftRealB[1] = 0;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
    345          }
   \   00000030   0x4770             BX       LR               ;; return
    346          
    347          
    348          
    349          
    350          //======================================================================
    351          //函数名：BlackGetLeftStep1Edge
    352          //功  能：左黑线提取中，第1阶段跳变检测函数,处理该行左线的可疑黑点
    353          //参  数：待检测的行号row, 第几次使用use, 是否为十字再检测调用标志位CrossFlag
    354          //返  回：1成功 0失败
    355          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[]
    356          //        BlackLeftLoc[][]
    357          //说  明：1. 对第row行的跳变向左进行白到黑检测，成功就赋相应的值（有3个备用值），失败则赋255
    358          //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
    359          //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
    360          //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
    361          //        5. 若要改成黑到白的检测，或者任意检测，只需更改第一批条件即可，很方便。
    362          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    363          uint8 BlackGetLeftStep1Edge(uint8 row, uint8 use, uint8 CrossFlag)
    364          {
   \                     BlackGetLeftStep1Edge:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    365            uint8 index, col, temp, temp1;
    366            uint8 abs1;
    367            
    368            //左线检测跳变时的起始列，允许在中心线的基础上向右偏移BlackLeftEdgeStartColOffset这么多列。
    369            temp = CameraRealWidth/2 - 1 + BlackLeftEdgeStartColOffset;
   \   0000000A   0xF05F 0x08AE      MOVS     R8,#+174
    370            
    371            index = 0;         //可疑点的序号
   \   0000000E   0x2700             MOVS     R7,#+0
    372            //从中间到最左边扫描，隔1个点求差
    373            for(col = temp; col >= 4+BlackLeftEdgeNum; col--) 
   \   00000010   0xE045             B.N      ??BlackGetLeftStep1Edge_0
    374            {
    375                abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col-1-BlackLeftEdgeNum]); //取差值的绝对值。
    376                
    377                if( //跳变沿的第一批条件：
    378                    //黑够黑，白够白，差够大。
    379                    //这里的3个阈值为初始值，不是自适应之后调整的值。
    380                    (abs1 > LimitLeftWB) //两者的差够大
    381                  //后面两个条件改一下，就可以实现黑到白的跳变检测，或者任意检测。
    382                  &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
    383                  &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
    384                   )
    385                {         
    386                    //跳变沿的第二批条件：
    387                    //近处的行，向左3个点仍为黑点
    388                    if(row > BlackMiddleLine)
    389                    {
    390                      temp1 = (
    391                                (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    392                              &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    393                              &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
    394                              );
    395                    }          
    396                    else
    397                    {
    398                      //远处的行 ，向左2个点为仍为黑点
    399                      if(row > BlackFarLine)
    400                      {
    401                        temp1 = (
    402                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    403                                &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    404                                );
    405                      }
    406                      //远处的行 ，向左1个点为仍为黑点
    407                      else
    408                      {
    409                        temp1 = (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB);
    410                      }
    411                    }
    412          
    413                    if(temp1)
    414                    {
    415                                      
    416                        //超过3个可疑黑点，则报错
    417                        if(index == 3)       
    418                        {
    419                          //如果是十字再检测的调用，就不用更新这几个值。
    420                          if(CrossFlag)
    421                          {
    422                            //对3个关键值的实际值清零
    423                            BlackLeftRealClear();
    424                          }
    425                          //该行定位黑线失败，赋无效值
    426                          BlackLeftLoc[row][0] = MaxValUint8;
    427                          return 0;
    428                        }
    429                        
    430                        //如果是十字再检测的调用，就不用更新这几个值。
    431                        if(CrossFlag)
    432                        {
    433                          //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
    434                          //记录3个关键值的实际信息，作为后面的参考。
    435                          if(use == 1)
    436                          {
    437                            BlackLeftRealWB[0] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
    438                            BlackLeftRealW[0] = ImgNew[row][col];
    439                            BlackLeftRealB[0] = ImgNew[row][col-1-BlackLeftEdgeNum];
    440                          }
    441                          else if(use == 2)
   \                     ??BlackGetLeftStep1Edge_1:
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D02             CMP      R5,#+2
   \   00000016   0xD135             BNE.N    ??BlackGetLeftStep1Edge_2
    442                          {
    443                            BlackLeftRealWB[1] = ImgNew[row][col] - ImgNew[row][col-1-BlackLeftEdgeNum]; 
   \   00000018   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x20FA             MOVS     R0,#+250
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000024   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000028   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000002C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x21FA             MOVS     R1,#+250
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   00000038   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000003C   0xEB18 0x0101      ADDS     R1,R8,R1
   \   00000040   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000044   0x1A40             SUBS     R0,R0,R1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   0000004A   0x7048             STRB     R0,[R1, #+1]
    444                            BlackLeftRealW[1] = ImgNew[row][col];
   \   0000004C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x20FA             MOVS     R0,#+250
   \   00000054   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000058   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000005C   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   00000064   0x7048             STRB     R0,[R1, #+1]
    445                            BlackLeftRealB[1] = ImgNew[row][col-1-BlackLeftEdgeNum];
   \   00000066   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006C   0x20FA             MOVS     R0,#+250
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000072   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000076   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000007A   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \   00000082   0x7048             STRB     R0,[R1, #+1]
    446                          }
    447                          else
    448                          {
    449                          }
    450                        }
    451                        //跳变检测成功，取黑点
    452                        BlackLeftLoc[row][index] = col - 1 - BlackLeftEdgeNum;          
   \                     ??BlackGetLeftStep1Edge_2:
   \   00000084   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2003             MOVS     R0,#+3
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   0000008E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000092   0xF1B8 0x0103      SUBS     R1,R8,#+3
   \   00000096   0x5439             STRB     R1,[R7, R0]
    453                        index++;
   \   00000098   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlackGetLeftStep1Edge_3:
   \   0000009A   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \                     ??BlackGetLeftStep1Edge_0:
   \   0000009E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A2   0xF1B8 0x0F06      CMP      R8,#+6
   \   000000A6   0xF0C0 0x810A      BCC.W    ??BlackGetLeftStep1Edge_4
   \   000000AA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x20FA             MOVS     R0,#+250
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000000B6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000BA   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000BE   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \   000000C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C8   0x20FA             MOVS     R0,#+250
   \   000000CA   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   000000CE   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   000000D2   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000000D6   0x.... 0x....      BL       AbsRe
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   000000DE   0x7809             LDRB     R1,[R1, #+0]
   \   000000E0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E2   0x4281             CMP      R1,R0
   \   000000E4   0xD2D9             BCS.N    ??BlackGetLeftStep1Edge_3
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F2   0x21FA             MOVS     R1,#+250
   \   000000F4   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   000000F8   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000FC   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   00000100   0x4288             CMP      R0,R1
   \   00000102   0xD2CA             BCS.N    ??BlackGetLeftStep1Edge_3
   \   00000104   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000108   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010A   0x20FA             MOVS     R0,#+250
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000110   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000114   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000118   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000011C   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000120   0x7809             LDRB     R1,[R1, #+0]
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD2B9             BCS.N    ??BlackGetLeftStep1Edge_3
   \   00000126   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000128   0x2C1F             CMP      R4,#+31
   \   0000012A   0xD336             BCC.N    ??BlackGetLeftStep1Edge_5
   \   0000012C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000130   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000132   0x20FA             MOVS     R0,#+250
   \   00000134   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000138   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000013C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000140   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000144   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000148   0x7809             LDRB     R1,[R1, #+0]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD223             BCS.N    ??BlackGetLeftStep1Edge_6
   \   0000014E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000152   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000154   0x20FA             MOVS     R0,#+250
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   0000015A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000015E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000162   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000016A   0x7809             LDRB     R1,[R1, #+0]
   \   0000016C   0x4288             CMP      R0,R1
   \   0000016E   0xD212             BCS.N    ??BlackGetLeftStep1Edge_6
   \   00000170   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000174   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000176   0x20FA             MOVS     R0,#+250
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   0000017C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000180   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000184   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000018C   0x7809             LDRB     R1,[R1, #+0]
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xD201             BCS.N    ??BlackGetLeftStep1Edge_6
   \   00000192   0x2001             MOVS     R0,#+1
   \   00000194   0xE000             B.N      ??BlackGetLeftStep1Edge_7
   \                     ??BlackGetLeftStep1Edge_6:
   \   00000196   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_7:
   \   00000198   0xE03C             B.N      ??BlackGetLeftStep1Edge_8
   \                     ??BlackGetLeftStep1Edge_5:
   \   0000019A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019C   0x2C15             CMP      R4,#+21
   \   0000019E   0xD325             BCC.N    ??BlackGetLeftStep1Edge_9
   \   000001A0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001A6   0x20FA             MOVS     R0,#+250
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000001AC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001B0   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001B4   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000001B8   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000001BC   0x7809             LDRB     R1,[R1, #+0]
   \   000001BE   0x4288             CMP      R0,R1
   \   000001C0   0xD212             BCS.N    ??BlackGetLeftStep1Edge_10
   \   000001C2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001C6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001C8   0x20FA             MOVS     R0,#+250
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000001CE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001D2   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001D6   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   000001DA   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000001DE   0x7809             LDRB     R1,[R1, #+0]
   \   000001E0   0x4288             CMP      R0,R1
   \   000001E2   0xD201             BCS.N    ??BlackGetLeftStep1Edge_10
   \   000001E4   0x2001             MOVS     R0,#+1
   \   000001E6   0xE000             B.N      ??BlackGetLeftStep1Edge_11
   \                     ??BlackGetLeftStep1Edge_10:
   \   000001E8   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_11:
   \   000001EA   0xE013             B.N      ??BlackGetLeftStep1Edge_8
   \                     ??BlackGetLeftStep1Edge_9:
   \   000001EC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001F0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001F2   0x20FA             MOVS     R0,#+250
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000001F8   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001FC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000200   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000208   0x7809             LDRB     R1,[R1, #+0]
   \   0000020A   0x4288             CMP      R0,R1
   \   0000020C   0xD201             BCS.N    ??BlackGetLeftStep1Edge_12
   \   0000020E   0x2001             MOVS     R0,#+1
   \   00000210   0xE000             B.N      ??BlackGetLeftStep1Edge_13
   \                     ??BlackGetLeftStep1Edge_12:
   \   00000212   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep1Edge_13:
   \                     ??BlackGetLeftStep1Edge_8:
   \   00000214   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xF43F 0xAF3F      BEQ.W    ??BlackGetLeftStep1Edge_3
   \   0000021C   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000021E   0x2F03             CMP      R7,#+3
   \   00000220   0xD10E             BNE.N    ??BlackGetLeftStep1Edge_14
   \   00000222   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000224   0x2E00             CMP      R6,#+0
   \   00000226   0xD001             BEQ.N    ??BlackGetLeftStep1Edge_15
   \   00000228   0x.... 0x....      BL       BlackLeftRealClear
   \                     ??BlackGetLeftStep1Edge_15:
   \   0000022C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022E   0x2003             MOVS     R0,#+3
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000234   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000238   0x21FF             MOVS     R1,#+255
   \   0000023A   0x7001             STRB     R1,[R0, #+0]
   \   0000023C   0x2000             MOVS     R0,#+0
   \   0000023E   0xE051             B.N      ??BlackGetLeftStep1Edge_16
   \                     ??BlackGetLeftStep1Edge_14:
   \   00000240   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000242   0x2E00             CMP      R6,#+0
   \   00000244   0xF43F 0xAF1E      BEQ.W    ??BlackGetLeftStep1Edge_2
   \   00000248   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024A   0x2D01             CMP      R5,#+1
   \   0000024C   0xF47F 0xAEE1      BNE.W    ??BlackGetLeftStep1Edge_1
   \   00000250   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000254   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000256   0x20FA             MOVS     R0,#+250
   \   00000258   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   0000025C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000260   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000264   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000268   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000026A   0x21FA             MOVS     R1,#+250
   \   0000026C   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   00000270   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000274   0xEB18 0x0101      ADDS     R1,R8,R1
   \   00000278   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   0000027C   0x1A40             SUBS     R0,R0,R1
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000282   0x7008             STRB     R0,[R1, #+0]
   \   00000284   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000288   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000028A   0x20FA             MOVS     R0,#+250
   \   0000028C   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000290   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000294   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000298   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000029C   0x7008             STRB     R0,[R1, #+0]
   \   0000029E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A4   0x20FA             MOVS     R0,#+250
   \   000002A6   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000002AA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002AE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000002B2   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000002B6   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \   000002BA   0x7008             STRB     R0,[R1, #+0]
   \   000002BC   0xE6E2             B.N      ??BlackGetLeftStep1Edge_2
    454                      
    455                    }    //end of 跳变沿的第二批条件
    456                }   //end of 跳变沿的第一批条件
    457            }// end of 从中间到最左边扫描，隔1个点求差
    458            
    459            //1个可疑黑点也没有，则报错。
    460            if(index == 0)
   \                     ??BlackGetLeftStep1Edge_4:
   \   000002BE   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002C0   0x2F00             CMP      R7,#+0
   \   000002C2   0xD10E             BNE.N    ??BlackGetLeftStep1Edge_17
    461            {
    462              //如果是十字再检测的调用，就不用更新这几个值。
    463              if(CrossFlag)
   \   000002C4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002C6   0x2E00             CMP      R6,#+0
   \   000002C8   0xD001             BEQ.N    ??BlackGetLeftStep1Edge_18
    464              {
    465                //对3个关键值的实际值清零
    466                BlackLeftRealClear();
   \   000002CA   0x.... 0x....      BL       BlackLeftRealClear
    467              }
    468              //该行定位黑线失败，赋无效值
    469              BlackLeftLoc[row][0] = MaxValUint8;
   \                     ??BlackGetLeftStep1Edge_18:
   \   000002CE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D0   0x2003             MOVS     R0,#+3
   \   000002D2   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   000002D6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002DA   0x21FF             MOVS     R1,#+255
   \   000002DC   0x7001             STRB     R1,[R0, #+0]
    470              return 0;
   \   000002DE   0x2000             MOVS     R0,#+0
   \   000002E0   0xE000             B.N      ??BlackGetLeftStep1Edge_16
    471            }
    472            
    473            //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
    474            return 1;
   \                     ??BlackGetLeftStep1Edge_17:
   \   000002E2   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeftStep1Edge_16:
   \   000002E4   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    475          }
    476          
    477          
    478          
    479          //======================================================================
    480          //函数名：BlackGetLeftStep2Win
    481          //功  能：左黑线提取中，第2阶段窗口内跳变检测函数
    482          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict
    483          //返  回：1成功  0失败
    484          //影  响：BlackLeftLoc[][0]
    485          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
    486          //        2. 窗口内没有检测到，则检测失败。
    487          //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
    488          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    489          uint8 BlackGetLeftStep2Win(uint8 row, uint8 win, uint8 predict)
    490          {
   \                     BlackGetLeftStep2Win:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    491            uint8 col, temp, temp1;
    492            uint8 abs1;
    493          
    494            //在规划好的窗口内，从右往左查找跳变沿
    495            //防止溢出
    496            
    497            //对左边界的限制
    498            if(predict <= win)
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0xD301             BCC.N    ??BlackGetLeftStep2Win_0
    499            {
    500              temp = 4 + BlackLeftEdgeNum;
   \   0000000C   0x2506             MOVS     R5,#+6
   \   0000000E   0xE004             B.N      ??BlackGetLeftStep2Win_1
    501            }  
    502            else
    503            {
    504              temp = predict - win;
   \                     ??BlackGetLeftStep2Win_0:
   \   00000010   0x1A55             SUBS     R5,R2,R1
    505              if(temp < 4 + BlackLeftEdgeNum)
   \   00000012   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000014   0x2D06             CMP      R5,#+6
   \   00000016   0xD200             BCS.N    ??BlackGetLeftStep2Win_1
    506              {
    507                temp = 4 + BlackLeftEdgeNum;
   \   00000018   0x2506             MOVS     R5,#+6
    508              }
    509              else 
    510              {
    511              } 
    512            }
    513            
    514            //对右边界的限制
    515            if(predict + win > CameraRealWidth - 1)
   \                     ??BlackGetLeftStep2Win_1:
   \   0000001A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000001C   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   00000020   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000022   0x28FA             CMP      R0,#+250
   \   00000024   0xD301             BCC.N    ??BlackGetLeftStep2Win_2
    516            {
    517              col = CameraRealWidth - 1;  
   \   00000026   0x26F9             MOVS     R6,#+249
   \   00000028   0xE002             B.N      ??BlackGetLeftStep2Win_3
    518            }
    519            else
    520            {
    521              col = predict + win;  
   \                     ??BlackGetLeftStep2Win_2:
   \   0000002A   0x188E             ADDS     R6,R1,R2
   \   0000002C   0xE000             B.N      ??BlackGetLeftStep2Win_3
    522            }
    523            
    524            //判断条件里的">"很关键，没有写">="是考虑temp = 0的情况，这样可以防止产生负数（uint8中为正数），即无限循环。
    525            for( ; col > temp; col--) 
   \                     ??BlackGetLeftStep2Win_4:
   \   0000002E   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackGetLeftStep2Win_3:
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0x42B5             CMP      R5,R6
   \   00000036   0xF080 0x80AF      BCS.W    ??BlackGetLeftStep2Win_5
    526            {
    527              abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col-1-BlackLeftEdgeNum]);
   \   0000003A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x20FA             MOVS     R0,#+250
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000044   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000048   0x1830             ADDS     R0,R6,R0
   \   0000004A   0xF810 0x1C03      LDRB     R1,[R0, #-3]
   \   0000004E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000050   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000052   0x20FA             MOVS     R0,#+250
   \   00000054   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   00000058   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   0000005C   0x5C30             LDRB     R0,[R6, R0]
   \   0000005E   0x.... 0x....      BL       AbsRe
    528              if( //跳变沿的第一批条件：
    529                  //黑够黑，白够白，差够大。
    530                  //这里的3个阈值是自适应之后调整的值
    531                    (abs1 > LimitLeftWB) //两者的差够大
    532                  &&(ImgNew[row][col] > LimitLeftW)                     //白点够白
    533                  &&(ImgNew[row][col-1-BlackLeftEdgeNum] < LimitLeftB)                   //黑点够黑
    534                 )
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x4281             CMP      R1,R0
   \   0000006C   0xD2DF             BCS.N    ??BlackGetLeftStep2Win_4
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable12_7
   \   00000072   0x7800             LDRB     R0,[R0, #+0]
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0x21FA             MOVS     R1,#+250
   \   0000007A   0x.... 0x....      LDR.W    R2,??DataTable12_4
   \   0000007E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000082   0x5C71             LDRB     R1,[R6, R1]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xD2D2             BCS.N    ??BlackGetLeftStep2Win_4
   \   00000088   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000008A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000008C   0x20FA             MOVS     R0,#+250
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000092   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000096   0x1830             ADDS     R0,R6,R0
   \   00000098   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD2C3             BCS.N    ??BlackGetLeftStep2Win_4
    535              {
    536                    //近处的行，向左3个点仍为黑点
    537                    if(row > BlackMiddleLine)
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2C1F             CMP      R4,#+31
   \   000000AA   0xD330             BCC.N    ??BlackGetLeftStep2Win_6
    538                    {
    539                      temp1 = (
    540                                (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    541                              &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    542                              &&(ImgNew[row][col-4-BlackLeftEdgeNum] < LimitLeftB)
    543                              );
   \   000000AC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x20FA             MOVS     R0,#+250
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000000B6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000BA   0x1830             ADDS     R0,R6,R0
   \   000000BC   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000000C4   0x7809             LDRB     R1,[R1, #+0]
   \   000000C6   0x4288             CMP      R0,R1
   \   000000C8   0xD21F             BCS.N    ??BlackGetLeftStep2Win_7
   \   000000CA   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x20FA             MOVS     R0,#+250
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000000D4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000D8   0x1830             ADDS     R0,R6,R0
   \   000000DA   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000000E2   0x7809             LDRB     R1,[R1, #+0]
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD210             BCS.N    ??BlackGetLeftStep2Win_7
   \   000000E8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000EA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EC   0x20FA             MOVS     R0,#+250
   \   000000EE   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   000000F2   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000F6   0x1830             ADDS     R0,R6,R0
   \   000000F8   0xF810 0x0C06      LDRB     R0,[R0, #-6]
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000100   0x7809             LDRB     R1,[R1, #+0]
   \   00000102   0x4288             CMP      R0,R1
   \   00000104   0xD201             BCS.N    ??BlackGetLeftStep2Win_7
   \   00000106   0x2001             MOVS     R0,#+1
   \   00000108   0xE000             B.N      ??BlackGetLeftStep2Win_8
   \                     ??BlackGetLeftStep2Win_7:
   \   0000010A   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_8:
   \   0000010C   0xE036             B.N      ??BlackGetLeftStep2Win_9
    544                    }
    545                    else
    546                    {
    547                      //中间的行 ，向左2个点为仍为黑点
    548                      if(row > BlackFarLine)
   \                     ??BlackGetLeftStep2Win_6:
   \   0000010E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000110   0x2C15             CMP      R4,#+21
   \   00000112   0xD321             BCC.N    ??BlackGetLeftStep2Win_10
    549                      {
    550                        temp1 = (
    551                                  (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB)
    552                                &&(ImgNew[row][col-3-BlackLeftEdgeNum] < LimitLeftB)
    553                                );
   \   00000114   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000116   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000118   0x20FA             MOVS     R0,#+250
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   0000011E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000122   0x1830             ADDS     R0,R6,R0
   \   00000124   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000012C   0x7809             LDRB     R1,[R1, #+0]
   \   0000012E   0x4288             CMP      R0,R1
   \   00000130   0xD210             BCS.N    ??BlackGetLeftStep2Win_11
   \   00000132   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000134   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000136   0x20FA             MOVS     R0,#+250
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   0000013C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000140   0x1830             ADDS     R0,R6,R0
   \   00000142   0xF810 0x0C05      LDRB     R0,[R0, #-5]
   \   00000146   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   0000014A   0x7809             LDRB     R1,[R1, #+0]
   \   0000014C   0x4288             CMP      R0,R1
   \   0000014E   0xD201             BCS.N    ??BlackGetLeftStep2Win_11
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0xE000             B.N      ??BlackGetLeftStep2Win_12
   \                     ??BlackGetLeftStep2Win_11:
   \   00000154   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_12:
   \   00000156   0xE011             B.N      ??BlackGetLeftStep2Win_9
    554                      }
    555                      //远处的行 ，向左1个点为仍为黑点
    556                      else
    557                      {
    558                        temp1 = (ImgNew[row][col-2-BlackLeftEdgeNum] < LimitLeftB);
   \                     ??BlackGetLeftStep2Win_10:
   \   00000158   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000015A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000015C   0x20FA             MOVS     R0,#+250
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable12_4
   \   00000162   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000166   0x1830             ADDS     R0,R6,R0
   \   00000168   0xF810 0x0C04      LDRB     R0,[R0, #-4]
   \   0000016C   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   00000170   0x7809             LDRB     R1,[R1, #+0]
   \   00000172   0x4288             CMP      R0,R1
   \   00000174   0xD201             BCS.N    ??BlackGetLeftStep2Win_13
   \   00000176   0x2001             MOVS     R0,#+1
   \   00000178   0xE000             B.N      ??BlackGetLeftStep2Win_14
   \                     ??BlackGetLeftStep2Win_13:
   \   0000017A   0x2000             MOVS     R0,#+0
    559                      }
    560                    }
    561                    
    562                    //跳变沿的第二批条件：
    563                    if(temp1)
   \                     ??BlackGetLeftStep2Win_14:
   \                     ??BlackGetLeftStep2Win_9:
   \   0000017C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xF43F 0xAF55      BEQ.W    ??BlackGetLeftStep2Win_4
    564                    {
    565                      //两批条件均满足，直接记录该点为黑线，返回即可
    566                      BlackLeftLoc[row][0] = col - 1 - BlackLeftEdgeNum;
   \   00000184   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000186   0x2003             MOVS     R0,#+3
   \   00000188   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000018C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000190   0x1EF1             SUBS     R1,R6,#+3
   \   00000192   0x7001             STRB     R1,[R0, #+0]
    567                      return 1;
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0xE008             B.N      ??BlackGetLeftStep2Win_15
    568                      //break;          
    569                    }// end of 跳变沿检测的第2批条件
    570              }// end of 跳变沿检测的第1批条件
    571              
    572              
    573              
    574            }// end of for循环
    575            
    576            //如果一直到窗口最左边还没有找到跳变沿，
    577            
    578            BlackLeftLoc[row][0] = MaxValUint8;   //该行的黑线位置记为无效值
   \                     ??BlackGetLeftStep2Win_5:
   \   00000198   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000019A   0x2003             MOVS     R0,#+3
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000001A0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001A4   0x21FF             MOVS     R1,#+255
   \   000001A6   0x7001             STRB     R1,[R0, #+0]
    579            return 0;
   \   000001A8   0x2000             MOVS     R0,#+0
   \                     ??BlackGetLeftStep2Win_15:
   \   000001AA   0xBD70             POP      {R4-R6,PC}       ;; return
    580          
    581            
    582          }
    583          
    584          
    585          //======================================================================
    586          //函数名：BlackGetLeftStep1Scan
    587          //功  能：左黑线提取中，第1阶段的行扫描函数
    588          //参  数：扫描起始行FirstLine, 扫描结束行LastLine, 十字再检测标志CrossFlag
    589          //返  回：0~CameraHight-1行数 255采集失败
    590          //影  响：BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[], BlackLeftLoc[][],
    591          //        LimitLeftWB, LimitLeftW, LimitLeftB
    592          //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
    593          //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
    594          //             
    595          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    596          uint8 BlackGetLeftStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
    597          {
   \                     BlackGetLeftStep1Scan:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
    598              uint8 row, temp1, temp2;
    599              uint8 abs1;
    600              uint8 tempWB, tempW, tempB;
    601            //最近的BlackStep1Size行用差值法找黑线
    602              for(row = FirstLine; row > LastLine; row -= 2)
   \   00000008   0xE000             B.N      ??BlackGetLeftStep1Scan_0
   \                     ??BlackGetLeftStep1Scan_1:
   \   0000000A   0x1EAD             SUBS     R5,R5,#+2
   \                     ??BlackGetLeftStep1Scan_0:
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD270             BCS.N    ??BlackGetLeftStep1Scan_2
    603              {
    604                //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个
    605                temp1 = BlackGetLeftStep1Edge(row, 1, CrossFlag);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       BlackGetLeftStep1Edge
   \   00000022   0x0007             MOVS     R7,R0
    606                temp2 = BlackGetLeftStep1Edge(row-1, 2, CrossFlag);
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x1E68             SUBS     R0,R5,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       BlackGetLeftStep1Edge
    607                if(temp1 && temp2)//这里可以这么写，不用嵌套if，因为&&的特点
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD0E8             BEQ.N    ??BlackGetLeftStep1Scan_1
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0E5             BEQ.N    ??BlackGetLeftStep1Scan_1
    608                {
    609                  abs1 = AbsRe(BlackLeftLoc[row-1][0], BlackLeftLoc[row][0]);
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable12_5
   \   00000046   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000004A   0x7801             LDRB     R1,[R0, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable12_5
   \   00000054   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   00000058   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000005C   0x.... 0x....      BL       AbsRe
    610                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
    611                  if(abs1 < BlackLeftStep1ScanMinus)
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2806             CMP      R0,#+6
   \   00000064   0xD2D1             BCS.N    ??BlackGetLeftStep1Scan_1
    612                  {
    613                    //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段
    614                    //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
    615                    if(CrossFlag)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD044             BEQ.N    ??BlackGetLeftStep1Scan_3
    616                      {
    617                        //差值的处理，留有裕度，且有上下界。
    618                        tempWB = (BlackLeftRealWB[0] + BlackLeftRealWB[1]) / 2 - LimitLeftWBMargin; 
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable12_1
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable12_1
   \   00000076   0x7849             LDRB     R1,[R1, #+1]
   \   00000078   0x1808             ADDS     R0,R1,R0
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000080   0x3814             SUBS     R0,R0,#+20
    619                        if(tempWB < LimitLeftWBMin) tempWB = LimitLeftWBMin;
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x284B             CMP      R0,#+75
   \   00000086   0xD201             BCS.N    ??BlackGetLeftStep1Scan_4
   \   00000088   0x204B             MOVS     R0,#+75
   \   0000008A   0xE003             B.N      ??BlackGetLeftStep1Scan_5
    620                        else if(tempWB > LimitLeftWBMax) tempWB = LimitLeftWBMax;
   \                     ??BlackGetLeftStep1Scan_4:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x286A             CMP      R0,#+106
   \   00000090   0xD300             BCC.N    ??BlackGetLeftStep1Scan_5
   \   00000092   0x2069             MOVS     R0,#+105
    621                        else ;
    622                        LimitLeftWB = tempWB;
   \                     ??BlackGetLeftStep1Scan_5:
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable12_6
   \   00000098   0x7008             STRB     R0,[R1, #+0]
    623                        
    624                        //白点的处理，留有裕度，且有上下界。
    625                        tempW = (BlackLeftRealW[0] + BlackLeftRealW[1]) / 2 - LimitLeftWMargin;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   000000A4   0x7849             LDRB     R1,[R1, #+1]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000AE   0x381E             SUBS     R0,R0,#+30
    626                        if(tempW < LimitLeftWMin) tempW = LimitLeftWMin;
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2896             CMP      R0,#+150
   \   000000B4   0xD201             BCS.N    ??BlackGetLeftStep1Scan_6
   \   000000B6   0x2096             MOVS     R0,#+150
   \   000000B8   0xE003             B.N      ??BlackGetLeftStep1Scan_7
    627                        else if(tempW > LimitLeftWMax) tempW = LimitLeftWMax;
   \                     ??BlackGetLeftStep1Scan_6:
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x28C9             CMP      R0,#+201
   \   000000BE   0xD300             BCC.N    ??BlackGetLeftStep1Scan_7
   \   000000C0   0x20C8             MOVS     R0,#+200
    628                        else ;
    629                        LimitLeftW = tempW;
   \                     ??BlackGetLeftStep1Scan_7:
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable12_7
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
    630                        
    631                        //黑点的处理，留有裕度，且有上下界。
    632                        tempB = (BlackLeftRealB[0] + BlackLeftRealB[1]) / 2 + LimitLeftBMargin;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable12_3
   \   000000D2   0x7849             LDRB     R1,[R1, #+1]
   \   000000D4   0x1808             ADDS     R0,R1,R0
   \   000000D6   0x2102             MOVS     R1,#+2
   \   000000D8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000DC   0x301E             ADDS     R0,R0,#+30
    633                        if(tempB < LimitLeftBMin) tempB = LimitLeftBMin;
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2855             CMP      R0,#+85
   \   000000E2   0xD201             BCS.N    ??BlackGetLeftStep1Scan_8
   \   000000E4   0x2055             MOVS     R0,#+85
   \   000000E6   0xE003             B.N      ??BlackGetLeftStep1Scan_9
    634                        else if(tempB > LimitLeftBMax) tempB = LimitLeftBMax;
   \                     ??BlackGetLeftStep1Scan_8:
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2865             CMP      R0,#+101
   \   000000EC   0xD300             BCC.N    ??BlackGetLeftStep1Scan_9
   \   000000EE   0x2064             MOVS     R0,#+100
    635                        else ;
    636                        LimitLeftB = tempB;
   \                     ??BlackGetLeftStep1Scan_9:
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable12_8
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
    637                      }
    638                    break;
    639                  }
    640                }      
    641              }   
    642              
    643              //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
    644              if(row <= LastLine)
   \                     ??BlackGetLeftStep1Scan_3:
   \                     ??BlackGetLeftStep1Scan_2:
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x42AC             CMP      R4,R5
   \   000000FC   0xD301             BCC.N    ??BlackGetLeftStep1Scan_10
    645                return MaxValUint8;
   \   000000FE   0x20FF             MOVS     R0,#+255
   \   00000100   0xE001             B.N      ??BlackGetLeftStep1Scan_11
    646              else 
    647                return row;
   \                     ??BlackGetLeftStep1Scan_10:
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetLeftStep1Scan_11:
   \   00000106   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    648            
    649          }
    650          
    651          //======================================================================
    652          //函数名：BlackLeftCrossStep3
    653          //功  能：左线提取中，十字检测第3阶段，脑补线函数
    654          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
    655          //返  回：1成功 0失败
    656          //影  响：BlackLeftLoc[][0]
    657          //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
    658          //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
    659          //             
    660          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    661          uint8 BlackLeftCrossStep3(uint8 FirstLine, uint8 LastLine)
    662          {
   \                     BlackLeftCrossStep3:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
    663            float delta_x, delta_y, delta, index;
    664            uint8 row, temp1, temp2;
    665            //uint8 temp3, temp4, flag1, flag2;
    666            
    667            //超始行比结束行还高，报错！
    668            if(LastLine >= FirstLine)
   \   00000008   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x42A7             CMP      R7,R4
   \   0000000E   0xD308             BCC.N    ??BlackLeftCrossStep3_0
    669            {
    670              uart_sendN(UART0, (uint8 *)"\nError In BlackLeftCrossStep3!", 30);
   \   00000010   0x221E             MOVS     R2,#+30
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable12  ;; 0x4006a000
   \   0000001A   0x.... 0x....      BL       uart_sendN
    671              return 0;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE0A5             B.N      ??BlackLeftCrossStep3_1
    672            }
    673            
    674            temp1 = BlackLeftLoc[FirstLine][0];
   \                     ??BlackLeftCrossStep3_0:
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000002A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002E   0x7805             LDRB     R5,[R0, #+0]
    675            temp2 = BlackLeftLoc[LastLine][0];
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000038   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   0000003C   0xF890 0x8000      LDRB     R8,[R0, #+0]
    676            
    677            /*
    678            flag = 1;
    679            flag = 2;
    680            //确认这两个点是直角处的点，也就是往左6个点仍为黑点
    681            if(temp1 <= (CameraRealWidth - 9))
    682            {
    683              temp3 = (
    684                      (ImgNew[FirstLine+1][temp1+6] < LimitLeftB)
    685                    &&(ImgNew[FirstLine+1][temp1+7] < LimitLeftB)
    686                    &&(ImgNew[FirstLine+1][temp1+8] < LimitLeftB)
    687                    );
    688              if(temp3)
    689              {
    690                flag1 = 0;  
    691              }
    692            }
    693            
    694            if(temp2 <= (CameraRealWidth - 9))
    695            {
    696              temp4 = (
    697                      (ImgNew[LastLine-1][temp2+6] < LimitLeftB)
    698                    &&(ImgNew[LastLine-1][temp2+7] < LimitLeftB)
    699                    &&(ImgNew[LastLine-1][temp2+8] < LimitLeftB)
    700                    );
    701              if(temp4)
    702              {
    703                flag2 = 0;  
    704              }
    705            }
    706            
    707            if((flag1 == 0) || (flag2 == 0))
    708            {
    709              return 0;  
    710            }
    711            
    712            */
    713            
    714            delta_y = FirstLine - LastLine;
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0x1BE0             SUBS     R0,R4,R7
   \   00000046   0x.... 0x....      BL       __aeabi_i2f
   \   0000004A   0x0006             MOVS     R6,R0
    715            
    716            
    717            //斜率向右
    718            if(temp1 < temp2)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0x4545             CMP      R5,R8
   \   00000054   0xD23A             BCS.N    ??BlackLeftCrossStep3_2
    719            {
    720              delta_x = temp2 - temp1;
   \   00000056   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0xEBB8 0x0005      SUBS     R0,R8,R5
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
    721              delta = delta_x / delta_y; //这是1个浮点数
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x0005             MOVS     R5,R0
    722              
    723              index = 1.0;
   \   0000006C   0xF05F 0x587E      MOVS     R8,#+1065353216
    724              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   00000070   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackLeftCrossStep3_3:
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x1C78             ADDS     R0,R7,#+1
   \   00000078   0x4286             CMP      R6,R0
   \   0000007A   0xDB77             BLT.N    ??BlackLeftCrossStep3_4
    725              {
    726                //每次右移一点点
    727                BlackLeftLoc[row][0] = (uint8)((float)BlackLeftLoc[FirstLine][0] + delta * index);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000084   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x4641             MOV      R1,R8
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x2103             MOVS     R1,#+3
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000AA   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    728                index += 1.0;
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x0002             MOVS     R2,R0
   \   000000B8   0x000B             MOVS     R3,R1
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x....             LDR.N    R1,??DataTable10  ;; 0x3ff00000
   \   000000BE   0x.... 0x....      BL       __aeabi_dadd
   \   000000C2   0x.... 0x....      BL       __aeabi_d2f
   \   000000C6   0x4680             MOV      R8,R0
    729              }
   \   000000C8   0x1E76             SUBS     R6,R6,#+1
   \   000000CA   0xE7D2             B.N      ??BlackLeftCrossStep3_3
    730            }
    731            //斜率向左
    732            else if(temp1 > temp2)
   \                     ??BlackLeftCrossStep3_2:
   \   000000CC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D2   0x45A8             CMP      R8,R5
   \   000000D4   0xD23B             BCS.N    ??BlackLeftCrossStep3_5
    733            {
    734              delta_x = temp1 - temp2;
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DC   0xEBB5 0x0008      SUBS     R0,R5,R8
   \   000000E0   0x.... 0x....      BL       __aeabi_i2f
    735              delta = delta_x / delta_y;
   \   000000E4   0x0031             MOVS     R1,R6
   \   000000E6   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EA   0x0005             MOVS     R5,R0
    736              
    737              index = 1.0;
   \   000000EC   0xF05F 0x587E      MOVS     R8,#+1065353216
    738              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000F0   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackLeftCrossStep3_6:
   \   000000F2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F4   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F6   0x1C78             ADDS     R0,R7,#+1
   \   000000F8   0x4286             CMP      R6,R0
   \   000000FA   0xDB37             BLT.N    ??BlackLeftCrossStep3_4
    739              {
    740                //每次右移一点点
    741                BlackLeftLoc[row][0] = (uint8)((float)BlackLeftLoc[FirstLine][0] - delta * index);
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x2003             MOVS     R0,#+3
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000104   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000010E   0x4681             MOV      R9,R0
   \   00000110   0x0028             MOVS     R0,R5
   \   00000112   0x4641             MOV      R1,R8
   \   00000114   0x.... 0x....      BL       __aeabi_fmul
   \   00000118   0x0001             MOVS     R1,R0
   \   0000011A   0x4648             MOV      R0,R9
   \   0000011C   0x.... 0x....      BL       __aeabi_fsub
   \   00000120   0x.... 0x....      BL       __aeabi_f2iz
   \   00000124   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000126   0x2103             MOVS     R1,#+3
   \   00000128   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000012C   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   00000130   0x7008             STRB     R0,[R1, #+0]
    742                index += 1.0;
   \   00000132   0x4640             MOV      R0,R8
   \   00000134   0x.... 0x....      BL       __aeabi_f2d
   \   00000138   0x0002             MOVS     R2,R0
   \   0000013A   0x000B             MOVS     R3,R1
   \   0000013C   0x2000             MOVS     R0,#+0
   \   0000013E   0x....             LDR.N    R1,??DataTable10  ;; 0x3ff00000
   \   00000140   0x.... 0x....      BL       __aeabi_dadd
   \   00000144   0x.... 0x....      BL       __aeabi_d2f
   \   00000148   0x4680             MOV      R8,R0
    743              }
   \   0000014A   0x1E76             SUBS     R6,R6,#+1
   \   0000014C   0xE7D1             B.N      ??BlackLeftCrossStep3_6
    744            }
    745            //斜率直走，这个不太可能出现
    746            else
    747            {
    748              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackLeftCrossStep3_5:
   \   0000014E   0x1E66             SUBS     R6,R4,#+1
   \   00000150   0xE007             B.N      ??BlackLeftCrossStep3_7
    749              {
    750                //赋相同的值
    751                BlackLeftLoc[row][0] = temp1;
   \                     ??BlackLeftCrossStep3_8:
   \   00000152   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000154   0x2003             MOVS     R0,#+3
   \   00000156   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000015A   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   0000015E   0x7005             STRB     R5,[R0, #+0]
    752              }
   \   00000160   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackLeftCrossStep3_7:
   \   00000162   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000164   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000166   0x1C78             ADDS     R0,R7,#+1
   \   00000168   0x4286             CMP      R6,R0
   \   0000016A   0xDAF2             BGE.N    ??BlackLeftCrossStep3_8
    753            }
    754            
    755            return 1;
   \                     ??BlackLeftCrossStep3_4:
   \   0000016C   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftCrossStep3_1:
   \   0000016E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    756              
    757          }
    758          
    759          //======================================================================
    760          //函数名：BlackLeftCrossConfirm
    761          //功  能：十字再检测时 ，线头有效性的确认。
    762          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
    763          //返  回：1成功 0失败
    764          //影  响：无
    765          //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
    766          //      
    767          //             
    768          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    769          uint8 BlackLeftCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
    770          {
   \                     BlackLeftCrossConfirm:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
    771            uint8 row, index;
    772            uint8 x[BlackCrossConfirmNum];
    773            uint8 y[BlackCrossConfirmNum];
    774            
    775            float a0, a1, temp;
    776            
    777            //第一段黑线太短，无法检测正确性。直接返回1.
    778            if(Row1RealLastLine < 5) return 1;
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xD201             BCS.N    ??BlackLeftCrossConfirm_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE044             B.N      ??BlackLeftCrossConfirm_1
    779            
    780            //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
    781            index = 0;
   \                     ??BlackLeftCrossConfirm_0:
   \   0000000E   0x2100             MOVS     R1,#+0
    782            for(row = Row1RealLastLine; ; row++)
   \   00000010   0xE000             B.N      ??BlackLeftCrossConfirm_2
   \                     ??BlackLeftCrossConfirm_3:
   \   00000012   0x1C40             ADDS     R0,R0,#+1
    783            {
    784              //有效行的记录
    785              if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??BlackLeftCrossConfirm_2:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2203             MOVS     R2,#+3
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable12_5
   \   0000001C   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD00D             BEQ.N    ??BlackLeftCrossConfirm_4
    786              {
    787                y[index] = BlackLeftLoc[row][0];
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable12_5
   \   0000002E   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0x54CA             STRB     R2,[R1, R3]
    788                x[index] = row;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xAA01             ADD      R2,SP,#+4
   \   0000003E   0x5488             STRB     R0,[R1, R2]
    789                index++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
    790              }
    791              //点数够多，则跳出。
    792              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackLeftCrossConfirm_4:
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x2903             CMP      R1,#+3
   \   00000046   0xD121             BNE.N    ??BlackLeftCrossConfirm_5
    793              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
    794              if(row == CameraHight - 1) return 1;
    795            }
    796            
    797            //最小二乘法
    798            //y = a0 + a1 * x
    799            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       LeastSquarea1
   \   00000052   0x0006             MOVS     R6,R0
    800            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       LeastSquarea0
   \   00000060   0x0005             MOVS     R5,R0
    801            
    802            //temp为第2段黑线起始行本应该在的位置。
    803            temp = a0 + a1 * Row2RealFirstLine;
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       __aeabi_ui2f
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x0029             MOVS     R1,R5
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
    804            //如果这个位置本来就超出了左右边界的范围，那说明不可能有第2段黑线存在了。
    805            //也就不用检测第2段黑线了，直接返回0.
    806            if((temp < 0) || (temp > CameraRealWidth - 1)) 
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xD304             BCC.N    ??BlackLeftCrossConfirm_6
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0x43790001
   \   00000082   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000086   0xD806             BHI.N    ??BlackLeftCrossConfirm_7
    807            {
    808              return 0;
   \                     ??BlackLeftCrossConfirm_6:
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0xE005             B.N      ??BlackLeftCrossConfirm_1
    809            }
   \                     ??BlackLeftCrossConfirm_5:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x2831             CMP      R0,#+49
   \   00000090   0xD1BF             BNE.N    ??BlackLeftCrossConfirm_3
   \   00000092   0x2001             MOVS     R0,#+1
   \   00000094   0xE000             B.N      ??BlackLeftCrossConfirm_1
    810            else
    811            { //这里本来应该加上把这个点限定在窗内，但是似乎没必要。
    812              //if(
    813              //  (BlackLeftLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
    814              //&&(BlackLeftLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)
    815              //  )
    816              return 1;
   \                     ??BlackLeftCrossConfirm_7:
   \   00000096   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftCrossConfirm_1:
   \   00000098   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    817            }  
    818          }
    819          
    820          
    821          
    822          //======================================================================
    823          //函数名：BlackLeftAgainForCross
    824          //功  能：左黑线提取中，针对十字的再检测程序
    825          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
    826          //        第1段黑线的实际结束行Row1RealLastLine
    827          //返  回：1成功 0失败
    828          //影  响：BlackLeftLoc[][]。 （不会影响那几个阈值。）
    829          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
    830          //        2. 本函数仅影响了BlackLeftLoc[][]，以后也应该保持。
    831          //             
    832          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    833          uint8 BlackLeftAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine)
    834          {
   \                     BlackLeftAgainForCross:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    835              uint8 row, temp, temp1, temp2;
    836              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
    837              uint8 i;
    838              
    839              //十字再检测第1阶段，找线头。
    840              temp = BlackGetLeftStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       BlackGetLeftStep1Scan
   \   00000018   0x4680             MOV      R8,R0
    841              if(temp == MaxValUint8)  
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD10E             BNE.N    ??BlackLeftAgainForCross_0
    842              {
    843                //扫屁股工作。       //i >= Row2LastLine
    844                for(i = Row2FirstLine; ; i--)
   \   00000024   0xE000             B.N      ??BlackLeftAgainForCross_1
   \                     ??BlackLeftAgainForCross_2:
   \   00000026   0x1E64             SUBS     R4,R4,#+1
    845                {
    846                  BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_1:
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000030   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000034   0x21FF             MOVS     R1,#+255
   \   00000036   0x7001             STRB     R1,[R0, #+0]
    847                  if(i == 0) break;
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD1F3             BNE.N    ??BlackLeftAgainForCross_2
    848                }
    849                return 0;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE07A             B.N      ??BlackLeftAgainForCross_3
    850              }
    851              else 
    852              {
    853                ////////////////如果要注释，就从这里开始注释
    854                //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
    855                if(!BlackLeftCrossConfirm(Row1RealLastLine, temp))
   \                     ??BlackLeftAgainForCross_0:
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackLeftCrossConfirm
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD10E             BNE.N    ??BlackLeftAgainForCross_4
    856                { //扫屁股工作。       //i >= (temp-1)
    857                  for(i = Row2FirstLine; ; i--)
   \   00000052   0xE000             B.N      ??BlackLeftAgainForCross_5
   \                     ??BlackLeftAgainForCross_6:
   \   00000054   0x1E64             SUBS     R4,R4,#+1
    858                  {
    859                    BlackLeftLoc[i][0] = MaxValUint8;
   \                     ??BlackLeftAgainForCross_5:
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000005E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x7001             STRB     R1,[R0, #+0]
    860                    if(i == 0) break;
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C00             CMP      R4,#+0
   \   0000006A   0xD1F3             BNE.N    ??BlackLeftAgainForCross_6
    861                  }
    862                  return 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE063             B.N      ??BlackLeftAgainForCross_3
    863                }
    864                //十字再检测的线头的确在限定的范围内，可以继续。
    865                else
    866                {
    867                row = temp;
   \                     ??BlackLeftAgainForCross_4:
   \   00000070   0x4644             MOV      R4,R8
    868                }
    869                ////////////////如果要注释，就从这里结束注释
    870                
    871                //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
    872                //row = temp;
    873              }
    874              
    875              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000072   0x0027             MOVS     R7,R4
    876              
    877              //十字再检测第2阶段，顺着线头找线。
    878              //temp为预测的黑点位置
    879              temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000007C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2103             MOVS     R1,#+3
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000008C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000090   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable14
   \   0000009E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0xEBB0 0x0801      SUBS     R8,R0,R1
    880              //从最近的认证行到取最远的行
    881              for(row -= 2; ; row -= 2)
   \   000000A8   0x1EA4             SUBS     R4,R4,#+2
   \   000000AA   0xE000             B.N      ??BlackLeftAgainForCross_7
   \                     ??BlackLeftAgainForCross_8:
   \   000000AC   0x1EA4             SUBS     R4,R4,#+2
    882              {
    883                //如果连续两行的黑点检测成功，则更新预测点的位置
    884                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp);
   \                     ??BlackLeftAgainForCross_7:
   \   000000AE   0x4642             MOV      R2,R8
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x210F             MOVS     R1,#+15
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   000000BC   0x4681             MOV      R9,R0
    885                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp);
   \   000000BE   0x4642             MOV      R2,R8
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0x210F             MOVS     R1,#+15
   \   000000C4   0x1E60             SUBS     R0,R4,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x.... 0x....      BL       BlackGetLeftStep2Win
    886                if(temp1 && temp2) 
   \   000000CC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D4   0xD01C             BEQ.N    ??BlackLeftAgainForCross_9
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD019             BEQ.N    ??BlackLeftAgainForCross_9
    887                {
    888                  temp = BlackLeftLoc[row - 1][0] + BlackLeftLoc[row - 1][0] - BlackLeftLoc[row][0];
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000000E4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2103             MOVS     R1,#+3
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000F4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000F8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000FC   0x1808             ADDS     R0,R1,R0
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2103             MOVS     R1,#+3
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000106   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000010A   0x7809             LDRB     R1,[R1, #+0]
   \   0000010C   0xEBB0 0x0801      SUBS     R8,R0,R1
    889                }
    890                //如果没能连续两行检测黑点成功，则不更新预测点位置，采用原位置。
    891                else
    892                {
    893                }       
    894                
    895                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackLeftAgainForCross_9:
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x42AC             CMP      R4,R5
   \   00000116   0xD004             BEQ.N    ??BlackLeftAgainForCross_10
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011C   0x1C68             ADDS     R0,R5,#+1
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD1C4             BNE.N    ??BlackLeftAgainForCross_8
    896              }
    897              
    898               //十字再检测第3阶段，脑补两段线的接线。
    899              if(!BlackLeftCrossStep3(Row1RealLastLine, Row2RealFirstLine))
   \                     ??BlackLeftAgainForCross_10:
   \   00000122   0x0039             MOVS     R1,R7
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x0030             MOVS     R0,R6
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x.... 0x....      BL       BlackLeftCrossStep3
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD101             BNE.N    ??BlackLeftAgainForCross_11
    900              {
    901                return 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE000             B.N      ??BlackLeftAgainForCross_3
    902              }
    903              
    904              return 1;
   \                     ??BlackLeftAgainForCross_11:
   \   00000136   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftAgainForCross_3:
   \   00000138   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    905                  
    906          }
    907          
    908          //======================================================================
    909          //函数名：BlackLeftStep4BackLine
    910          //功  能：左黑线提取中，第4阶段十字向后补线函数。
    911          //参  数：Step4StartLine开始行
    912          //返  回：1成功 0失败
    913          //影  响：BlackLeftLoc[][0]
    914          //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
    915          //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
    916          //             
    917          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    918          uint8 BlackLeftStep4BackLine(uint8 Step4StartLine)
    919          {
   \                     BlackLeftStep4BackLine:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    920            uint8 row;
    921            uint8 i, index;
    922            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
    923            uint8 y[BlackBackLineNum];
    924            uint8 j;
    925            
    926            float temp;
    927            float a0, a1;
    928            
    929            //取BlackBackLineNum个点作为最小二乘法的基准点。
    930            //以左上角为原点，向下为x轴正方向，向右为y轴正方向
    931            index = 0;
   \   00000004   0x2100             MOVS     R1,#+0
    932            for(i = Step4StartLine; ; i--)
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xE000             B.N      ??BlackLeftStep4BackLine_0
   \                     ??BlackLeftStep4BackLine_1:
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
    933            {
    934              if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??BlackLeftStep4BackLine_0:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable14
   \   00000014   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000018   0x7812             LDRB     R2,[R2, #+0]
   \   0000001A   0x2AFF             CMP      R2,#+255
   \   0000001C   0xD00D             BEQ.N    ??BlackLeftStep4BackLine_2
    935              {
    936                y[index] = BlackLeftLoc[i][0];
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2203             MOVS     R2,#+3
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable14
   \   00000026   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0xAB00             ADD      R3,SP,#+0
   \   00000030   0x54CA             STRB     R2,[R1, R3]
    937                x[index] = i;
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xAA01             ADD      R2,SP,#+4
   \   00000036   0x5488             STRB     R0,[R1, R2]
    938                index++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
    939              }
    940              if(index == BlackBackLineNum)
   \                     ??BlackLeftStep4BackLine_2:
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0x2904             CMP      R1,#+4
   \   0000003E   0xD10E             BNE.N    ??BlackLeftStep4BackLine_3
    941              {
    942                break;  
    943              }
    944              if(i == 0)
    945              {
    946                return 0;
    947              }
    948            }
    949            
    950            //最小二乘法
    951            //y = a0 + a1 * x
    952            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       LeastSquarea1
   \   0000004A   0x0006             MOVS     R6,R0
    953            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   0000004C   0x2304             MOVS     R3,#+4
   \   0000004E   0x0032             MOVS     R2,R6
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0xA801             ADD      R0,SP,#+4
   \   00000054   0x.... 0x....      BL       LeastSquarea0
   \   00000058   0x0005             MOVS     R5,R0
    954            
    955            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \   0000005C   0xE00E             B.N      ??BlackLeftStep4BackLine_4
   \                     ??BlackLeftStep4BackLine_3:
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1D2             BNE.N    ??BlackLeftStep4BackLine_1
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE03D             B.N      ??BlackLeftStep4BackLine_5
    956            {
    957              //补线也有个度，向左向右都不能补出范围。
    958              temp = a0 + a1 * row;
    959              if(temp >= CameraRealWidth)
    960              {
    961                //BlackLeftLoc[row][0] = CameraRealWidth - 1;
    962                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
    963                for(j = row; ; j++)
    964                {
    965                  BlackLeftLoc[row][0] = MaxValUint8;
    966                  if(j == CameraHight - 1) break;
    967                }
    968                break;
    969              }
    970              else if(temp <= 0)
    971              {
    972                //BlackLeftLoc[row][0] = 0;
    973                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
    974                for(j = row; ; j++)
    975                {
    976                  BlackLeftLoc[row][0] = MaxValUint8;
    977                  if(j == CameraHight - 1) break;
    978                }
    979                break;
    980              }
    981              else
    982              {
    983                BlackLeftLoc[row][0] = (uint8)(temp); 
   \                     ??BlackLeftStep4BackLine_6:
   \   00000068   0x.... 0x....      BL       __aeabi_f2iz
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x.... 0x....      LDR.W    R2,??DataTable14
   \   00000074   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000078   0x7008             STRB     R0,[R1, #+0]
    984              }
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackLeftStep4BackLine_4:
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2C32             CMP      R4,#+50
   \   00000080   0xD22F             BCS.N    ??BlackLeftStep4BackLine_7
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008A   0x0031             MOVS     R1,R6
   \   0000008C   0x.... 0x....      BL       __aeabi_fmul
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x.... 0x....      BL       __aeabi_fadd
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable18  ;; 0x437a0000
   \   0000009A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000009E   0xD80E             BHI.N    ??BlackLeftStep4BackLine_8
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0xE000             B.N      ??BlackLeftStep4BackLine_9
   \                     ??BlackLeftStep4BackLine_10:
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_9:
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2103             MOVS     R1,#+3
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000AE   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000B2   0x22FF             MOVS     R2,#+255
   \   000000B4   0x700A             STRB     R2,[R1, #+0]
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x2831             CMP      R0,#+49
   \   000000BA   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_10
   \   000000BC   0xE011             B.N      ??BlackLeftStep4BackLine_7
   \                     ??BlackLeftStep4BackLine_8:
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C4   0xD8D0             BHI.N    ??BlackLeftStep4BackLine_6
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xE000             B.N      ??BlackLeftStep4BackLine_11
   \                     ??BlackLeftStep4BackLine_12:
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackLeftStep4BackLine_11:
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2103             MOVS     R1,#+3
   \   000000D0   0x.... 0x....      LDR.W    R2,??DataTable14
   \   000000D4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000D8   0x22FF             MOVS     R2,#+255
   \   000000DA   0x700A             STRB     R2,[R1, #+0]
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x2831             CMP      R0,#+49
   \   000000E0   0xD1F3             BNE.N    ??BlackLeftStep4BackLine_12
    985            }
    986            
    987            return 1;
   \                     ??BlackLeftStep4BackLine_7:
   \   000000E2   0x2001             MOVS     R0,#+1
   \                     ??BlackLeftStep4BackLine_5:
   \   000000E4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    988            
    989          }
    990          
    991          
    992          
    993          
    994          //======================================================================
    995          //函数名：BlackGetLeft
    996          //功  能：左黑线提取算法
    997          //参  数：无
    998          //返  回：1成功 0失败
    999          //影  响：BlackLeftCrossDone，BlackLeftLoc[][],
   1000          //        BlackLeftRealWB[], BlackLeftRealW[], BlackLeftRealB[],
   1001          //        LimitLeftWB, LimitLeftW, LimitLeftB
   1002          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
   1003          //      
   1004          //             
   1005          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1006          uint8 BlackGetLeft(void)
   1007          {
   \                     BlackGetLeft:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   1008              uint8 row, temp, temp1, temp2, temp3, i;
   1009              uint8 GapCount, Row1RealLastLine, index;
   1010              uint8 Step4Flag, Step4StartLine;  
   1011              
   1012              //第4阶段进入标志。
   1013              Step4Flag = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1014              //默认十字检测标志置为未进入。
   1015              BlackLeftCrossDone = 0;    
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   1016              
   1017              //第1阶段。这1阶段有可能会返回黑线提取失败
   1018              temp = BlackGetLeftStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x210E             MOVS     R1,#+14
   \   00000012   0x2031             MOVS     R0,#+49
   \   00000014   0x.... 0x....      BL       BlackGetLeftStep1Scan
   \   00000018   0x0007             MOVS     R7,R0
   1019              if(temp == MaxValUint8)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2FFF             CMP      R7,#+255
   \   0000001E   0xD101             BNE.N    ??BlackGetLeft_0
   1020              {
   1021                return 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE13A             B.N      ??BlackGetLeft_1
   1022              }    
   1023              else 
   1024              {
   1025                row = temp;
   \                     ??BlackGetLeft_0:
   \   00000024   0x46BA             MOV      R10,R7
   1026                //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
   1027                if(row < CameraHight - BlackLeftBackLineStart)
   \   00000026   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002A   0xF1BA 0x0F2A      CMP      R10,#+42
   \   0000002E   0xD201             BCS.N    ??BlackGetLeft_2
   1028                {
   1029                  Step4Flag = 1;
   \   00000030   0x2501             MOVS     R5,#+1
   1030                  Step4StartLine = row;
   \   00000032   0x4656             MOV      R6,R10
   1031                }
   1032              }
   1033              
   1034              //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
   1035              //下面开始利用斜率找黑点。
   1036              //上次已经处理完了第row-1行，下一次要处理第row-2行
   1037              //BlackLeftSlope();
   1038              
   1039              //temp为预测的黑点位置
   1040          
   1041              //对预测值的大小限定
   1042              if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) < 0)
   \                     ??BlackGetLeft_2:
   \   00000034   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable12_5
   \   0000003C   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000040   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000044   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0x....             LDR.N    R2,??DataTable12_5
   \   0000004C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000050   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000054   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000058   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0x....             LDR.N    R2,??DataTable12_5
   \   00000060   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x1A40             SUBS     R0,R0,R1
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD501             BPL.N    ??BlackGetLeft_3
   1043              {
   1044                temp = 0;
   \   0000006C   0x2700             MOVS     R7,#+0
   \   0000006E   0xE036             B.N      ??BlackGetLeft_4
   1045              }
   1046              else if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) >= CameraRealWidth)
   \                     ??BlackGetLeft_3:
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x....             LDR.N    R1,??DataTable12_5
   \   00000078   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000007C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000080   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x....             LDR.N    R2,??DataTable12_5
   \   00000088   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000008C   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000090   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x....             LDR.N    R2,??DataTable12_5
   \   0000009C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x1A40             SUBS     R0,R0,R1
   \   000000A4   0x28FA             CMP      R0,#+250
   \   000000A6   0xDB01             BLT.N    ??BlackGetLeft_5
   1047              {
   1048                temp = CameraRealWidth - 1;
   \   000000A8   0x27F9             MOVS     R7,#+249
   \   000000AA   0xE018             B.N      ??BlackGetLeft_4
   1049              }
   1050              else
   1051              {
   1052                temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];  
   \                     ??BlackGetLeft_5:
   \   000000AC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x....             LDR.N    R1,??DataTable12_5
   \   000000B4   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000000B8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0x2103             MOVS     R1,#+3
   \   000000C2   0x....             LDR.N    R2,??DataTable12_5
   \   000000C4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000C8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D2   0x2103             MOVS     R1,#+3
   \   000000D4   0x....             LDR.N    R2,??DataTable12_5
   \   000000D6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x1A47             SUBS     R7,R0,R1
   1053              }
   1054          
   1055              index = 0;
   \                     ??BlackGetLeft_4:
   \   000000DE   0xF05F 0x0800      MOVS     R8,#+0
   1056              
   1057              GapCount = 0;  //连续多少行没有采集到黑线
   \   000000E2   0xF05F 0x0900      MOVS     R9,#+0
   1058              //从最近的认证行到取最远的行
   1059              for(row -= 2; ; row -= 2)
   \   000000E6   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   \   000000EA   0xE001             B.N      ??BlackGetLeft_6
   \                     ??BlackGetLeft_7:
   \   000000EC   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   1060              {
   1061                //如果连续两行的黑点检测成功，则更新预测点的位置
   1062                temp1 = BlackGetLeftStep2Win(row, BlackLeftWinVal, temp);
   \                     ??BlackGetLeft_6:
   \   000000F0   0x003A             MOVS     R2,R7
   \   000000F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F4   0x210F             MOVS     R1,#+15
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       BlackGetLeftStep2Win
   \   000000FE   0x4683             MOV      R11,R0
   1063                temp2 = BlackGetLeftStep2Win(row-1, BlackLeftWinVal, temp);
   \   00000100   0x003A             MOVS     R2,R7
   \   00000102   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000104   0x210F             MOVS     R1,#+15
   \   00000106   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x.... 0x....      BL       BlackGetLeftStep2Win
   1064                temp3 = (
   1065                        (!temp1)
   1066                      &&(!temp2)
   1067                      &&(!Step4Flag)
   1068                        );
   \   00000110   0xEA50 0x010B      ORRS     R1,R0,R11
   \   00000114   0x4329             ORRS     R1,R5,R1
   \   00000116   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000118   0x2900             CMP      R1,#+0
   \   0000011A   0xD101             BNE.N    ??BlackGetLeft_8
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0xE000             B.N      ??BlackGetLeft_9
   \                     ??BlackGetLeft_8:
   \   00000120   0x2100             MOVS     R1,#+0
   1069                if(temp1 && temp2) 
   \                     ??BlackGetLeft_9:
   \   00000122   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000126   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000012A   0xD058             BEQ.N    ??BlackGetLeft_10
   \   0000012C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD055             BEQ.N    ??BlackGetLeft_10
   1070                {   //对预测值的大小限定
   1071                    if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) < 0)
   \   00000132   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000136   0x2003             MOVS     R0,#+3
   \   00000138   0x....             LDR.N    R1,??DataTable12_5
   \   0000013A   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000013E   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000142   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000146   0x2103             MOVS     R1,#+3
   \   00000148   0x....             LDR.N    R2,??DataTable12_5
   \   0000014A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000014E   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000152   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000156   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015A   0x2103             MOVS     R1,#+3
   \   0000015C   0x....             LDR.N    R2,??DataTable12_5
   \   0000015E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000162   0x7809             LDRB     R1,[R1, #+0]
   \   00000164   0x1A40             SUBS     R0,R0,R1
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD501             BPL.N    ??BlackGetLeft_11
   1072                    {
   1073                      temp = 0;
   \   0000016A   0x2700             MOVS     R7,#+0
   \   0000016C   0xE07E             B.N      ??BlackGetLeft_12
   1074                    }
   1075                    else if((BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0]) >= CameraRealWidth)
   \                     ??BlackGetLeft_11:
   \   0000016E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000172   0x2003             MOVS     R0,#+3
   \   00000174   0x....             LDR.N    R1,??DataTable12_5
   \   00000176   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000017A   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000017E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000182   0x2103             MOVS     R1,#+3
   \   00000184   0x....             LDR.N    R2,??DataTable12_5
   \   00000186   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000018A   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   0000018E   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000192   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000196   0x2103             MOVS     R1,#+3
   \   00000198   0x....             LDR.N    R2,??DataTable12_5
   \   0000019A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000019E   0x7809             LDRB     R1,[R1, #+0]
   \   000001A0   0x1A40             SUBS     R0,R0,R1
   \   000001A2   0x28FA             CMP      R0,#+250
   \   000001A4   0xDB01             BLT.N    ??BlackGetLeft_13
   1076                    {
   1077                      temp = CameraRealWidth - 1;
   \   000001A6   0x27F9             MOVS     R7,#+249
   \   000001A8   0xE060             B.N      ??BlackGetLeft_12
   1078                    }
   1079                    else
   1080                    {
   1081                      temp = BlackLeftLoc[row-1][0] + BlackLeftLoc[row-1][0] - BlackLeftLoc[row][0];  
   \                     ??BlackGetLeft_13:
   \   000001AA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001AE   0x2003             MOVS     R0,#+3
   \   000001B0   0x....             LDR.N    R1,??DataTable12_5
   \   000001B2   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000001B6   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000001BA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001BE   0x2103             MOVS     R1,#+3
   \   000001C0   0x....             LDR.N    R2,??DataTable12_5
   \   000001C2   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001C6   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000001CA   0x1808             ADDS     R0,R1,R0
   \   000001CC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D0   0x2103             MOVS     R1,#+3
   \   000001D2   0x....             LDR.N    R2,??DataTable12_5
   \   000001D4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001D8   0x7809             LDRB     R1,[R1, #+0]
   \   000001DA   0x1A47             SUBS     R7,R0,R1
   \   000001DC   0xE046             B.N      ??BlackGetLeft_12
   1082                    }
   1083                }
   1084                //如果没能连续两行检测黑点成功，则不更新预测点位置，采用原位置。
   1085                //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
   1086                //如果第4阶段检测标志置位，就不用进入十字检测了。
   1087                else if(temp3)
   \                     ??BlackGetLeft_10:
   \   000001DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E0   0x2900             CMP      R1,#+0
   \   000001E2   0xD043             BEQ.N    ??BlackGetLeft_12
   1088                {       
   1089                  //Row1RealLastLine记录第1段黑线的最后一行。
   1090                  if(index == 0)
   \   000001E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001EC   0xD118             BNE.N    ??BlackGetLeft_14
   1091                  {
   1092                    //进来一次后，就再也不会进来了。
   1093                    index++;
   \   000001EE   0xF118 0x0801      ADDS     R8,R8,#+1
   1094                    for(i = row; i < (row + 5); i++)
   \   000001F2   0x4650             MOV      R0,R10
   \   000001F4   0xE000             B.N      ??BlackGetLeft_15
   \                     ??BlackGetLeft_16:
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetLeft_15:
   \   000001F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001FE   0xF11A 0x0105      ADDS     R1,R10,#+5
   \   00000202   0x4288             CMP      R0,R1
   \   00000204   0xDA08             BGE.N    ??BlackGetLeft_17
   1095                    {
   1096                      if(BlackLeftLoc[i][0] != MaxValUint8)
   \   00000206   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   0x2103             MOVS     R1,#+3
   \   0000020A   0x....             LDR.N    R2,??DataTable12_5
   \   0000020C   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000210   0x7809             LDRB     R1,[R1, #+0]
   \   00000212   0x29FF             CMP      R1,#+255
   \   00000214   0xD0EF             BEQ.N    ??BlackGetLeft_16
   1097                      {
   1098                        Row1RealLastLine = i;
   \   00000216   0x0004             MOVS     R4,R0
   1099                        break;
   1100                      }
   1101                    }
   1102                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetLeft_17:
   \   00000218   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021A   0x2C31             CMP      R4,#+49
   \   0000021C   0xD300             BCC.N    ??BlackGetLeft_14
   1103                    {
   1104                      Row1RealLastLine = CameraHight - 1;
   \   0000021E   0x2431             MOVS     R4,#+49
   1105                    }
   1106                    else
   1107                    {
   1108                    }
   1109                  }
   1110                  
   1111                  GapCount += 2;
   \                     ??BlackGetLeft_14:
   \   00000220   0xF119 0x0902      ADDS     R9,R9,#+2
   1112                  ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
   1113                  if(GapCount > BlackCrossGapLine)
   \   00000224   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000228   0xF1B9 0x0F0B      CMP      R9,#+11
   \   0000022C   0xD31A             BCC.N    ??BlackGetLeft_18
   1114                  {
   1115                    //再检测时的行太远了，就没必要检测了。
   1116                    if(row < BlackLeftCrossTooLowLine)
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable19_1
   \   00000232   0x7800             LDRB     R0,[R0, #+0]
   \   00000234   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000238   0x4582             CMP      R10,R0
   \   0000023A   0xD322             BCC.N    ??BlackGetLeft_19
   1117                    {
   1118                      break;
   1119                    }
   1120                    else
   1121                    {
   1122                    }
   1123                    
   1124                    //这个的行怎么取？？？？？？？？？？？？？？？
   1125                    if(!BlackLeftAgainForCross(row - 2, 1, Row1RealLastLine))
   \                     ??BlackGetLeft_20:
   \   0000023C   0x0022             MOVS     R2,R4
   \   0000023E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000240   0x2101             MOVS     R1,#+1
   \   00000242   0xF1BA 0x0002      SUBS     R0,R10,#+2
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x.... 0x....      BL       BlackLeftAgainForCross
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD104             BNE.N    ??BlackGetLeft_21
   1126                    {
   1127                      BlackLeftCrossDone = 1;  //十字检测失败           
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000254   0x2101             MOVS     R1,#+1
   \   00000256   0x7001             STRB     R1,[R0, #+0]
   \   00000258   0xE003             B.N      ??BlackGetLeft_22
   1128                    }
   1129                    else
   1130                    {
   1131                      BlackLeftCrossDone = 2;  //十字检测成功
   \                     ??BlackGetLeft_21:
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable19
   \   0000025E   0x2102             MOVS     R1,#+2
   \   00000260   0x7001             STRB     R1,[R0, #+0]
   1132                    }
   1133                    break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetLeft_22:
   \   00000262   0xE00E             B.N      ??BlackGetLeft_19
   1134                    
   1135                  }
   1136                  else
   1137                  {
   1138                    BlackLeftCrossDone = 0;   //十字检测未进入
   \                     ??BlackGetLeft_18:
   \   00000264   0x.... 0x....      LDR.W    R0,??DataTable19
   \   00000268   0x2100             MOVS     R1,#+0
   \   0000026A   0x7001             STRB     R1,[R0, #+0]
   1139                  }
   1140                }
   1141                else
   1142                {        
   1143                }
   1144                
   1145                
   1146                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetLeft_12:
   \   0000026C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000270   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000274   0xD005             BEQ.N    ??BlackGetLeft_23
   \   00000276   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000027A   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000027E   0xF47F 0xAF35      BNE.W    ??BlackGetLeft_7
   1147                
   1148              }
   1149              
   1150              
   1151              //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
   1152              //////////////////////////其实想想，向后补线有用吗，方便人看，但似乎对车没太大用。
   1153              if(Step4Flag)
   \                     ??BlackGetLeft_23:
   \                     ??BlackGetLeft_19:
   \   00000282   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000284   0x2D00             CMP      R5,#+0
   \   00000286   0xD007             BEQ.N    ??BlackGetLeft_24
   1154              {
   1155                if(!BlackLeftStep4BackLine(Step4StartLine))
   \   00000288   0x0030             MOVS     R0,R6
   \   0000028A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028C   0x.... 0x....      BL       BlackLeftStep4BackLine
   \   00000290   0x2800             CMP      R0,#+0
   \   00000292   0xD101             BNE.N    ??BlackGetLeft_24
   1156                {
   1157                  return 0;  
   \   00000294   0x2000             MOVS     R0,#+0
   \   00000296   0xE000             B.N      ??BlackGetLeft_1
   1158                }
   1159              }
   1160              
   1161              
   1162              return 1;
   \                     ??BlackGetLeft_24:
   \   00000298   0x2001             MOVS     R0,#+1
   \                     ??BlackGetLeft_1:
   \   0000029A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1163          }
   1164          
   1165          
   1166          
   1167          //====================================右右右右右右右右右右右右右右右右右============================
   1168          
   1169          
   1170          
   1171          //======================================================================
   1172          //函数名：BlackRightRealClear
   1173          //功  能：右黑线提取中，对3个关键值的实际值清零
   1174          //参  数：无
   1175          //返  回：无
   1176          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
   1177          //说  明：
   1178          //      
   1179          //             
   1180          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1181          void BlackRightRealClear(void)
   1182          {
   1183              BlackRightRealWB[0] = 0;
   \                     BlackRightRealClear:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
   1184              BlackRightRealWB[1] = 0;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
   1185              BlackRightRealW[0] = 0;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1186              BlackRightRealW[1] = 0;
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x7041             STRB     R1,[R0, #+1]
   1187              BlackRightRealB[0] = 0;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x7001             STRB     R1,[R0, #+0]
   1188              BlackRightRealB[1] = 0;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x7041             STRB     R1,[R0, #+1]
   1189          }
   \   00000030   0x4770             BX       LR               ;; return
   1190          
   1191          
   1192          
   1193          //======================================================================
   1194          //函数名：BlackGetRightStep1Edge
   1195          //功  能：右黑线提取中，第1阶段跳变检测函数,处理该右左线的可疑黑点
   1196          //参  数：待检测的行号row, 第几次使用use, 是否为十字再检测调用标志位CrossFlag
   1197          //返  回：1成功 0失败
   1198          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[]
   1199          //        BlackRightLoc[][]
   1200          //说  明：1. 对第row行的跳变向右进行检测，成功就赋相应的值（有3个备用值），失败则赋255
   1201          //        2. 两批条件均满足时。则检测成功。会有最多3个值进行记录，现阶段只用到了第1个值
   1202          //        3. 里面有涉及3个关键值的实际值的记录，CrossFlag的情况就不用记录（也就不用更改）
   1203          //        4. 若1个黑点也没有，或者超过3个黑点，则检测失败。
   1204          //        5. 若要检测黑到白的跳变，或者任意跳变，改变第一批条件即可。
   1205          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1206          uint8 BlackGetRightStep1Edge(uint8 row, uint8 use, uint8 CrossFlag)
   1207          {
   \                     BlackGetRightStep1Edge:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1208            uint8 index, col, temp1;
   1209            uint8 abs1;
   1210            uint8 RightBeginCol; //右线跳变检测起点
   1211            
   1212            //左黑线检测成功时
   1213            if(BlackLeftDone == 1)
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD11F             BNE.N    ??BlackGetRightStep1Edge_0
   1214            {
   1215                //右线跳变检测的起点至少要比该行左线的跳变点要靠右。
   1216              if(BlackLeftLoc[row][0] == MaxValUint8)
   \   00000014   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000001C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x28FF             CMP      R0,#+255
   \   00000024   0xD102             BNE.N    ??BlackGetRightStep1Edge_1
   1217              {
   1218                RightBeginCol = CameraRealWidth/2;
   \   00000026   0xF05F 0x087D      MOVS     R8,#+125
   \   0000002A   0xE015             B.N      ??BlackGetRightStep1Edge_2
   1219              }
   1220              else
   1221              {
   1222                //至少要在左跳变向右4+BlackRightEdgeNum个点
   1223                RightBeginCol = MaxRe(CameraRealWidth/2, BlackLeftLoc[row][0] + 4 + BlackRightEdgeNum);
   \                     ??BlackGetRightStep1Edge_1:
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000034   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x1D81             ADDS     R1,R0,#+6
   \   0000003C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003E   0x207D             MOVS     R0,#+125
   \   00000040   0x.... 0x....      BL       MaxRe
   \   00000044   0x4680             MOV      R8,R0
   1224                //同时，也不能超过数组界限219，其实是不能超过CameraRealWidth - 5 - BlackRightEdgeNum，下面for循环里。
   1225                RightBeginCol = MinRe(RightBeginCol, CameraRealWidth - 5 - BlackRightEdgeNum);
   \   00000046   0x21F3             MOVS     R1,#+243
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x.... 0x....      BL       MinRe
   \   00000050   0x4680             MOV      R8,R0
   \   00000052   0xE001             B.N      ??BlackGetRightStep1Edge_2
   1226              }
   1227            }
   1228            //左黑线检测失败时，右黑线检测的起点要比中心线靠左BlackRightEdgeStartColOffset这么多列。
   1229            else
   1230            {
   1231              RightBeginCol = CameraRealWidth/2 - BlackRightEdgeStartColOffset;  
   \                     ??BlackGetRightStep1Edge_0:
   \   00000054   0xF05F 0x084B      MOVS     R8,#+75
   1232            }
   1233            
   1234            index = 0;         //可疑点的序号
   \                     ??BlackGetRightStep1Edge_2:
   \   00000058   0x2700             MOVS     R7,#+0
   1235            //从中间到最右边扫描，隔1个点求差
   1236            for(col = RightBeginCol; col <= CameraRealWidth - 5 - BlackRightEdgeNum; col++) 
   \   0000005A   0xE043             B.N      ??BlackGetRightStep1Edge_3
   1237            {
   1238                abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col+1+BlackRightEdgeNum]);
   1239                if( //跳变沿的第一批条件：
   1240                    //黑够黑，白够白，差够大。
   1241                    //这里的3个阈值为初始值，不是自适应之后调整的值。
   1242                    (abs1 > LimitRightWB) //两者的差够大
   1243                  &&(ImgNew[row][col] > LimitRightW)                     //白点够白
   1244                  &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB) //黑点够黑
   1245                   )
   1246                {         
   1247                    //跳变沿的第二批条件：
   1248                    //近处的行，向右3个点仍为黑点
   1249                    if(row > BlackMiddleLine)
   1250                    {
   1251                      temp1 = (
   1252                                (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1253                              &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1254                              &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
   1255                              );
   1256                    }
   1257                    else
   1258                    {
   1259                      if(row > BlackFarLine)
   1260                      {
   1261                        //中间的行，向右2个点仍为黑点。
   1262                        temp1 = (
   1263                                  (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1264                                &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1265                                );
   1266                      }
   1267                      //远处的行，向右1个点仍为黑点。
   1268                      else
   1269                      {
   1270                        temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
   1271                      }
   1272                    }
   1273                    
   1274                    if(temp1)
   1275                    {
   1276                                      
   1277                        //超过3个可疑黑点，则报错
   1278                        if(index == 3)       
   1279                        {
   1280                          //如果是十字再检测的调用，就不用更新这几个值。
   1281                          if(CrossFlag)
   1282                          {
   1283                            //对3个关键值的实际值清零
   1284                            BlackRightRealClear();
   1285                          }
   1286                          //该行定位黑线失败，赋无效值
   1287                          BlackRightLoc[row][0] = MaxValUint8;
   1288                          return 0;
   1289                        }
   1290                        
   1291                        //如果是十字再检测的调用，就不用更新这几个值。
   1292                        if(CrossFlag)
   1293                        {
   1294                          //进入这里说明跳变沿的二批条件均满足，进入黑点记录阶段
   1295                          //记录3个关键值的实际信息，作为后面的参考。
   1296                          if(use == 1)
   1297                          {
   1298                            BlackRightRealWB[0] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   1299                            BlackRightRealW[0] = ImgNew[row][col];
   1300                            BlackRightRealB[0] = ImgNew[row][col+1+BlackRightEdgeNum];
   1301                          }
   1302                          else if(use == 2)
   \                     ??BlackGetRightStep1Edge_4:
   \   0000005C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005E   0x2D02             CMP      R5,#+2
   \   00000060   0xD133             BNE.N    ??BlackGetRightStep1Edge_5
   1303                          {
   1304                            BlackRightRealWB[1] = ImgNew[row][col] - ImgNew[row][col+1+BlackRightEdgeNum]; 
   \   00000062   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x20FA             MOVS     R0,#+250
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000006E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000072   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   00000076   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000007A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007C   0x21FA             MOVS     R1,#+250
   \   0000007E   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000082   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000086   0xEB18 0x0101      ADDS     R1,R8,R1
   \   0000008A   0x78C9             LDRB     R1,[R1, #+3]
   \   0000008C   0x1A40             SUBS     R0,R0,R1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000092   0x7048             STRB     R0,[R1, #+1]
   1305                            BlackRightRealW[1] = ImgNew[row][col];
   \   00000094   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000098   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009A   0x20FA             MOVS     R0,#+250
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000A0   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000A4   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000AC   0x7048             STRB     R0,[R1, #+1]
   1306                            BlackRightRealB[1] = ImgNew[row][col+1+BlackRightEdgeNum];
   \   000000AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B4   0x20FA             MOVS     R0,#+250
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000BA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000BE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000000C2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000C8   0x7048             STRB     R0,[R1, #+1]
   1307                          }
   1308                          else
   1309                          {
   1310                          }
   1311                        }
   1312                        //跳变检测成功，取黑点
   1313                        BlackRightLoc[row][index] = col + 1 + BlackRightEdgeNum;          
   \                     ??BlackGetRightStep1Edge_5:
   \   000000CA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2003             MOVS     R0,#+3
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000D4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000D8   0xF118 0x0103      ADDS     R1,R8,#+3
   \   000000DC   0x5439             STRB     R1,[R7, R0]
   1314                        index++;
   \   000000DE   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BlackGetRightStep1Edge_6:
   \   000000E0   0xF118 0x0801      ADDS     R8,R8,#+1
   \                     ??BlackGetRightStep1Edge_3:
   \   000000E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000E8   0xF1B8 0x0FF4      CMP      R8,#+244
   \   000000EC   0xF080 0x8100      BCS.W    ??BlackGetRightStep1Edge_7
   \   000000F0   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000F4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F6   0x20FA             MOVS     R0,#+250
   \   000000F8   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000FC   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000100   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000104   0x78C1             LDRB     R1,[R0, #+3]
   \   00000106   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000010A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000010C   0x20FA             MOVS     R0,#+250
   \   0000010E   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000112   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   00000116   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000011A   0x.... 0x....      BL       AbsRe
   \   0000011E   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000122   0x7809             LDRB     R1,[R1, #+0]
   \   00000124   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000126   0x4281             CMP      R1,R0
   \   00000128   0xD2DA             BCS.N    ??BlackGetRightStep1Edge_6
   \   0000012A   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   0000012E   0x7800             LDRB     R0,[R0, #+0]
   \   00000130   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000134   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000136   0x21FA             MOVS     R1,#+250
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   0000013C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000140   0xF818 0x1001      LDRB     R1,[R8, R1]
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD2CB             BCS.N    ??BlackGetRightStep1Edge_6
   \   00000148   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000014C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000014E   0x20FA             MOVS     R0,#+250
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000154   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000158   0xEB18 0x0000      ADDS     R0,R8,R0
   \   0000015C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000015E   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000162   0x7809             LDRB     R1,[R1, #+0]
   \   00000164   0x4288             CMP      R0,R1
   \   00000166   0xD2BB             BCS.N    ??BlackGetRightStep1Edge_6
   \   00000168   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016A   0x2C1F             CMP      R4,#+31
   \   0000016C   0xD333             BCC.N    ??BlackGetRightStep1Edge_8
   \   0000016E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000172   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000174   0x20FA             MOVS     R0,#+250
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000017A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000017E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000182   0x7900             LDRB     R0,[R0, #+4]
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000188   0x7809             LDRB     R1,[R1, #+0]
   \   0000018A   0x4288             CMP      R0,R1
   \   0000018C   0xD221             BCS.N    ??BlackGetRightStep1Edge_9
   \   0000018E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000192   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000194   0x20FA             MOVS     R0,#+250
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000019A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000019E   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001A2   0x7940             LDRB     R0,[R0, #+5]
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000001A8   0x7809             LDRB     R1,[R1, #+0]
   \   000001AA   0x4288             CMP      R0,R1
   \   000001AC   0xD211             BCS.N    ??BlackGetRightStep1Edge_9
   \   000001AE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001B2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001B4   0x20FA             MOVS     R0,#+250
   \   000001B6   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000001BA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001BE   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001C2   0x7980             LDRB     R0,[R0, #+6]
   \   000001C4   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000001C8   0x7809             LDRB     R1,[R1, #+0]
   \   000001CA   0x4288             CMP      R0,R1
   \   000001CC   0xD201             BCS.N    ??BlackGetRightStep1Edge_9
   \   000001CE   0x2001             MOVS     R0,#+1
   \   000001D0   0xE000             B.N      ??BlackGetRightStep1Edge_10
   \                     ??BlackGetRightStep1Edge_9:
   \   000001D2   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_10:
   \   000001D4   0xE039             B.N      ??BlackGetRightStep1Edge_11
   \                     ??BlackGetRightStep1Edge_8:
   \   000001D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001D8   0x2C15             CMP      R4,#+21
   \   000001DA   0xD323             BCC.N    ??BlackGetRightStep1Edge_12
   \   000001DC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000001E2   0x20FA             MOVS     R0,#+250
   \   000001E4   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000001E8   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000001EC   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000001F0   0x7900             LDRB     R0,[R0, #+4]
   \   000001F2   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000001F6   0x7809             LDRB     R1,[R1, #+0]
   \   000001F8   0x4288             CMP      R0,R1
   \   000001FA   0xD211             BCS.N    ??BlackGetRightStep1Edge_13
   \   000001FC   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000200   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000202   0x20FA             MOVS     R0,#+250
   \   00000204   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000208   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000020C   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000210   0x7940             LDRB     R0,[R0, #+5]
   \   00000212   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000216   0x7809             LDRB     R1,[R1, #+0]
   \   00000218   0x4288             CMP      R0,R1
   \   0000021A   0xD201             BCS.N    ??BlackGetRightStep1Edge_13
   \   0000021C   0x2001             MOVS     R0,#+1
   \   0000021E   0xE000             B.N      ??BlackGetRightStep1Edge_14
   \                     ??BlackGetRightStep1Edge_13:
   \   00000220   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_14:
   \   00000222   0xE012             B.N      ??BlackGetRightStep1Edge_11
   \                     ??BlackGetRightStep1Edge_12:
   \   00000224   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000228   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000022A   0x20FA             MOVS     R0,#+250
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000230   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000234   0xEB18 0x0000      ADDS     R0,R8,R0
   \   00000238   0x7900             LDRB     R0,[R0, #+4]
   \   0000023A   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   0000023E   0x7809             LDRB     R1,[R1, #+0]
   \   00000240   0x4288             CMP      R0,R1
   \   00000242   0xD201             BCS.N    ??BlackGetRightStep1Edge_15
   \   00000244   0x2001             MOVS     R0,#+1
   \   00000246   0xE000             B.N      ??BlackGetRightStep1Edge_16
   \                     ??BlackGetRightStep1Edge_15:
   \   00000248   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep1Edge_16:
   \                     ??BlackGetRightStep1Edge_11:
   \   0000024A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xF43F 0xAF47      BEQ.W    ??BlackGetRightStep1Edge_6
   \   00000252   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000254   0x2F03             CMP      R7,#+3
   \   00000256   0xD10E             BNE.N    ??BlackGetRightStep1Edge_17
   \   00000258   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000025A   0x2E00             CMP      R6,#+0
   \   0000025C   0xD001             BEQ.N    ??BlackGetRightStep1Edge_18
   \   0000025E   0x.... 0x....      BL       BlackRightRealClear
   \                     ??BlackGetRightStep1Edge_18:
   \   00000262   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000264   0x2003             MOVS     R0,#+3
   \   00000266   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000026A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000026E   0x21FF             MOVS     R1,#+255
   \   00000270   0x7001             STRB     R1,[R0, #+0]
   \   00000272   0x2000             MOVS     R0,#+0
   \   00000274   0xE04F             B.N      ??BlackGetRightStep1Edge_19
   \                     ??BlackGetRightStep1Edge_17:
   \   00000276   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000278   0x2E00             CMP      R6,#+0
   \   0000027A   0xF43F 0xAF26      BEQ.W    ??BlackGetRightStep1Edge_5
   \   0000027E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000280   0x2D01             CMP      R5,#+1
   \   00000282   0xF47F 0xAEEB      BNE.W    ??BlackGetRightStep1Edge_4
   \   00000286   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000028A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000028C   0x20FA             MOVS     R0,#+250
   \   0000028E   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000292   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000296   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   0000029A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000029E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002A0   0x21FA             MOVS     R1,#+250
   \   000002A2   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000002A6   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000002AA   0xEB18 0x0101      ADDS     R1,R8,R1
   \   000002AE   0x78C9             LDRB     R1,[R1, #+3]
   \   000002B0   0x1A40             SUBS     R0,R0,R1
   \   000002B2   0x.... 0x....      LDR.W    R1,??DataTable20
   \   000002B6   0x7008             STRB     R0,[R1, #+0]
   \   000002B8   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002BE   0x20FA             MOVS     R0,#+250
   \   000002C0   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000002C4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002C8   0xF818 0x0000      LDRB     R0,[R8, R0]
   \   000002CC   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000002D0   0x7008             STRB     R0,[R1, #+0]
   \   000002D2   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000002D6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000002D8   0x20FA             MOVS     R0,#+250
   \   000002DA   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000002DE   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000002E2   0xEB18 0x0000      ADDS     R0,R8,R0
   \   000002E6   0x78C0             LDRB     R0,[R0, #+3]
   \   000002E8   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000002EC   0x7008             STRB     R0,[R1, #+0]
   \   000002EE   0xE6EC             B.N      ??BlackGetRightStep1Edge_5
   1315                      
   1316                    }    //end of 跳变沿的第二批条件
   1317                }   //end of 跳变沿的第一批条件
   1318            }// end of 从中间到最左边扫描，隔1个点求差
   1319            
   1320            //1个可疑黑点也没有，则报错。
   1321            if(index == 0)
   \                     ??BlackGetRightStep1Edge_7:
   \   000002F0   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000002F2   0x2F00             CMP      R7,#+0
   \   000002F4   0xD10E             BNE.N    ??BlackGetRightStep1Edge_20
   1322            {
   1323              //如果是十字再检测的调用，就不用更新这几个值。
   1324              if(CrossFlag)
   \   000002F6   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000002F8   0x2E00             CMP      R6,#+0
   \   000002FA   0xD001             BEQ.N    ??BlackGetRightStep1Edge_21
   1325              {
   1326                //对3个关键值的实际值清零
   1327                BlackRightRealClear();
   \   000002FC   0x.... 0x....      BL       BlackRightRealClear
   1328              }
   1329              //该行定位黑线失败，赋无效值
   1330              BlackRightLoc[row][0] = MaxValUint8;
   \                     ??BlackGetRightStep1Edge_21:
   \   00000300   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000302   0x2003             MOVS     R0,#+3
   \   00000304   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000308   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000030C   0x21FF             MOVS     R1,#+255
   \   0000030E   0x7001             STRB     R1,[R0, #+0]
   1331              return 0;
   \   00000310   0x2000             MOVS     R0,#+0
   \   00000312   0xE000             B.N      ??BlackGetRightStep1Edge_19
   1332            }
   1333            
   1334            //没有报错，就会走到这里，黑点查找成功，会有1，2，3个黑点
   1335            return 1;
   \                     ??BlackGetRightStep1Edge_20:
   \   00000314   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRightStep1Edge_19:
   \   00000316   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1336          }
   1337          
   1338          
   1339          
   1340          //======================================================================
   1341          //函数名：BlackGetRightStep2Win
   1342          //功  能：右黑线提取中，第2阶段窗口内跳变检测函数
   1343          //参  数：待处理行号row, 窗口大小win, 预测的跳变点的位置predict
   1344          //返  回：1成功  0失败
   1345          //影  响：BlackRightLoc[][0]
   1346          //说  明：1. 满足两批条件，才能检测成功。只有一个点的记录。
   1347          //        2. 窗口内没有检测到，则检测失败。
   1348          //        3. 窗缩小可以减少一定的时间，但如果遇到斜率过大的情况，就有可能检测不到。     
   1349          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1350          uint8 BlackGetRightStep2Win(uint8 row, uint8 win, uint8 predict)
   1351          {
   \                     BlackGetRightStep2Win:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1352            uint8 col, temp, temp1;
   1353            uint8 abs1;
   1354          
   1355            //在规划好的窗口内，从左往右查找跳变沿
   1356            //防止溢出
   1357            //对右边界的限制 
   1358            if((predict + win) >= (CameraRealWidth - 5 - BlackRightEdgeNum)) 
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0xFA51 0xF082      UXTAB    R0,R1,R2
   \   0000000A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000C   0x28F3             CMP      R0,#+243
   \   0000000E   0xD301             BCC.N    ??BlackGetRightStep2Win_0
   1359            {
   1360              temp = CameraRealWidth - 5 - BlackRightEdgeNum;
   \   00000010   0x25F3             MOVS     R5,#+243
   \   00000012   0xE000             B.N      ??BlackGetRightStep2Win_1
   1361            }  
   1362            else
   1363            {
   1364              temp = predict + win;
   \                     ??BlackGetRightStep2Win_0:
   \   00000014   0x188D             ADDS     R5,R1,R2
   1365            }
   1366            //对左边界的限制
   1367            if(predict <= win)
   \                     ??BlackGetRightStep2Win_1:
   \   00000016   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x4291             CMP      R1,R2
   \   0000001C   0xD301             BCC.N    ??BlackGetRightStep2Win_2
   1368            {
   1369              col = 0;
   \   0000001E   0x2600             MOVS     R6,#+0
   \   00000020   0xE002             B.N      ??BlackGetRightStep2Win_3
   1370            }
   1371            else
   1372            {
   1373              col = predict - win;  
   \                     ??BlackGetRightStep2Win_2:
   \   00000022   0x1A56             SUBS     R6,R2,R1
   \   00000024   0xE000             B.N      ??BlackGetRightStep2Win_3
   1374            }
   1375             
   1376            for(; col < temp; col++) 
   \                     ??BlackGetRightStep2Win_4:
   \   00000026   0x1C76             ADDS     R6,R6,#+1
   \                     ??BlackGetRightStep2Win_3:
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000002C   0x42AE             CMP      R6,R5
   \   0000002E   0xF080 0x80A7      BCS.W    ??BlackGetRightStep2Win_5
   1377            {
   1378              abs1 = AbsRe(ImgNew[row][col], ImgNew[row][col+1+BlackRightEdgeNum]);
   \   00000032   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x20FA             MOVS     R0,#+250
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000003C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000040   0x1830             ADDS     R0,R6,R0
   \   00000042   0x78C1             LDRB     R1,[R0, #+3]
   \   00000044   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x20FA             MOVS     R0,#+250
   \   0000004A   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   0000004E   0xFB00 0x2004      MLA      R0,R0,R4,R2
   \   00000052   0x5C30             LDRB     R0,[R6, R0]
   \   00000054   0x.... 0x....      BL       AbsRe
   1379              if( //跳变沿的第一批条件：
   1380                  //黑够黑，白够白，差够大。
   1381                  //这里的3个阈值是自适应之后调整的值
   1382                    (abs1 > LimitRightWB) //两者的差够大
   1383                  &&(ImgNew[row][col] > LimitRightW)                     //白点够白
   1384                  &&(ImgNew[row][col+1+BlackRightEdgeNum] < LimitRightB)                   //黑点够黑
   1385                 )
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   0000005C   0x7809             LDRB     R1,[R1, #+0]
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x4281             CMP      R1,R0
   \   00000062   0xD2E0             BCS.N    ??BlackGetRightStep2Win_4
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x21FA             MOVS     R1,#+250
   \   00000070   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000074   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000078   0x5C71             LDRB     R1,[R6, R1]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD2D3             BCS.N    ??BlackGetRightStep2Win_4
   \   0000007E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000080   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000082   0x20FA             MOVS     R0,#+250
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000088   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000008C   0x1830             ADDS     R0,R6,R0
   \   0000008E   0x78C0             LDRB     R0,[R0, #+3]
   \   00000090   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000094   0x7809             LDRB     R1,[R1, #+0]
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD2C5             BCS.N    ??BlackGetRightStep2Win_4
   1386              {
   1387                  
   1388                    //近处的行，向右3个点仍为黑点
   1389                    if(row > BlackMiddleLine)
   \   0000009A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009C   0x2C1F             CMP      R4,#+31
   \   0000009E   0xD32D             BCC.N    ??BlackGetRightStep2Win_6
   1390                    {
   1391                      temp1 = (
   1392                                (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1393                              &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1394                              &&(ImgNew[row][col+4+BlackRightEdgeNum] < LimitRightB)
   1395                              );
   \   000000A0   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A2   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A4   0x20FA             MOVS     R0,#+250
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000AA   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000AE   0x1830             ADDS     R0,R6,R0
   \   000000B0   0x7900             LDRB     R0,[R0, #+4]
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000000B6   0x7809             LDRB     R1,[R1, #+0]
   \   000000B8   0x4288             CMP      R0,R1
   \   000000BA   0xD21D             BCS.N    ??BlackGetRightStep2Win_7
   \   000000BC   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000BE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000C0   0x20FA             MOVS     R0,#+250
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000C6   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000CA   0x1830             ADDS     R0,R6,R0
   \   000000CC   0x7940             LDRB     R0,[R0, #+5]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD20F             BCS.N    ??BlackGetRightStep2Win_7
   \   000000D8   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000DA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DC   0x20FA             MOVS     R0,#+250
   \   000000DE   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   000000E2   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E6   0x1830             ADDS     R0,R6,R0
   \   000000E8   0x7980             LDRB     R0,[R0, #+6]
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000000EE   0x7809             LDRB     R1,[R1, #+0]
   \   000000F0   0x4288             CMP      R0,R1
   \   000000F2   0xD201             BCS.N    ??BlackGetRightStep2Win_7
   \   000000F4   0x2001             MOVS     R0,#+1
   \   000000F6   0xE000             B.N      ??BlackGetRightStep2Win_8
   \                     ??BlackGetRightStep2Win_7:
   \   000000F8   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_8:
   \   000000FA   0xE033             B.N      ??BlackGetRightStep2Win_9
   1396                    }
   1397                    else
   1398                    {
   1399                      //中间的行 ，向右2个点为仍为黑点
   1400                      if(row > BlackFarLine)
   \                     ??BlackGetRightStep2Win_6:
   \   000000FC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FE   0x2C15             CMP      R4,#+21
   \   00000100   0xD31F             BCC.N    ??BlackGetRightStep2Win_10
   1401                      {
   1402                        temp1 = (
   1403                                  (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB)
   1404                                &&(ImgNew[row][col+3+BlackRightEdgeNum] < LimitRightB)
   1405                                );
   \   00000102   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000104   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000106   0x20FA             MOVS     R0,#+250
   \   00000108   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000010C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000110   0x1830             ADDS     R0,R6,R0
   \   00000112   0x7900             LDRB     R0,[R0, #+4]
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000118   0x7809             LDRB     R1,[R1, #+0]
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD20F             BCS.N    ??BlackGetRightStep2Win_11
   \   0000011E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000120   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000122   0x20FA             MOVS     R0,#+250
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000128   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000012C   0x1830             ADDS     R0,R6,R0
   \   0000012E   0x7940             LDRB     R0,[R0, #+5]
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000134   0x7809             LDRB     R1,[R1, #+0]
   \   00000136   0x4288             CMP      R0,R1
   \   00000138   0xD201             BCS.N    ??BlackGetRightStep2Win_11
   \   0000013A   0x2001             MOVS     R0,#+1
   \   0000013C   0xE000             B.N      ??BlackGetRightStep2Win_12
   \                     ??BlackGetRightStep2Win_11:
   \   0000013E   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_12:
   \   00000140   0xE010             B.N      ??BlackGetRightStep2Win_9
   1406                      }
   1407                      //远处的行，向右1个点仍为黑点
   1408                      else
   1409                      {
   1410                        temp1 = (ImgNew[row][col+2+BlackRightEdgeNum] < LimitRightB);
   \                     ??BlackGetRightStep2Win_10:
   \   00000142   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000144   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000146   0x20FA             MOVS     R0,#+250
   \   00000148   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000014C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000150   0x1830             ADDS     R0,R6,R0
   \   00000152   0x7900             LDRB     R0,[R0, #+4]
   \   00000154   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000158   0x7809             LDRB     R1,[R1, #+0]
   \   0000015A   0x4288             CMP      R0,R1
   \   0000015C   0xD201             BCS.N    ??BlackGetRightStep2Win_13
   \   0000015E   0x2001             MOVS     R0,#+1
   \   00000160   0xE000             B.N      ??BlackGetRightStep2Win_14
   \                     ??BlackGetRightStep2Win_13:
   \   00000162   0x2000             MOVS     R0,#+0
   1411                      }
   1412                    }
   1413                    
   1414                    //跳变沿的第二批条件：
   1415                    if(temp1)
   \                     ??BlackGetRightStep2Win_14:
   \                     ??BlackGetRightStep2Win_9:
   \   00000164   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xF43F 0xAF5D      BEQ.W    ??BlackGetRightStep2Win_4
   1416                    {
   1417                    //两批条件均满足，直接记录该点为黑线，返回即可
   1418                    BlackRightLoc[row][0] = col + 1 + BlackRightEdgeNum;
   \   0000016C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000016E   0x2003             MOVS     R0,#+3
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000174   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000178   0x1CF1             ADDS     R1,R6,#+3
   \   0000017A   0x7001             STRB     R1,[R0, #+0]
   1419                    return 1;
   \   0000017C   0x2001             MOVS     R0,#+1
   \   0000017E   0xE008             B.N      ??BlackGetRightStep2Win_15
   1420                    //break;               
   1421                    }// end of 跳变沿检测的第2批条件
   1422              }// end of 跳变沿检测的第1批条件
   1423              
   1424              
   1425              
   1426            }// end of for循环
   1427            
   1428            //如果一直到窗口最左边还没有找到跳变沿，
   1429            
   1430            BlackRightLoc[row][0] = MaxValUint8;   //该行的黑线位置记为无效值
   \                     ??BlackGetRightStep2Win_5:
   \   00000180   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000182   0x2003             MOVS     R0,#+3
   \   00000184   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000188   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000018C   0x21FF             MOVS     R1,#+255
   \   0000018E   0x7001             STRB     R1,[R0, #+0]
   1431            return 0;
   \   00000190   0x2000             MOVS     R0,#+0
   \                     ??BlackGetRightStep2Win_15:
   \   00000192   0xBD70             POP      {R4-R6,PC}       ;; return
   1432            
   1433          }
   1434          
   1435          
   1436          
   1437          //======================================================================
   1438          //函数名：BlackGetRightStep1Scan
   1439          //功  能：右黑线提取中，第1阶段的行扫描函数
   1440          //参  数：扫描起始行FirstLine, 扫描结束行LastLine, 十字再检测标志CrossFlag
   1441          //返  回：0~CameraHight - 1行数 255采集失败
   1442          //影  响：BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[], BlackRightLoc[][],
   1443          //        LimitRightWB, LimitRightW, LimitRightB
   1444          //说  明：1. 可用于正常地第1阶段行扫描，也可用于十字再检测时的行扫描
   1445          //        2. 正常第1阶段扫描时，会更改3个关键阈值的值。
   1446          //             
   1447          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1448          uint8 BlackGetRightStep1Scan(uint8 FirstLine, uint8 LastLine, uint8 CrossFlag)
   1449          {
   \                     BlackGetRightStep1Scan:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   \   00000006   0x0016             MOVS     R6,R2
   1450              uint8 row, temp1, temp2;
   1451              uint8 abs1;
   1452              uint8 tempWB, tempW, tempB;
   1453              
   1454            //最近的BlackStep1Size行用差值法找黑线
   1455              for(row = FirstLine; row > LastLine; row -= 2)
   \   00000008   0xE000             B.N      ??BlackGetRightStep1Scan_0
   \                     ??BlackGetRightStep1Scan_1:
   \   0000000A   0x1EAD             SUBS     R5,R5,#+2
   \                     ??BlackGetRightStep1Scan_0:
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0x42AC             CMP      R4,R5
   \   00000012   0xD270             BCS.N    ??BlackGetRightStep1Scan_2
   1456              {
   1457                //判断是否连续两行检测到跳变，可疑黑点有3个点，暂取其中一个
   1458                temp1 = BlackGetRightStep1Edge(row, 1, CrossFlag);
   \   00000014   0x0032             MOVS     R2,R6
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x0028             MOVS     R0,R5
   \   0000001C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001E   0x.... 0x....      BL       BlackGetRightStep1Edge
   \   00000022   0x0007             MOVS     R7,R0
   1459                temp2 = BlackGetRightStep1Edge(row-1, 2, CrossFlag);
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000028   0x2102             MOVS     R1,#+2
   \   0000002A   0x1E68             SUBS     R0,R5,#+1
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x.... 0x....      BL       BlackGetRightStep1Edge
   1460                if(temp1 && temp2)//这里可以这么写，不用嵌套if，因为&&的特点
   \   00000032   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000034   0x2F00             CMP      R7,#+0
   \   00000036   0xD0E8             BEQ.N    ??BlackGetRightStep1Scan_1
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD0E5             BEQ.N    ??BlackGetRightStep1Scan_1
   1461                {
   1462                  abs1 = AbsRe(BlackRightLoc[row-1][0], BlackRightLoc[row][0]);
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x2003             MOVS     R0,#+3
   \   00000042   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000046   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000004A   0x7801             LDRB     R1,[R0, #+0]
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0x2003             MOVS     R0,#+3
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   00000054   0xFB00 0x2005      MLA      R0,R0,R5,R2
   \   00000058   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000005C   0x.... 0x....      BL       AbsRe
   1463                  //进一步判断连续两行的黑点的间隔是否够小，且暂取第1个可疑黑点。
   1464                  if(abs1 < BlackRightStep1ScanMinus)
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0x2806             CMP      R0,#+6
   \   00000064   0xD2D1             BCS.N    ??BlackGetRightStep1Scan_1
   1465                  {
   1466                    //检测到了连续的黑线，停止差值法找跳变沿，节省时间，下面进入第2阶段                                     
   1467                    //如果不是十字再检测的情况，就更新一下实际的3个关键值，否则不更新。
   1468                    if(CrossFlag)
   \   00000066   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000068   0x2E00             CMP      R6,#+0
   \   0000006A   0xD044             BEQ.N    ??BlackGetRightStep1Scan_3
   1469                      {           
   1470                        //差值的处理，留有裕度，且有上下界。
   1471                        tempWB = (BlackRightRealWB[0] + BlackRightRealWB[1]) / 2 - LimitRightWBMargin; 
   \   0000006C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable20
   \   00000076   0x7849             LDRB     R1,[R1, #+1]
   \   00000078   0x1808             ADDS     R0,R1,R0
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000080   0x3814             SUBS     R0,R0,#+20
   1472                        if(tempWB < LimitRightWBMin) tempWB = LimitRightWBMin;
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x284B             CMP      R0,#+75
   \   00000086   0xD201             BCS.N    ??BlackGetRightStep1Scan_4
   \   00000088   0x204B             MOVS     R0,#+75
   \   0000008A   0xE003             B.N      ??BlackGetRightStep1Scan_5
   1473                        else if(tempWB > LimitRightWBMax) tempWB = LimitRightWBMax;
   \                     ??BlackGetRightStep1Scan_4:
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x286A             CMP      R0,#+106
   \   00000090   0xD300             BCC.N    ??BlackGetRightStep1Scan_5
   \   00000092   0x2069             MOVS     R0,#+105
   1474                        else ;
   1475                        LimitRightWB = tempWB;
   \                     ??BlackGetRightStep1Scan_5:
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000098   0x7008             STRB     R0,[R1, #+0]
   1476                        
   1477                        //白点的处理，留有裕度，且有上下界。
   1478                        tempW = (BlackRightRealW[0] + BlackRightRealW[1]) / 2 - LimitRightWMargin;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable20_1
   \   0000009E   0x7800             LDRB     R0,[R0, #+0]
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable20_1
   \   000000A4   0x7849             LDRB     R1,[R1, #+1]
   \   000000A6   0x1808             ADDS     R0,R1,R0
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000AE   0x381E             SUBS     R0,R0,#+30
   1479                        if(tempW < LimitRightWMin) tempW = LimitRightWMin;
   \   000000B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B2   0x2896             CMP      R0,#+150
   \   000000B4   0xD201             BCS.N    ??BlackGetRightStep1Scan_6
   \   000000B6   0x2096             MOVS     R0,#+150
   \   000000B8   0xE003             B.N      ??BlackGetRightStep1Scan_7
   1480                        else if(tempW > LimitRightWMax) tempW = LimitRightWMax;
   \                     ??BlackGetRightStep1Scan_6:
   \   000000BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BC   0x28C9             CMP      R0,#+201
   \   000000BE   0xD300             BCC.N    ??BlackGetRightStep1Scan_7
   \   000000C0   0x20C8             MOVS     R0,#+200
   1481                        else ;
   1482                        LimitRightW = tempW;
   \                     ??BlackGetRightStep1Scan_7:
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
   1483                        
   1484                        //黑点的处理，留有裕度，且有上下界。
   1485                        tempB = (BlackRightRealB[0] + BlackRightRealB[1]) / 2 + LimitRightBMargin;
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable21
   \   000000D2   0x7849             LDRB     R1,[R1, #+1]
   \   000000D4   0x1808             ADDS     R0,R1,R0
   \   000000D6   0x2102             MOVS     R1,#+2
   \   000000D8   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000DC   0x301E             ADDS     R0,R0,#+30
   1486                        if(tempB < LimitRightBMin) tempB = LimitRightBMin;
   \   000000DE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E0   0x2855             CMP      R0,#+85
   \   000000E2   0xD201             BCS.N    ??BlackGetRightStep1Scan_8
   \   000000E4   0x2055             MOVS     R0,#+85
   \   000000E6   0xE003             B.N      ??BlackGetRightStep1Scan_9
   1487                        else if(tempB > LimitRightBMax) tempB = LimitRightBMax;
   \                     ??BlackGetRightStep1Scan_8:
   \   000000E8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000EA   0x2865             CMP      R0,#+101
   \   000000EC   0xD300             BCC.N    ??BlackGetRightStep1Scan_9
   \   000000EE   0x2064             MOVS     R0,#+100
   1488                        else ;
   1489                        LimitRightB = tempB;           
   \                     ??BlackGetRightStep1Scan_9:
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
   1490                      }
   1491                    break;
   1492                  }
   1493                }      
   1494              }   
   1495              
   1496              //检测了BlackStep1Size行也没有检测到连续的黑线，说明黑线检测失败
   1497              if(row <= LastLine)
   \                     ??BlackGetRightStep1Scan_3:
   \                     ??BlackGetRightStep1Scan_2:
   \   000000F6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FA   0x42AC             CMP      R4,R5
   \   000000FC   0xD301             BCC.N    ??BlackGetRightStep1Scan_10
   1498                return MaxValUint8;
   \   000000FE   0x20FF             MOVS     R0,#+255
   \   00000100   0xE001             B.N      ??BlackGetRightStep1Scan_11
   1499              else
   1500                return row;
   \                     ??BlackGetRightStep1Scan_10:
   \   00000102   0x0028             MOVS     R0,R5
   \   00000104   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \                     ??BlackGetRightStep1Scan_11:
   \   00000106   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1501            
   1502          }
   1503          
   1504          
   1505          //======================================================================
   1506          //函数名：BlackRightCrossStep3
   1507          //功  能：右线提取中，十字检测第3阶段，脑补线函数
   1508          //参  数：第1段有效黑线的最后一行FirstLine， 第2段有效黑线的第一行LastLine
   1509          //返  回：1成功 0失败
   1510          //影  响：BlackRightLoc[][0]
   1511          //说  明：1. 这里有一些浮点运算，会占时间，在调用本函数时要慎重，尽量不要用。
   1512          //        2. 这里的两点间连线的思路很不错，float强转和uint8强转用得很好。
   1513          //             
   1514          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1515          uint8 BlackRightCrossStep3(uint8 FirstLine, uint8 LastLine)
   1516          {
   \                     BlackRightCrossStep3:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   1517            float delta_x, delta_y, delta, index;
   1518            uint8 row, temp1, temp2;
   1519            //uint8 temp3, temp4, flag1, flag2;
   1520            
   1521            //超始行比结束行还高，报错！
   1522            if(LastLine >= FirstLine)
   \   00000008   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000000A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000C   0x42A7             CMP      R7,R4
   \   0000000E   0xD308             BCC.N    ??BlackRightCrossStep3_0
   1523            {
   1524              uart_sendN(UART0, (uint8 *)"\nError In BlackRightCrossStep3!", 31);
   \   00000010   0x221F             MOVS     R2,#+31
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable21_5
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable21_6  ;; 0x4006a000
   \   0000001A   0x.... 0x....      BL       uart_sendN
   1525              return 0;  
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE0A7             B.N      ??BlackRightCrossStep3_1
   1526            }
   1527            
   1528            temp1 = BlackRightLoc[FirstLine][0];
   \                     ??BlackRightCrossStep3_0:
   \   00000022   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000002A   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000002E   0x7805             LDRB     R5,[R0, #+0]
   1529            temp2 = BlackRightLoc[LastLine][0];
   \   00000030   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000032   0x2003             MOVS     R0,#+3
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000038   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   0000003C   0xF890 0x8000      LDRB     R8,[R0, #+0]
   1530            
   1531            /*
   1532            flag1 = 1;
   1533            flag2 = 1;
   1534            //确认这两个点是直角处的点，也就是往右6个点仍为黑点
   1535            if(temp1 <= (CameraRealWidth - 9))
   1536            {
   1537              temp3 = (
   1538                      (ImgNew[FirstLine+1][temp1+6] < LimitRightB)
   1539                    &&(ImgNew[FirstLine+1][temp1+7] < LimitRightB)
   1540                    &&(ImgNew[FirstLine+1][temp1+8] < LimitRightB)
   1541                    );
   1542              if(temp3)
   1543              {
   1544                flag1 = 0;  
   1545              }
   1546            }
   1547            
   1548            if(temp2 <= (CameraRealWidth - 9))
   1549            {
   1550              temp4 = (
   1551                      (ImgNew[LastLine-1][temp2+6] < LimitRightB)
   1552                    &&(ImgNew[LastLine-1][temp2+7] < LimitRightB)
   1553                    &&(ImgNew[LastLine-1][temp2+8] < LimitRightB)
   1554                    );
   1555              if(temp4)
   1556              {
   1557                flag2 = 0;  
   1558              }
   1559            }
   1560            
   1561            if((flag1 == 0) || (flag2 == 0))
   1562            {
   1563              return 0;  
   1564            }
   1565            
   1566            */
   1567            
   1568            delta_y = FirstLine - LastLine;
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000044   0x1BE0             SUBS     R0,R4,R7
   \   00000046   0x.... 0x....      BL       __aeabi_i2f
   \   0000004A   0x0006             MOVS     R6,R0
   1569            
   1570            
   1571            //斜率向右
   1572            if(temp1 < temp2)
   \   0000004C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0x4545             CMP      R5,R8
   \   00000054   0xD23B             BCS.N    ??BlackRightCrossStep3_2
   1573            {
   1574              delta_x = temp2 - temp1;
   \   00000056   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000005A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005C   0xEBB8 0x0005      SUBS     R0,R8,R5
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   1575              delta = delta_x / delta_y; //这是1个浮点数
   \   00000064   0x0031             MOVS     R1,R6
   \   00000066   0x.... 0x....      BL       __aeabi_fdiv
   \   0000006A   0x0005             MOVS     R5,R0
   1576              
   1577              index = 1.0;
   \   0000006C   0xF05F 0x587E      MOVS     R8,#+1065353216
   1578              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   00000070   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackRightCrossStep3_3:
   \   00000072   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000074   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000076   0x1C78             ADDS     R0,R7,#+1
   \   00000078   0x4286             CMP      R6,R0
   \   0000007A   0xDB79             BLT.N    ??BlackRightCrossStep3_4
   1579              {
   1580                //每次右移一点点
   1581                BlackRightLoc[row][0] = (uint8)((float)BlackRightLoc[FirstLine][0] + delta * index);
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2003             MOVS     R0,#+3
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000084   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000088   0x7800             LDRB     R0,[R0, #+0]
   \   0000008A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x4641             MOV      R1,R8
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4649             MOV      R1,R9
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x.... 0x....      BL       __aeabi_f2iz
   \   000000A2   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000A4   0x2103             MOVS     R1,#+3
   \   000000A6   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   000000AA   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
   1582                index += 1.0;
   \   000000B0   0x4640             MOV      R0,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x0002             MOVS     R2,R0
   \   000000B8   0x000B             MOVS     R3,R1
   \   000000BA   0x2000             MOVS     R0,#+0
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable21_7  ;; 0x3ff00000
   \   000000C0   0x.... 0x....      BL       __aeabi_dadd
   \   000000C4   0x.... 0x....      BL       __aeabi_d2f
   \   000000C8   0x4680             MOV      R8,R0
   1583              }
   \   000000CA   0x1E76             SUBS     R6,R6,#+1
   \   000000CC   0xE7D1             B.N      ??BlackRightCrossStep3_3
   1584            }
   1585            //斜率向左
   1586            else if(temp1 > temp2)
   \                     ??BlackRightCrossStep3_2:
   \   000000CE   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D4   0x45A8             CMP      R8,R5
   \   000000D6   0xD23C             BCS.N    ??BlackRightCrossStep3_5
   1587            {
   1588              delta_x = temp1 - temp2;
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000DE   0xEBB5 0x0008      SUBS     R0,R5,R8
   \   000000E2   0x.... 0x....      BL       __aeabi_i2f
   1589              delta = delta_x / delta_y;
   \   000000E6   0x0031             MOVS     R1,R6
   \   000000E8   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EC   0x0005             MOVS     R5,R0
   1590              
   1591              index = 1.0;
   \   000000EE   0xF05F 0x587E      MOVS     R8,#+1065353216
   1592              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \   000000F2   0x1E66             SUBS     R6,R4,#+1
   \                     ??BlackRightCrossStep3_6:
   \   000000F4   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   000000F6   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000000F8   0x1C78             ADDS     R0,R7,#+1
   \   000000FA   0x4286             CMP      R6,R0
   \   000000FC   0xDB38             BLT.N    ??BlackRightCrossStep3_4
   1593              {
   1594                //每次右移一点点
   1595                BlackRightLoc[row][0] = (uint8)((float)BlackRightLoc[FirstLine][0] - delta * index);
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000106   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000110   0x4681             MOV      R9,R0
   \   00000112   0x0028             MOVS     R0,R5
   \   00000114   0x4641             MOV      R1,R8
   \   00000116   0x.... 0x....      BL       __aeabi_fmul
   \   0000011A   0x0001             MOVS     R1,R0
   \   0000011C   0x4648             MOV      R0,R9
   \   0000011E   0x.... 0x....      BL       __aeabi_fsub
   \   00000122   0x.... 0x....      BL       __aeabi_f2iz
   \   00000126   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000128   0x2103             MOVS     R1,#+3
   \   0000012A   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   0000012E   0xFB01 0x2106      MLA      R1,R1,R6,R2
   \   00000132   0x7008             STRB     R0,[R1, #+0]
   1596                index += 1.0;
   \   00000134   0x4640             MOV      R0,R8
   \   00000136   0x.... 0x....      BL       __aeabi_f2d
   \   0000013A   0x0002             MOVS     R2,R0
   \   0000013C   0x000B             MOVS     R3,R1
   \   0000013E   0x2000             MOVS     R0,#+0
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable21_7  ;; 0x3ff00000
   \   00000144   0x.... 0x....      BL       __aeabi_dadd
   \   00000148   0x.... 0x....      BL       __aeabi_d2f
   \   0000014C   0x4680             MOV      R8,R0
   1597              }
   \   0000014E   0x1E76             SUBS     R6,R6,#+1
   \   00000150   0xE7D0             B.N      ??BlackRightCrossStep3_6
   1598            }
   1599            //斜率直走，这个不太可能出现
   1600            else
   1601            {
   1602              for(row = FirstLine - 1; row >= LastLine + 1; row-- )
   \                     ??BlackRightCrossStep3_5:
   \   00000152   0x1E66             SUBS     R6,R4,#+1
   \   00000154   0xE007             B.N      ??BlackRightCrossStep3_7
   1603              {
   1604                //赋相同的值
   1605                BlackRightLoc[row][0] = temp1;
   \                     ??BlackRightCrossStep3_8:
   \   00000156   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000158   0x2003             MOVS     R0,#+3
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000015E   0xFB00 0x1006      MLA      R0,R0,R6,R1
   \   00000162   0x7005             STRB     R5,[R0, #+0]
   1606              }
   \   00000164   0x1E76             SUBS     R6,R6,#+1
   \                     ??BlackRightCrossStep3_7:
   \   00000166   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000168   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000016A   0x1C78             ADDS     R0,R7,#+1
   \   0000016C   0x4286             CMP      R6,R0
   \   0000016E   0xDAF2             BGE.N    ??BlackRightCrossStep3_8
   1607            }
   1608            
   1609            return 1;
   \                     ??BlackRightCrossStep3_4:
   \   00000170   0x2001             MOVS     R0,#+1
   \                     ??BlackRightCrossStep3_1:
   \   00000172   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1610              
   1611          }
   1612          
   1613          //======================================================================
   1614          //函数名：BlackRightCrossConfirm
   1615          //功  能：十字再检测时 ，线头有效性的确认。
   1616          //参  数：第1段黑线的真实结束行Row1RealLastLine，第2段黑线的真实起始行Row2RealFirstLine
   1617          //返  回：1成功 0失败
   1618          //影  响：无
   1619          //说  明：1. 为了应对270度弯道十字误检测而诞生，编写过程中没有过多考虑其它情况。
   1620          //      
   1621          //             
   1622          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1623          uint8 BlackRightCrossConfirm(uint8 Row1RealLastLine, uint8 Row2RealFirstLine)
   1624          {
   \                     BlackRightCrossConfirm:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x000C             MOVS     R4,R1
   1625            uint8 row, index;
   1626            uint8 x[BlackCrossConfirmNum];
   1627            uint8 y[BlackCrossConfirmNum];
   1628            
   1629            float a0, a1, temp;
   1630            
   1631            //第一段黑线太短，无法检测正确性。直接返回1.
   1632            if(Row1RealLastLine < 5) return 1;
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x2805             CMP      R0,#+5
   \   00000008   0xD201             BCS.N    ??BlackRightCrossConfirm_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE043             B.N      ??BlackRightCrossConfirm_1
   1633            
   1634            //以左上角为原点，向下为x轴正方向（0~49），向右为y轴正方向(0~249)
   1635            index = 0;
   \                     ??BlackRightCrossConfirm_0:
   \   0000000E   0x2100             MOVS     R1,#+0
   1636            for(row = Row1RealLastLine; ; row++)
   \   00000010   0xE000             B.N      ??BlackRightCrossConfirm_2
   \                     ??BlackRightCrossConfirm_3:
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   1637            {
   1638              //有效行的记录
   1639              if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??BlackRightCrossConfirm_2:
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0x2203             MOVS     R2,#+3
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable21_1
   \   0000001C   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000020   0x7812             LDRB     R2,[R2, #+0]
   \   00000022   0x2AFF             CMP      R2,#+255
   \   00000024   0xD00D             BEQ.N    ??BlackRightCrossConfirm_4
   1640              {
   1641                y[index] = BlackRightLoc[row][0];
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2203             MOVS     R2,#+3
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable21_1
   \   0000002E   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000032   0x7812             LDRB     R2,[R2, #+0]
   \   00000034   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0x54CA             STRB     R2,[R1, R3]
   1642                x[index] = row;
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0xAA01             ADD      R2,SP,#+4
   \   0000003E   0x5488             STRB     R0,[R1, R2]
   1643                index++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
   1644              }
   1645              //点数够多，则跳出。
   1646              if(index == BlackCrossConfirmNum) break;
   \                     ??BlackRightCrossConfirm_4:
   \   00000042   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000044   0x2903             CMP      R1,#+3
   \   00000046   0xD120             BNE.N    ??BlackRightCrossConfirm_5
   1647              //直到最低行仍没有凑够足够的点数，说明第一段有效黑线太短，无法检测正确性，直接返回1.
   1648              if(row == CameraHight - 1) return 1;
   1649            }
   1650            
   1651            //最小二乘法
   1652            //y = a0 + a1 * x
   1653            a1 = LeastSquarea1(x, y, BlackCrossConfirmNum);
   \   00000048   0x2203             MOVS     R2,#+3
   \   0000004A   0xA900             ADD      R1,SP,#+0
   \   0000004C   0xA801             ADD      R0,SP,#+4
   \   0000004E   0x.... 0x....      BL       LeastSquarea1
   \   00000052   0x0006             MOVS     R6,R0
   1654            a0 = LeastSquarea0(x, y, a1, BlackCrossConfirmNum);
   \   00000054   0x2303             MOVS     R3,#+3
   \   00000056   0x0032             MOVS     R2,R6
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0xA801             ADD      R0,SP,#+4
   \   0000005C   0x.... 0x....      BL       LeastSquarea0
   \   00000060   0x0005             MOVS     R5,R0
   1655            
   1656            //temp为第2段黑线起始行本应该在的位置。
   1657            temp = a0 + a1 * Row2RealFirstLine;
   \   00000062   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0x.... 0x....      BL       __aeabi_ui2f
   \   0000006A   0x0031             MOVS     R1,R6
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x0029             MOVS     R1,R5
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   1658            //如果这个位置本来就超出了左右边界的范围，那说明不可能有第2段黑线存在了。
   1659            //也就不用检测第2段黑线了，直接返回0.
   1660            if((temp < 0) || (temp > CameraRealWidth - 1)) 
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xD303             BCC.N    ??BlackRightCrossConfirm_6
   \   0000007E   0x....             LDR.N    R1,??DataTable17  ;; 0x43790001
   \   00000080   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000084   0xD806             BHI.N    ??BlackRightCrossConfirm_7
   1661            {
   1662              return 0;
   \                     ??BlackRightCrossConfirm_6:
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE005             B.N      ??BlackRightCrossConfirm_1
   1663            }
   \                     ??BlackRightCrossConfirm_5:
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x2831             CMP      R0,#+49
   \   0000008E   0xD1C0             BNE.N    ??BlackRightCrossConfirm_3
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0xE000             B.N      ??BlackRightCrossConfirm_1
   1664            else
   1665            { //这里本来应该加上把这个点限定在窗内，但是似乎没必要。
   1666              //if(
   1667              //  (BlackRightLoc[Row2RealFirstLine][0] > temp - BlackCrossConfirmWin) 
   1668              //&&(BlackRightLoc[Row2RealFirstLine][0] < temp + BlackCrossConfirmWin)
   1669              //  )
   1670              return 1;
   \                     ??BlackRightCrossConfirm_7:
   \   00000094   0x2001             MOVS     R0,#+1
   \                     ??BlackRightCrossConfirm_1:
   \   00000096   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1671            }  
   1672          }
   1673          
   1674          
   1675          //======================================================================
   1676          //函数名：BlackRightAgainForCross
   1677          //功  能：右黑线提取中，针对十字的再检测程序
   1678          //参  数：第2段黑线的预测起始行Row2FirstLine， 第2段黑线的预测结束行Row2LastLine，
   1679          //        第1段黑线的实际结束行Row1RealLastLine
   1680          //返  回：1成功 0失败
   1681          //影  响：BlackRightLoc[][]。 （不会影响那几个阈值。）
   1682          //说  明：1. 本函数会调用浮点运算的函数，预计花费较多时间，调用入口需谨慎。
   1683          //        2. 本函数仅影响了BlackRightLoc[][]，以后也应该保持。
   1684          //             
   1685          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1686          uint8 BlackRightAgainForCross(uint8 Row2FirstLine, uint8 Row2LastLine, uint8 Row1RealLastLine)
   1687          {
   \                     BlackRightAgainForCross:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1688              uint8 row, temp, temp1, temp2;
   1689              uint8 Row2RealFirstLine; //第2段黑线的真实起始行
   1690              uint8 i;
   1691              
   1692              //十字再检测第1阶段，找线头。
   1693              temp = BlackGetRightStep1Scan(Row2FirstLine, Row2LastLine, 0); //第3个参数0表示是十字再检测，不用更新3个关键值
   \   0000000A   0x2200             MOVS     R2,#+0
   \   0000000C   0x0029             MOVS     R1,R5
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       BlackGetRightStep1Scan
   \   00000018   0x4680             MOV      R8,R0
   1694              if(temp == MaxValUint8)  
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0FFF      CMP      R8,#+255
   \   00000022   0xD10E             BNE.N    ??BlackRightAgainForCross_0
   1695              {
   1696                //扫屁股工作。        //i >= Row2LastLine
   1697                for(i = Row2FirstLine; ; i--)
   \   00000024   0xE000             B.N      ??BlackRightAgainForCross_1
   \                     ??BlackRightAgainForCross_2:
   \   00000026   0x1E64             SUBS     R4,R4,#+1
   1698                {
   1699                  BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_1:
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000030   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000034   0x21FF             MOVS     R1,#+255
   \   00000036   0x7001             STRB     R1,[R0, #+0]
   1700                  if(i == 0) break;
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD1F3             BNE.N    ??BlackRightAgainForCross_2
   1701                }
   1702                return 0;  
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE07A             B.N      ??BlackRightAgainForCross_3
   1703              }
   1704              else 
   1705              {
   1706                ////////////////如果要注释，就从这里开始注释
   1707                //十字再检测的线头不在限定的范围内，认为是干扰点，不用顺着线头找线了，直接退出。
   1708                if(!BlackRightCrossConfirm(Row1RealLastLine, temp))
   \                     ??BlackRightAgainForCross_0:
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000046   0x0030             MOVS     R0,R6
   \   00000048   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004A   0x.... 0x....      BL       BlackRightCrossConfirm
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD10E             BNE.N    ??BlackRightAgainForCross_4
   1709                { //扫屁股工作。         //i >= (temp-1)
   1710                  for(i = Row2FirstLine; ; i--)
   \   00000052   0xE000             B.N      ??BlackRightAgainForCross_5
   \                     ??BlackRightAgainForCross_6:
   \   00000054   0x1E64             SUBS     R4,R4,#+1
   1711                  {
   1712                    BlackRightLoc[i][0] = MaxValUint8;
   \                     ??BlackRightAgainForCross_5:
   \   00000056   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000058   0x2003             MOVS     R0,#+3
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000005E   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000062   0x21FF             MOVS     R1,#+255
   \   00000064   0x7001             STRB     R1,[R0, #+0]
   1713                    if(i == 0) break;
   \   00000066   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000068   0x2C00             CMP      R4,#+0
   \   0000006A   0xD1F3             BNE.N    ??BlackRightAgainForCross_6
   1714                  }
   1715                  return 0;
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xE063             B.N      ??BlackRightAgainForCross_3
   1716                }
   1717                //十字再检测的线头的确在限定的范围内，可以继续。
   1718                else
   1719                {
   1720                row = temp;
   \                     ??BlackRightAgainForCross_4:
   \   00000070   0x4644             MOV      R4,R8
   1721                }
   1722                ////////////////如果要注释，就从这里结束注释
   1723                
   1724                //暂时不用confirm函数，如果要用的话 ，就把后面这句话去掉，前面注释去掉。
   1725                //row = temp;
   1726              }
   1727              
   1728              Row2RealFirstLine = row; //记录第2段黑线的真实起始行
   \   00000072   0x0027             MOVS     R7,R4
   1729              
   1730              //十字再检测第2阶段，顺着线头找线。
   1731              //temp为预测的黑点位置
   1732              temp = BlackRightLoc[row-1][0] + BlackRightLoc[row-1][0] - BlackRightLoc[row][0];
   \   00000074   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000076   0x2003             MOVS     R0,#+3
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000007C   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   00000080   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000084   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000086   0x2103             MOVS     R1,#+3
   \   00000088   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   0000008C   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000090   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000094   0x1808             ADDS     R0,R1,R0
   \   00000096   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   0000009E   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000A2   0x7809             LDRB     R1,[R1, #+0]
   \   000000A4   0xEBB0 0x0801      SUBS     R8,R0,R1
   1733              //从最近的认证行到取最远的行
   1734              for(row -= 2; ; row -= 2)
   \   000000A8   0x1EA4             SUBS     R4,R4,#+2
   \   000000AA   0xE000             B.N      ??BlackRightAgainForCross_7
   \                     ??BlackRightAgainForCross_8:
   \   000000AC   0x1EA4             SUBS     R4,R4,#+2
   1735              {
   1736                //如果连续两行的黑点检测成功，则更新预测点的位置
   1737                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp);
   \                     ??BlackRightAgainForCross_7:
   \   000000AE   0x4642             MOV      R2,R8
   \   000000B0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000B2   0x210F             MOVS     R1,#+15
   \   000000B4   0x0020             MOVS     R0,R4
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x.... 0x....      BL       BlackGetRightStep2Win
   \   000000BC   0x4681             MOV      R9,R0
   1738                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp);
   \   000000BE   0x4642             MOV      R2,R8
   \   000000C0   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000C2   0x210F             MOVS     R1,#+15
   \   000000C4   0x1E60             SUBS     R0,R4,#+1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x.... 0x....      BL       BlackGetRightStep2Win
   1739                if(temp1 && temp2) 
   \   000000CC   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000D0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000000D4   0xD01C             BEQ.N    ??BlackRightAgainForCross_9
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD019             BEQ.N    ??BlackRightAgainForCross_9
   1740                {
   1741                  temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \   000000DC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000DE   0x2003             MOVS     R0,#+3
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   000000E4   0xFB00 0x1004      MLA      R0,R0,R4,R1
   \   000000E8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000EC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000EE   0x2103             MOVS     R1,#+3
   \   000000F0   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   000000F4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000F8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000FC   0x1808             ADDS     R0,R1,R0
   \   000000FE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000100   0x2103             MOVS     R1,#+3
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   00000106   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   0000010A   0x7809             LDRB     R1,[R1, #+0]
   \   0000010C   0xEBB0 0x0801      SUBS     R8,R0,R1
   1742                }
   1743                //如果没能连续两行检测黑点成功，则不更新预测点位置，采用原位置。
   1744                else
   1745                {
   1746                }       
   1747                
   1748                if((row == Row2LastLine) || (row == Row2LastLine+1)) break;      
   \                     ??BlackRightAgainForCross_9:
   \   00000110   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000112   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000114   0x42AC             CMP      R4,R5
   \   00000116   0xD004             BEQ.N    ??BlackRightAgainForCross_10
   \   00000118   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000011A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011C   0x1C68             ADDS     R0,R5,#+1
   \   0000011E   0x4284             CMP      R4,R0
   \   00000120   0xD1C4             BNE.N    ??BlackRightAgainForCross_8
   1749              }
   1750              
   1751              //十字再检测第3阶段，脑补两段线的接线。
   1752              if(!BlackRightCrossStep3(Row1RealLastLine, Row2RealFirstLine))
   \                     ??BlackRightAgainForCross_10:
   \   00000122   0x0039             MOVS     R1,R7
   \   00000124   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000126   0x0030             MOVS     R0,R6
   \   00000128   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012A   0x.... 0x....      BL       BlackRightCrossStep3
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD101             BNE.N    ??BlackRightAgainForCross_11
   1753              {
   1754                return 0;
   \   00000132   0x2000             MOVS     R0,#+0
   \   00000134   0xE000             B.N      ??BlackRightAgainForCross_3
   1755              }
   1756              
   1757              return 1;
   \                     ??BlackRightAgainForCross_11:
   \   00000136   0x2001             MOVS     R0,#+1
   \                     ??BlackRightAgainForCross_3:
   \   00000138   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1758                  
   1759          }
   1760          
   1761          
   1762          //======================================================================
   1763          //函数名：BlackRightStep4BackLine
   1764          //功  能：右黑线提取中，第4阶段十字向后补线函数。
   1765          //参  数：Step4StartLine开始行
   1766          //返  回：1成功 0失败
   1767          //影  响：BlackRightLoc[][0]
   1768          //说  明：1. 这里引用了float型的函数，有可能占用较长的时间。
   1769          //        2. 想要减少时间，可以把宏定义BlackBackLineNum减至3或者2.
   1770          //             
   1771          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1772          uint8 BlackRightStep4BackLine(uint8 Step4StartLine)
   1773          {
   \                     BlackRightStep4BackLine:
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1774            uint8 row;
   1775            uint8 i, index;
   1776            uint8 x[BlackBackLineNum];   //取多少个点在一开始有定义。
   1777            uint8 y[BlackBackLineNum];
   1778            uint8 j;
   1779            float temp;
   1780              
   1781            float a0, a1;
   1782            
   1783            //取BlackBackLineNum个点作为最小二乘法的基准点。
   1784            //以左上角为原点，向下为x轴正方向，向右为y轴正方向
   1785            index = 0;
   \   00000004   0x2100             MOVS     R1,#+0
   1786            for(i = Step4StartLine; ; i--)
   \   00000006   0x0020             MOVS     R0,R4
   \   00000008   0xE000             B.N      ??BlackRightStep4BackLine_0
   \                     ??BlackRightStep4BackLine_1:
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   1787            {
   1788              if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??BlackRightStep4BackLine_0:
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2203             MOVS     R2,#+3
   \   00000010   0x.... 0x....      LDR.W    R3,??DataTable21_1
   \   00000014   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000018   0x7812             LDRB     R2,[R2, #+0]
   \   0000001A   0x2AFF             CMP      R2,#+255
   \   0000001C   0xD00D             BEQ.N    ??BlackRightStep4BackLine_2
   1789              {
   1790                y[index] = BlackRightLoc[i][0];
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x2203             MOVS     R2,#+3
   \   00000022   0x.... 0x....      LDR.W    R3,??DataTable21_1
   \   00000026   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   0000002A   0x7812             LDRB     R2,[R2, #+0]
   \   0000002C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002E   0xAB00             ADD      R3,SP,#+0
   \   00000030   0x54CA             STRB     R2,[R1, R3]
   1791                x[index] = i;
   \   00000032   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000034   0xAA01             ADD      R2,SP,#+4
   \   00000036   0x5488             STRB     R0,[R1, R2]
   1792                index++;
   \   00000038   0x1C49             ADDS     R1,R1,#+1
   1793              }
   1794              if(index == BlackBackLineNum)
   \                     ??BlackRightStep4BackLine_2:
   \   0000003A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000003C   0x2904             CMP      R1,#+4
   \   0000003E   0xD10E             BNE.N    ??BlackRightStep4BackLine_3
   1795              {
   1796                break;  
   1797              }
   1798              if(i == 0)
   1799              {
   1800                return 0;
   1801              }
   1802            }
   1803            
   1804            //最小二乘法
   1805            //y = a0 + a1 * x
   1806            a1 = LeastSquarea1(x, y, BlackBackLineNum);
   \   00000040   0x2204             MOVS     R2,#+4
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0xA801             ADD      R0,SP,#+4
   \   00000046   0x.... 0x....      BL       LeastSquarea1
   \   0000004A   0x0006             MOVS     R6,R0
   1807            a0 = LeastSquarea0(x, y, a1, BlackBackLineNum);
   \   0000004C   0x2304             MOVS     R3,#+4
   \   0000004E   0x0032             MOVS     R2,R6
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0xA801             ADD      R0,SP,#+4
   \   00000054   0x.... 0x....      BL       LeastSquarea0
   \   00000058   0x0005             MOVS     R5,R0
   1808            
   1809            for(row = Step4StartLine + 1; row <= CameraHight - 1; row++)
   \   0000005A   0x1C64             ADDS     R4,R4,#+1
   \   0000005C   0xE00E             B.N      ??BlackRightStep4BackLine_4
   \                     ??BlackRightStep4BackLine_3:
   \   0000005E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1D2             BNE.N    ??BlackRightStep4BackLine_1
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xE03D             B.N      ??BlackRightStep4BackLine_5
   1810            {
   1811              //补线也有个度，向右和向左都不能补出范围。
   1812              temp = a0 + a1 * row;
   1813              if(temp > CameraRealWidth)
   1814              {
   1815                //BlackRightLoc[row][0] = CameraRealWidth - 1;
   1816                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。
   1817                for(j = row; ; j++)
   1818                {
   1819                  BlackRightLoc[row][0] = MaxValUint8;
   1820                  if(j == CameraHight - 1) break;
   1821                }
   1822                break;
   1823              }
   1824              else if(temp < 0)
   1825              {
   1826                //BlackRightLoc[row][0] = 0;
   1827                //超过左右界限时，原策略为置边界值，现在的策略是从该行起置无效值。我
   1828                for(j = row; ; j++)
   1829                {
   1830                  BlackRightLoc[row][0] = MaxValUint8;
   1831                  if(j == CameraHight - 1) break;
   1832                }
   1833                break;
   1834              }
   1835              else
   1836              {
   1837                BlackRightLoc[row][0] = (uint8)(temp); 
   \                     ??BlackRightStep4BackLine_6:
   \   00000068   0x.... 0x....      BL       __aeabi_f2iz
   \   0000006C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006E   0x2103             MOVS     R1,#+3
   \   00000070   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   00000074   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   00000078   0x7008             STRB     R0,[R1, #+0]
   1838              }
   \   0000007A   0x1C64             ADDS     R4,R4,#+1
   \                     ??BlackRightStep4BackLine_4:
   \   0000007C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000007E   0x2C32             CMP      R4,#+50
   \   00000080   0xD22F             BCS.N    ??BlackRightStep4BackLine_7
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x0020             MOVS     R0,R4
   \   00000086   0x.... 0x....      BL       __aeabi_ui2f
   \   0000008A   0x0031             MOVS     R1,R6
   \   0000008C   0x.... 0x....      BL       __aeabi_fmul
   \   00000090   0x0029             MOVS     R1,R5
   \   00000092   0x.... 0x....      BL       __aeabi_fadd
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable24  ;; 0x437a0001
   \   0000009A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000009E   0xD80E             BHI.N    ??BlackRightStep4BackLine_8
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0xE000             B.N      ??BlackRightStep4BackLine_9
   \                     ??BlackRightStep4BackLine_10:
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_9:
   \   000000A6   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A8   0x2103             MOVS     R1,#+3
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   000000AE   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000B2   0x22FF             MOVS     R2,#+255
   \   000000B4   0x700A             STRB     R2,[R1, #+0]
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x2831             CMP      R0,#+49
   \   000000BA   0xD1F3             BNE.N    ??BlackRightStep4BackLine_10
   \   000000BC   0xE011             B.N      ??BlackRightStep4BackLine_7
   \                     ??BlackRightStep4BackLine_8:
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C4   0xD2D0             BCS.N    ??BlackRightStep4BackLine_6
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xE000             B.N      ??BlackRightStep4BackLine_11
   \                     ??BlackRightStep4BackLine_12:
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackRightStep4BackLine_11:
   \   000000CC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000CE   0x2103             MOVS     R1,#+3
   \   000000D0   0x.... 0x....      LDR.W    R2,??DataTable21_1
   \   000000D4   0xFB01 0x2104      MLA      R1,R1,R4,R2
   \   000000D8   0x22FF             MOVS     R2,#+255
   \   000000DA   0x700A             STRB     R2,[R1, #+0]
   \   000000DC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DE   0x2831             CMP      R0,#+49
   \   000000E0   0xD1F3             BNE.N    ??BlackRightStep4BackLine_12
   1839            }
   1840            
   1841            return 1;
   \                     ??BlackRightStep4BackLine_7:
   \   000000E2   0x2001             MOVS     R0,#+1
   \                     ??BlackRightStep4BackLine_5:
   \   000000E4   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1842            
   1843          }
   1844          
   1845          
   1846          //======================================================================
   1847          //函数名：BlackGetRight
   1848          //功  能：右黑线提取算法
   1849          //参  数：无
   1850          //返  回：1成功 0失败
   1851          //影  响：BlackRightCrossDone，BlackRightLoc[][],
   1852          //        BlackRightRealWB[], BlackRightRealW[], BlackRightRealB[],
   1853          //        LimitRightWB, LimitRightW, LimitRightB
   1854          //说  明：1. 暂时可以处理直道，弯道，十字路口3种情况。2014.11.10
   1855          //      
   1856          //       
   1857          //       
   1858          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   1859          uint8 BlackGetRight(void)
   1860          {
   \                     BlackGetRight:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   1861              uint8 row, temp, temp1, temp2, temp3, i;
   1862              uint8 GapCount, Row1RealLastLine, index;
   1863              uint8 Step4Flag, Step4StartLine;
   1864              
   1865              //第4阶段进入标志。
   1866              Step4Flag = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1867          
   1868              //默认十字检测标志置为未进入。
   1869              BlackRightCrossDone = 0;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   1870              
   1871              
   1872              //第1阶段。这1阶段有可能会返回黑线提取失败
   1873              temp = BlackGetRightStep1Scan(CameraHight - 1, CameraHight - BlackStep1Size - 1, 1);
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x210E             MOVS     R1,#+14
   \   00000012   0x2031             MOVS     R0,#+49
   \   00000014   0x.... 0x....      BL       BlackGetRightStep1Scan
   \   00000018   0x0007             MOVS     R7,R0
   1874              if(temp == MaxValUint8)
   \   0000001A   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   0000001C   0x2FFF             CMP      R7,#+255
   \   0000001E   0xD101             BNE.N    ??BlackGetRight_0
   1875              {
   1876                return 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE13A             B.N      ??BlackGetRight_1
   1877              }
   1878              else
   1879              {
   1880                row = temp;
   \                     ??BlackGetRight_0:
   \   00000024   0x46BA             MOV      R10,R7
   1881                //如果起始线头的位置非常高，就认为是十字的前两个角，需要进入第4阶段向后补线。    
   1882                if(row < CameraHight - BlackRightBackLineStart)
   \   00000026   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002A   0xF1BA 0x0F2A      CMP      R10,#+42
   \   0000002E   0xD201             BCS.N    ??BlackGetRight_2
   1883                {
   1884                  Step4Flag = 1;
   \   00000030   0x2501             MOVS     R5,#+1
   1885                  Step4StartLine = row;
   \   00000032   0x4656             MOV      R6,R10
   1886                }
   1887          
   1888              }
   1889              
   1890              
   1891              //第2阶段。到了这一阶段，已经不会返回黑线提取失败 
   1892              //下面开始利用斜率找黑点。
   1893              //上次已经处理完了第row-1行，下一次要处理第row-2行
   1894              //BlackRightSlope();
   1895              
   1896              //temp为预测的黑点位置
   1897              //对预测值进行限定。
   1898              if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) < 0)
   \                     ??BlackGetRight_2:
   \   00000034   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000038   0x2003             MOVS     R0,#+3
   \   0000003A   0x....             LDR.N    R1,??DataTable21_1
   \   0000003C   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   00000040   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000044   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000048   0x2103             MOVS     R1,#+3
   \   0000004A   0x....             LDR.N    R2,??DataTable21_1
   \   0000004C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000050   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000054   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000058   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000005C   0x2103             MOVS     R1,#+3
   \   0000005E   0x....             LDR.N    R2,??DataTable21_1
   \   00000060   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000064   0x7809             LDRB     R1,[R1, #+0]
   \   00000066   0x1A40             SUBS     R0,R0,R1
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD501             BPL.N    ??BlackGetRight_3
   1899              {
   1900                temp = 0;
   \   0000006C   0x2700             MOVS     R7,#+0
   \   0000006E   0xE036             B.N      ??BlackGetRight_4
   1901              }
   1902              else if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) >= CameraRealWidth) 
   \                     ??BlackGetRight_3:
   \   00000070   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000074   0x2003             MOVS     R0,#+3
   \   00000076   0x....             LDR.N    R1,??DataTable21_1
   \   00000078   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000007C   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000080   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000084   0x2103             MOVS     R1,#+3
   \   00000086   0x....             LDR.N    R2,??DataTable21_1
   \   00000088   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000008C   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000090   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000094   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000098   0x2103             MOVS     R1,#+3
   \   0000009A   0x....             LDR.N    R2,??DataTable21_1
   \   0000009C   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0x1A40             SUBS     R0,R0,R1
   \   000000A4   0x28FA             CMP      R0,#+250
   \   000000A6   0xDB01             BLT.N    ??BlackGetRight_5
   1903              {         
   1904                temp = CameraRealWidth - 1; 
   \   000000A8   0x27F9             MOVS     R7,#+249
   \   000000AA   0xE018             B.N      ??BlackGetRight_4
   1905              }
   1906              else
   1907              {
   1908                temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \                     ??BlackGetRight_5:
   \   000000AC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000B0   0x2003             MOVS     R0,#+3
   \   000000B2   0x....             LDR.N    R1,??DataTable21_1
   \   000000B4   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000000B8   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000000BC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000C0   0x2103             MOVS     R1,#+3
   \   000000C2   0x....             LDR.N    R2,??DataTable21_1
   \   000000C4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000C8   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000000D2   0x2103             MOVS     R1,#+3
   \   000000D4   0x....             LDR.N    R2,??DataTable21_1
   \   000000D6   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000000DA   0x7809             LDRB     R1,[R1, #+0]
   \   000000DC   0x1A47             SUBS     R7,R0,R1
   1909              }
   1910              
   1911              index = 0;
   \                     ??BlackGetRight_4:
   \   000000DE   0xF05F 0x0800      MOVS     R8,#+0
   1912              
   1913              GapCount = 0;  //连续多少行没有采到黑线
   \   000000E2   0xF05F 0x0900      MOVS     R9,#+0
   1914              //从最近的认证行到取最远的行
   1915              for(row -= 2; ; row -= 2)
   \   000000E6   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   \   000000EA   0xE001             B.N      ??BlackGetRight_6
   \                     ??BlackGetRight_7:
   \   000000EC   0xF1BA 0x0A02      SUBS     R10,R10,#+2
   1916              {
   1917                //如果连续两行的黑点检测成功，则更新预测点的位置
   1918                temp1 = BlackGetRightStep2Win(row, BlackRightWinVal, temp);
   \                     ??BlackGetRight_6:
   \   000000F0   0x003A             MOVS     R2,R7
   \   000000F2   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000000F4   0x210F             MOVS     R1,#+15
   \   000000F6   0x4650             MOV      R0,R10
   \   000000F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FA   0x.... 0x....      BL       BlackGetRightStep2Win
   \   000000FE   0x4683             MOV      R11,R0
   1919                temp2 = BlackGetRightStep2Win(row-1, BlackRightWinVal, temp);
   \   00000100   0x003A             MOVS     R2,R7
   \   00000102   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000104   0x210F             MOVS     R1,#+15
   \   00000106   0xF1BA 0x0001      SUBS     R0,R10,#+1
   \   0000010A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000010C   0x.... 0x....      BL       BlackGetRightStep2Win
   1920                temp3 = (
   1921                        (!temp1)
   1922                      &&(!temp2)
   1923                      &&(!Step4Flag)
   1924                        );
   \   00000110   0xEA50 0x010B      ORRS     R1,R0,R11
   \   00000114   0x4329             ORRS     R1,R5,R1
   \   00000116   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000118   0x2900             CMP      R1,#+0
   \   0000011A   0xD101             BNE.N    ??BlackGetRight_8
   \   0000011C   0x2101             MOVS     R1,#+1
   \   0000011E   0xE000             B.N      ??BlackGetRight_9
   \                     ??BlackGetRight_8:
   \   00000120   0x2100             MOVS     R1,#+0
   1925                if(temp1 && temp2) 
   \                     ??BlackGetRight_9:
   \   00000122   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000126   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000012A   0xD058             BEQ.N    ??BlackGetRight_10
   \   0000012C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD055             BEQ.N    ??BlackGetRight_10
   1926                {
   1927                  //对预测值进行限定。
   1928                  if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) < 0)
   \   00000132   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000136   0x2003             MOVS     R0,#+3
   \   00000138   0x....             LDR.N    R1,??DataTable21_1
   \   0000013A   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000013E   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   00000142   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000146   0x2103             MOVS     R1,#+3
   \   00000148   0x....             LDR.N    R2,??DataTable21_1
   \   0000014A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000014E   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   00000152   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000156   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000015A   0x2103             MOVS     R1,#+3
   \   0000015C   0x....             LDR.N    R2,??DataTable21_1
   \   0000015E   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   00000162   0x7809             LDRB     R1,[R1, #+0]
   \   00000164   0x1A40             SUBS     R0,R0,R1
   \   00000166   0x2800             CMP      R0,#+0
   \   00000168   0xD501             BPL.N    ??BlackGetRight_11
   1929                  {
   1930                    temp = 0;
   \   0000016A   0x2700             MOVS     R7,#+0
   \   0000016C   0xE07E             B.N      ??BlackGetRight_12
   1931                  }
   1932                  else if((BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0]) >= CameraRealWidth) 
   \                     ??BlackGetRight_11:
   \   0000016E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000172   0x2003             MOVS     R0,#+3
   \   00000174   0x....             LDR.N    R1,??DataTable21_1
   \   00000176   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   0000017A   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   0000017E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000182   0x2103             MOVS     R1,#+3
   \   00000184   0x....             LDR.N    R2,??DataTable21_1
   \   00000186   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000018A   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   0000018E   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000192   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000196   0x2103             MOVS     R1,#+3
   \   00000198   0x....             LDR.N    R2,??DataTable21_1
   \   0000019A   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   0000019E   0x7809             LDRB     R1,[R1, #+0]
   \   000001A0   0x1A40             SUBS     R0,R0,R1
   \   000001A2   0x28FA             CMP      R0,#+250
   \   000001A4   0xDB01             BLT.N    ??BlackGetRight_13
   1933                  {         
   1934                    temp = CameraRealWidth - 1; 
   \   000001A6   0x27F9             MOVS     R7,#+249
   \   000001A8   0xE060             B.N      ??BlackGetRight_12
   1935                  }
   1936                  else
   1937                  {
   1938                    temp = BlackRightLoc[row - 1][0] + BlackRightLoc[row - 1][0] - BlackRightLoc[row][0];
   \                     ??BlackGetRight_13:
   \   000001AA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001AE   0x2003             MOVS     R0,#+3
   \   000001B0   0x....             LDR.N    R1,??DataTable21_1
   \   000001B2   0xFB00 0x100A      MLA      R0,R0,R10,R1
   \   000001B6   0xF810 0x0C03      LDRB     R0,[R0, #-3]
   \   000001BA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001BE   0x2103             MOVS     R1,#+3
   \   000001C0   0x....             LDR.N    R2,??DataTable21_1
   \   000001C2   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001C6   0xF811 0x1C03      LDRB     R1,[R1, #-3]
   \   000001CA   0x1808             ADDS     R0,R1,R0
   \   000001CC   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001D0   0x2103             MOVS     R1,#+3
   \   000001D2   0x....             LDR.N    R2,??DataTable21_1
   \   000001D4   0xFB01 0x210A      MLA      R1,R1,R10,R2
   \   000001D8   0x7809             LDRB     R1,[R1, #+0]
   \   000001DA   0x1A47             SUBS     R7,R0,R1
   \   000001DC   0xE046             B.N      ??BlackGetRight_12
   1939                  }
   1940                }
   1941                //如果没能连续两行检测黑点成功，则不更新预测点位置，采用原位置。
   1942                //如果连续两行均采集黑线失败，则记数，记到一定值就再来一次Step1
   1943                //如果第4阶段检测标志置位，就不用进入十字检测了。
   1944                else if(temp3)
   \                     ??BlackGetRight_10:
   \   000001DE   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000001E0   0x2900             CMP      R1,#+0
   \   000001E2   0xD043             BEQ.N    ??BlackGetRight_12
   1945                {       
   1946                  //Row1RealLastLine记录第1段黑线的最后一行。
   1947                  if(index == 0)
   \   000001E4   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000001E8   0xF1B8 0x0F00      CMP      R8,#+0
   \   000001EC   0xD118             BNE.N    ??BlackGetRight_14
   1948                  {
   1949                    //进来一次后，就再也不会进来了。
   1950                    index++;
   \   000001EE   0xF118 0x0801      ADDS     R8,R8,#+1
   1951                    for(i = row; i < (row + 5); i++)
   \   000001F2   0x4650             MOV      R0,R10
   \   000001F4   0xE000             B.N      ??BlackGetRight_15
   \                     ??BlackGetRight_16:
   \   000001F6   0x1C40             ADDS     R0,R0,#+1
   \                     ??BlackGetRight_15:
   \   000001F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001FA   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   000001FE   0xF11A 0x0105      ADDS     R1,R10,#+5
   \   00000202   0x4288             CMP      R0,R1
   \   00000204   0xDA08             BGE.N    ??BlackGetRight_17
   1952                    {
   1953                      if(BlackRightLoc[i][0] != MaxValUint8)
   \   00000206   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000208   0x2103             MOVS     R1,#+3
   \   0000020A   0x....             LDR.N    R2,??DataTable21_1
   \   0000020C   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000210   0x7809             LDRB     R1,[R1, #+0]
   \   00000212   0x29FF             CMP      R1,#+255
   \   00000214   0xD0EF             BEQ.N    ??BlackGetRight_16
   1954                      {
   1955                        Row1RealLastLine = i;
   \   00000216   0x0004             MOVS     R4,R0
   1956                        break;
   1957                      }
   1958                    }
   1959                    if(Row1RealLastLine >= CameraHight - 1)
   \                     ??BlackGetRight_17:
   \   00000218   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000021A   0x2C31             CMP      R4,#+49
   \   0000021C   0xD300             BCC.N    ??BlackGetRight_14
   1960                    {
   1961                      Row1RealLastLine = CameraHight - 1;
   \   0000021E   0x2431             MOVS     R4,#+49
   1962                    }
   1963                    else
   1964                    {
   1965                    }
   1966                  }
   1967                  
   1968                  GapCount += 2;
   \                     ??BlackGetRight_14:
   \   00000220   0xF119 0x0902      ADDS     R9,R9,#+2
   1969                  ///////////////////////////////进入十字重新检测的条件还要再严格一些，减少没必要的时间，比如说前面最多只允许检测到多少行。
   1970                  if(GapCount > BlackCrossGapLine)
   \   00000224   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000228   0xF1B9 0x0F0B      CMP      R9,#+11
   \   0000022C   0xD31A             BCC.N    ??BlackGetRight_18
   1971                  {
   1972                    //再检测时的行太远了，就没必要检测了。
   1973                    if(row < BlackRightCrossTooLowLine)
   \   0000022E   0x.... 0x....      LDR.W    R0,??DataTable26
   \   00000232   0x7800             LDRB     R0,[R0, #+0]
   \   00000234   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000238   0x4582             CMP      R10,R0
   \   0000023A   0xD322             BCC.N    ??BlackGetRight_19
   1974                    {
   1975                      break;
   1976                    }
   1977                    else
   1978                    {
   1979                    }
   1980                    
   1981                    //这个的行怎么取？？？？？？？？？？？？？？？
   1982                    if(!BlackRightAgainForCross(row - 2, 1, Row1RealLastLine))
   \                     ??BlackGetRight_20:
   \   0000023C   0x0022             MOVS     R2,R4
   \   0000023E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000240   0x2101             MOVS     R1,#+1
   \   00000242   0xF1BA 0x0002      SUBS     R0,R10,#+2
   \   00000246   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000248   0x.... 0x....      BL       BlackRightAgainForCross
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD104             BNE.N    ??BlackGetRight_21
   1983                    {
   1984                      BlackRightCrossDone = 1;  //十字检测失败            
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000254   0x2101             MOVS     R1,#+1
   \   00000256   0x7001             STRB     R1,[R0, #+0]
   \   00000258   0xE003             B.N      ??BlackGetRight_22
   1985                    }
   1986                    else
   1987                    {
   1988                      BlackRightCrossDone = 2;  //十字检测成功
   \                     ??BlackGetRight_21:
   \   0000025A   0x.... 0x....      LDR.W    R0,??DataTable25
   \   0000025E   0x2102             MOVS     R1,#+2
   \   00000260   0x7001             STRB     R1,[R0, #+0]
   1989                    }
   1990                    break;  //十字再检测里会开窗检测到指定的最后一行，所以不用再循环了，直接跳出
   \                     ??BlackGetRight_22:
   \   00000262   0xE00E             B.N      ??BlackGetRight_19
   1991                  }
   1992                  else
   1993                  {
   1994                     BlackRightCrossDone = 0;    //十字检测未进入
   \                     ??BlackGetRight_18:
   \   00000264   0x.... 0x....      LDR.W    R0,??DataTable25
   \   00000268   0x2100             MOVS     R1,#+0
   \   0000026A   0x7001             STRB     R1,[R0, #+0]
   1995                  }
   1996                
   1997                }
   1998                else
   1999                {       
   2000                }
   2001                
   2002                
   2003                if((row == 0) || (row == 1)) break;
   \                     ??BlackGetRight_12:
   \   0000026C   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000270   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000274   0xD005             BEQ.N    ??BlackGetRight_23
   \   00000276   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000027A   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000027E   0xF47F 0xAF35      BNE.W    ??BlackGetRight_7
   2004                
   2005              }
   2006              
   2007              
   2008              //第4阶段，采集到十字的前两个角，向后补线。这里有浮点运算，要严格控制调用。
   2009              //////////////////////////其实想想，向后补线有用吗，方便人看，但似乎对车没太大用。
   2010              if(Step4Flag)
   \                     ??BlackGetRight_23:
   \                     ??BlackGetRight_19:
   \   00000282   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000284   0x2D00             CMP      R5,#+0
   \   00000286   0xD007             BEQ.N    ??BlackGetRight_24
   2011              {
   2012                if(!BlackRightStep4BackLine(Step4StartLine))
   \   00000288   0x0030             MOVS     R0,R6
   \   0000028A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000028C   0x.... 0x....      BL       BlackRightStep4BackLine
   \   00000290   0x2800             CMP      R0,#+0
   \   00000292   0xD101             BNE.N    ??BlackGetRight_24
   2013                {
   2014                  return 0;  
   \   00000294   0x2000             MOVS     R0,#+0
   \   00000296   0xE000             B.N      ??BlackGetRight_1
   2015                }
   2016              }
   2017              
   2018              
   2019              return 1;
   \                     ??BlackGetRight_24:
   \   00000298   0x2001             MOVS     R0,#+1
   \                     ??BlackGetRight_1:
   \   0000029A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2020          
   2021            
   2022            
   2023          }
   2024          
   2025          
   2026          //======================================================================
   2027          //函数名：BlackGet
   2028          //功  能：黑线提取程序
   2029          //参  数：无
   2030          //返  回：1成功 0失败
   2031          //影  响：见具体的左、右黑线算法
   2032          //说  明：1. 学长的黑线提取算法有很多输入参数，用以对不同环境下的黑线进行提取，可以效仿
   2033          //        2. 左右黑线分开提取，但右黑线提取的起始点以左黑线提取的结果为准（前提是左黑线提取成功）。
   2034          //        3. 为了防止光线的突变，左右黑线各有2次机会，第2次机会将会把3个关键值赋成原始值再试一次。
   2035          //           如果不是光线的原因，3个关键值会变回来。
   2036          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   2037          uint8 BlackGet(void)
   2038          {
   \                     BlackGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2039              uint8 tempLWB, tempLW, tempLB;
   2040              uint8 tempRWB, tempRW, tempRB;
   2041              //采集成功标志位
   2042              BlackLeftDone = 1;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x7001             STRB     R1,[R0, #+0]
   2043              BlackRightDone = 1;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x7001             STRB     R1,[R0, #+0]
   2044              
   2045              //左黑线提取，成功则返回1，失败则返回0.
   2046              if(!BlackGetLeft())
   \   00000012   0x.... 0x....      BL       BlackGetLeft
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD12D             BNE.N    ??BlackGet_0
   2047              {
   2048                //暂存3个关键值。如果不是光线的原因，值就变回来。
   2049                tempLWB = LimitLeftWB;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   0000001E   0x7804             LDRB     R4,[R0, #+0]
   2050                tempLW = LimitLeftW;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   00000024   0x7805             LDRB     R5,[R0, #+0]
   2051                tempLB = LimitLeftB;
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable26_5
   \   0000002A   0x7806             LDRB     R6,[R0, #+0]
   2052                
   2053                //有可能是光线变化太大，3个关键值改回原来的值，再给1次机会。
   2054                LimitLeftWB = LimitOriLeftWB;                 
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000030   0x2150             MOVS     R1,#+80
   \   00000032   0x7001             STRB     R1,[R0, #+0]
   2055                LimitLeftW = LimitOriLeftW;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   00000038   0x2196             MOVS     R1,#+150
   \   0000003A   0x7001             STRB     R1,[R0, #+0]
   2056                LimitLeftB = LimitOriLeftB;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable26_5
   \   00000040   0x2150             MOVS     R1,#+80
   \   00000042   0x7001             STRB     R1,[R0, #+0]
   2057                
   2058                //不是光线的原因。
   2059                if(!BlackGetLeft())
   \   00000044   0x.... 0x....      BL       BlackGetLeft
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD10D             BNE.N    ??BlackGet_1
   2060                {
   2061                  //不是光线的原因的情况下，把3个关键值变回来。
   2062                  LimitLeftWB = tempLWB;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable26_3
   \   00000050   0x7004             STRB     R4,[R0, #+0]
   2063                  LimitLeftW = tempLW;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable26_4
   \   00000056   0x7005             STRB     R5,[R0, #+0]
   2064                  LimitLeftB = tempLB;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable26_5
   \   0000005C   0x7006             STRB     R6,[R0, #+0]
   2065                  
   2066                  //uart_sendN(UART0, (uint8 *)"\nFailed In BlackGetLeft!", 24);  
   2067                  BlackLeftDone = 0;
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x7001             STRB     R1,[R0, #+0]
   \   00000066   0xE006             B.N      ??BlackGet_0
   2068                }
   2069                //的确是光线的原因。
   2070                else
   2071                {
   2072                  BlackLeft3ResetCount++;    //由于光线变化太大引起的3个关键值重置的次数。
   \                     ??BlackGet_1:
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable26_6
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable26_6
   \   00000074   0x7008             STRB     R0,[R1, #+0]
   2073                }
   2074              }
   2075              
   2076              
   2077              //右黑线提取，成功则返回1，失败则返回0.
   2078              if(!BlackGetRight())
   \                     ??BlackGet_0:
   \   00000076   0x.... 0x....      BL       BlackGetRight
   \   0000007A   0x2800             CMP      R0,#+0
   \   0000007C   0xD124             BNE.N    ??BlackGet_2
   2079              {
   2080                //暂存3个关键值。如果不是光线的原因，值就变回来。
   2081                tempRWB = LimitRightWB;
   \   0000007E   0x....             LDR.N    R0,??DataTable21_2
   \   00000080   0x7804             LDRB     R4,[R0, #+0]
   2082                tempRW = LimitRightW;
   \   00000082   0x....             LDR.N    R0,??DataTable21_3
   \   00000084   0x7805             LDRB     R5,[R0, #+0]
   2083                tempRB = LimitRightB;
   \   00000086   0x....             LDR.N    R0,??DataTable21_4
   \   00000088   0x7806             LDRB     R6,[R0, #+0]
   2084                
   2085                //有可能是光线变化太大，3个关键值改回原来的值，再给1次机会。
   2086                LimitRightWB = LimitOriRightWB;                 
   \   0000008A   0x....             LDR.N    R0,??DataTable21_2
   \   0000008C   0x2150             MOVS     R1,#+80
   \   0000008E   0x7001             STRB     R1,[R0, #+0]
   2087                LimitRightW = LimitOriRightW;
   \   00000090   0x....             LDR.N    R0,??DataTable21_3
   \   00000092   0x2196             MOVS     R1,#+150
   \   00000094   0x7001             STRB     R1,[R0, #+0]
   2088                LimitRightB = LimitOriRightB;
   \   00000096   0x....             LDR.N    R0,??DataTable21_4
   \   00000098   0x2150             MOVS     R1,#+80
   \   0000009A   0x7001             STRB     R1,[R0, #+0]
   2089          
   2090                //不是光线的原因的情况下，把3个关键值变回来。
   2091                if(!BlackGetRight())
   \   0000009C   0x.... 0x....      BL       BlackGetRight
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD10A             BNE.N    ??BlackGet_3
   2092                {
   2093                  LimitRightWB = tempRWB;
   \   000000A4   0x....             LDR.N    R0,??DataTable21_2
   \   000000A6   0x7004             STRB     R4,[R0, #+0]
   2094                  LimitRightW = tempRW;
   \   000000A8   0x....             LDR.N    R0,??DataTable21_3
   \   000000AA   0x7005             STRB     R5,[R0, #+0]
   2095                  LimitRightB = tempRB;
   \   000000AC   0x....             LDR.N    R0,??DataTable21_4
   \   000000AE   0x7006             STRB     R6,[R0, #+0]
   2096                
   2097                  //uart_sendN(UART0, (uint8 *)"\nFailed In BlackGetRight!", 25);  
   2098                  BlackRightDone = 0;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x7001             STRB     R1,[R0, #+0]
   \   000000B8   0xE006             B.N      ??BlackGet_2
   2099                }
   2100                //的确是光线的原因。
   2101                else
   2102                {
   2103                  BlackRight3ResetCount++;    //由于光线变化太大引起的3个关键值重置的次数。
   \                     ??BlackGet_3:
   \   000000BA   0x.... 0x....      LDR.W    R0,??DataTable26_7
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x1C40             ADDS     R0,R0,#+1
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable26_7
   \   000000C6   0x7008             STRB     R0,[R1, #+0]
   2104                }
   2105              }
   2106              
   2107              //左、右黑线均提取失败，则黑线提取失败。
   2108              if((BlackLeftDone == 0) && (BlackRightDone == 0))
   \                     ??BlackGet_2:
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   000000D2   0x7809             LDRB     R1,[R1, #+0]
   \   000000D4   0x4308             ORRS     R0,R1,R0
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD101             BNE.N    ??BlackGet_4
   2109              {
   2110                return 0;
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0xE000             B.N      ??BlackGet_5
   2111              }    
   2112              //暂时还是不采取这种向后补线的方式，因为的确存在一边是十字补线，一边是向后补线的情况。
   2113              /*
   2114              //左、右黑线均提取成功，则看一下是否需要向后补线。
   2115              else if((BlackLeftDone == 1) && (BlackRightDone == 1))
   2116              {
   2117                //左、右黑线均要求向后补线时，才执行补线程序。否则有可能是弯道使线头上浮的情况。
   2118                if((BlackLeftStep4Flag == 1) && (BlackRightStep4Flag == 1))
   2119                {
   2120                  BlackLeftStep4BackLine(BlackLeftStep4StartLine);
   2121                  BlackRightStep4BackLine(BlackRightStep4StartLine);
   2122                }
   2123                
   2124              }
   2125              */
   2126              else
   2127              {
   2128                
   2129              }
   2130              
   2131              return 1;
   \                     ??BlackGet_4:
   \   000000E0   0x2001             MOVS     R0,#+1
   \                     ??BlackGet_5:
   \   000000E2   0xBD70             POP      {R4-R6,PC}       ;; return
   2132          }
   2133          
   2134          
   2135          
   2136          
   2137          
   2138          
   2139          
   2140          
   2141          
   2142          /*
   2143          //======================================================================
   2144          //函数名：CenterLineGet
   2145          //功  能：中心线提取函数
   2146          //参  数：无
   2147          //返  回：1成功 0失败
   2148          //影  响：CenterLineLoc[]
   2149          //说  明：1. 暂定为取左右有效黑线的中点，为基础版本。2014.11.11
   2150          //      
   2151          //             
   2152          //======================================================================
   2153          uint8 CenterLineGet(void)
   2154          {
   2155            uint8 row;
   2156            uint8 templ, tempr;
   2157              
   2158            //左、右黑线均提取失败。
   2159            if((BlackLeftDone == 0) && (BlackRightDone ==  0))
   2160            {
   2161              return 0;  
   2162            }
   2163            
   2164            for(row = CameraHight - 1; ; row--)
   2165            {
   2166              templ = BlackLeftLoc[row][0];
   2167              tempr = BlackRightLoc[row][0];
   2168              
   2169              //左、右黑线均提取成功。
   2170              if((BlackLeftDone == 1) && (BlackRightDone ==  1))
   2171              {   
   2172                //该行左右黑线都提取到了。
   2173                if((templ != MaxValUint8) && (tempr != MaxValUint8))  
   2174                {
   2175                  CenterLineLoc[row] = (templ + tempr) / 2;
   2176                }
   2177                //该行左黑线提取到了，右黑线提取失败。
   2178                else if((templ != MaxValUint8) && (tempr == MaxValUint8))
   2179                {
   2180                  CenterLineLoc[row] = templ + CenterLineHalfWidth[row];
   2181                }
   2182                //该行右黑线提取到了，左黑线提取失败。
   2183                else if((tempr != MaxValUint8) && (templ == MaxValUint8))  
   2184                {
   2185                  CenterLineLoc[row] = tempr - CenterLineHalfWidth[row];
   2186                }
   2187                //该行左、右黑线均提取失败，该行中心点赋无效值。
   2188                else 
   2189                {
   2190                  CenterLineLoc[row] = MaxValUint8;  
   2191                }
   2192              }
   2193              //左黑线提取成功，右黑线提取失败
   2194              else if((BlackLeftDone == 1) && (BlackRightDone ==  0))
   2195              {
   2196                if(templ != MaxValUint8)
   2197                {
   2198                  CenterLineLoc[row] = templ + CenterLineHalfWidth[row];
   2199                }
   2200                else 
   2201                {
   2202                  CenterLineLoc[row] = MaxValUint8;
   2203                }
   2204              }
   2205              //右黑线提取成功，左黑线提取失败
   2206              else if((BlackLeftDone == 0) && (BlackRightDone ==  1))
   2207              {
   2208                if(tempr != MaxValUint8)
   2209                {
   2210                  CenterLineLoc[row] = tempr - CenterLineHalfWidth[row];
   2211                }
   2212                else 
   2213                {
   2214                  CenterLineLoc[row] = MaxValUint8;
   2215                }
   2216              }
   2217              else
   2218              {
   2219                
   2220              }
   2221              
   2222              //如果处理到了最后一行，就跳出for循环。
   2223              if(row == 0) break;
   2224            }
   2225            return 1;
   2226            
   2227          }
   2228          */
   2229          
   2230          
   2231          
   2232          

   \                                 In section .text, align 2, keep-with-next
   2233          uint8 CenterLineGet(void)
   2234          {
   \                     CenterLineGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2235            uint8 row, i, j;
   2236            uint8 templ, tempr;
   2237            uint8 FailCount;
   2238            uint8 tempmax;
   2239            //uint8 flag001 = 0;
   2240            //左、右黑线均提取失败。
   2241            if((BlackLeftDone == 0) && (BlackRightDone ==  0))
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable26_2
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD101             BNE.N    ??CenterLineGet_0
   2242            {
   2243              return 0;  
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE398             B.N      ??CenterLineGet_1
   2244            }
   2245              
   2246            //左、右黑线均提取成功。
   2247            if((BlackLeftDone == 1) && (BlackRightDone ==  1))
   \                     ??CenterLineGet_0:
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xF040 0x81FD      BNE.W    ??CenterLineGet_2
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2801             CMP      R0,#+1
   \   0000002E   0xF040 0x81F7      BNE.W    ??CenterLineGet_2
   2248            {
   2249              FailCount = 0;
   \   00000032   0x2400             MOVS     R4,#+0
   2250              for(row = CameraHight - 1; ; row--)
   \   00000034   0x2531             MOVS     R5,#+49
   \   00000036   0xE000             B.N      ??CenterLineGet_3
   \                     ??CenterLineGet_4:
   \   00000038   0x1E6D             SUBS     R5,R5,#+1
   2251              {
   2252                templ = BlackLeftLoc[row][0];
   \                     ??CenterLineGet_3:
   \   0000003A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003C   0x2003             MOVS     R0,#+3
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000042   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000046   0x7802             LDRB     R2,[R0, #+0]
   2253                tempr = BlackRightLoc[row][0];
   \   00000048   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004A   0x2003             MOVS     R0,#+3
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000050   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   2254                //该行左右黑线都提取到了。
   2255                if((templ != MaxValUint8) && (tempr != MaxValUint8))  
   \   00000056   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000058   0x2AFF             CMP      R2,#+255
   \   0000005A   0xD00D             BEQ.N    ??CenterLineGet_5
   \   0000005C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005E   0x28FF             CMP      R0,#+255
   \   00000060   0xD00A             BEQ.N    ??CenterLineGet_5
   2256                {        
   2257                  CenterLineLoc[row] = (templ + tempr) / 2;    
   \   00000062   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000064   0xFA50 0xF082      UXTAB    R0,R0,R2
   \   00000068   0x2102             MOVS     R1,#+2
   \   0000006A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000006E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000074   0x5468             STRB     R0,[R5, R1]
   \   00000076   0xE143             B.N      ??CenterLineGet_6
   2258                }
   2259                //该行左黑线提取失败，右黑线提取成功。
   2260                else if((templ == MaxValUint8) && (tempr != MaxValUint8))
   \                     ??CenterLineGet_5:
   \   00000078   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000007A   0x2AFF             CMP      R2,#+255
   \   0000007C   0xF040 0x809C      BNE.W    ??CenterLineGet_7
   \   00000080   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000082   0x28FF             CMP      R0,#+255
   \   00000084   0xF000 0x8098      BEQ.W    ??CenterLineGet_7
   2261                {
   2262                  //根据右线来估计中心线的走向，前提是上一行的右黑线有有效值。
   2263                  if((row != (CameraHight-1))&&(BlackRightLoc[row+1][0] != MaxValUint8))
   \   00000088   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000008A   0x2D31             CMP      R5,#+49
   \   0000008C   0xF000 0x808E      BEQ.W    ??CenterLineGet_8
   \   00000090   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000092   0x2103             MOVS     R1,#+3
   \   00000094   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   00000098   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   0000009C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000009E   0x29FF             CMP      R1,#+255
   \   000000A0   0xF000 0x8084      BEQ.W    ??CenterLineGet_8
   2264                  { //前一行的中心线有效。
   2265                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   000000A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000A6   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000000AA   0x1869             ADDS     R1,R5,R1
   \   000000AC   0x7849             LDRB     R1,[R1, #+1]
   \   000000AE   0x29FF             CMP      R1,#+255
   \   000000B0   0xD012             BEQ.N    ??CenterLineGet_9
   2266                    {
   2267                      CenterLineLoc[row] = CenterLineLoc[row+1] + tempr - BlackRightLoc[row+1][0];
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000000B8   0x1869             ADDS     R1,R5,R1
   \   000000BA   0x7849             LDRB     R1,[R1, #+1]
   \   000000BC   0x1840             ADDS     R0,R0,R1
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0x2103             MOVS     R1,#+3
   \   000000C2   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   000000C6   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   000000CA   0x78C9             LDRB     R1,[R1, #+3]
   \   000000CC   0x1A40             SUBS     R0,R0,R1
   \   000000CE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D0   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000000D4   0x5468             STRB     R0,[R5, R1]
   \   000000D6   0xE113             B.N      ??CenterLineGet_6
   2268                    }
   2269                    //前一行的中心线无效。
   2270                    //如果是近处的行，那就有可能是270度左右黑线错位的情况。
   2271                    else if(row > CameraHight - 5)
   \                     ??CenterLineGet_9:
   \   000000D8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000DA   0x2D2E             CMP      R5,#+46
   \   000000DC   0xD325             BCC.N    ??CenterLineGet_10
   2272                    {
   2273                      if(CenterLocStore != MaxValUint8)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x28FF             CMP      R0,#+255
   \   000000E6   0xD00F             BEQ.N    ??CenterLineGet_11
   2274                      {
   2275                        CenterLineLoc[row] = BlackRightLoc[row][0] - CenterLocStore;
   \   000000E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EA   0x2003             MOVS     R0,#+3
   \   000000EC   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   000000F0   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000000F4   0x7800             LDRB     R0,[R0, #+0]
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \   000000FA   0x7809             LDRB     R1,[R1, #+0]
   \   000000FC   0x1A40             SUBS     R0,R0,R1
   \   000000FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000100   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000104   0x5468             STRB     R0,[R5, R1]
   \   00000106   0xE0FB             B.N      ??CenterLineGet_6
   2276                      }
   2277                      else
   2278                      {
   2279                        CenterLineLoc[row] = BlackRightLoc[row][0] - CenterLineHalfWidth[row];
   \                     ??CenterLineGet_11:
   \   00000108   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   0x2003             MOVS     R0,#+3
   \   0000010C   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000110   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000118   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \   0000011C   0x5C69             LDRB     R1,[R5, R1]
   \   0000011E   0x1A40             SUBS     R0,R0,R1
   \   00000120   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000126   0x5468             STRB     R0,[R5, R1]
   \   00000128   0xE0EA             B.N      ??CenterLineGet_6
   2280                      }
   2281                      //flag001 = 1; //flag001是标志位，用以防止开头几行的中心线不连续的情况。
   2282                    }
   2283                    else
   2284                    { //行数够低才处理，否则不考虑。
   2285                      if(row <= CameraHight - 3)
   \                     ??CenterLineGet_10:
   \   0000012A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000012C   0x2D30             CMP      R5,#+48
   \   0000012E   0xD237             BCS.N    ??CenterLineGet_12
   2286                      { //连续3行找符合要求的行。
   2287                        for(i = 2; i <= 4; i++)
   \   00000130   0x2102             MOVS     R1,#+2
   \   00000132   0xE000             B.N      ??CenterLineGet_13
   \                     ??CenterLineGet_14:
   \   00000134   0x1C49             ADDS     R1,R1,#+1
   \                     ??CenterLineGet_13:
   \   00000136   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000138   0x2905             CMP      R1,#+5
   \   0000013A   0xD227             BCS.N    ??CenterLineGet_15
   2288                        {
   2289                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackRightLoc[row+i][0] != MaxValUint8))
   \   0000013C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000013E   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   00000142   0x.... 0x....      LDR.W    R3,??DataTable26_10
   \   00000146   0x5CD2             LDRB     R2,[R2, R3]
   \   00000148   0x2AFF             CMP      R2,#+255
   \   0000014A   0xD0F3             BEQ.N    ??CenterLineGet_14
   \   0000014C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000014E   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   00000152   0x2303             MOVS     R3,#+3
   \   00000154   0x.... 0x....      LDR.W    R6,??DataTable26_9
   \   00000158   0xFB03 0x6202      MLA      R2,R3,R2,R6
   \   0000015C   0x7812             LDRB     R2,[R2, #+0]
   \   0000015E   0x2AFF             CMP      R2,#+255
   \   00000160   0xD0E8             BEQ.N    ??CenterLineGet_14
   2290                          {
   2291                             CenterLineLoc[row] = CenterLineLoc[row+i] + tempr - BlackRightLoc[row+i][0]; 
   \   00000162   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000164   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   00000168   0x.... 0x....      LDR.W    R3,??DataTable26_10
   \   0000016C   0x5CD2             LDRB     R2,[R2, R3]
   \   0000016E   0x1880             ADDS     R0,R0,R2
   \   00000170   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000172   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   00000176   0x2303             MOVS     R3,#+3
   \   00000178   0x.... 0x....      LDR.W    R6,??DataTable26_9
   \   0000017C   0xFB03 0x6202      MLA      R2,R3,R2,R6
   \   00000180   0x7812             LDRB     R2,[R2, #+0]
   \   00000182   0x1A80             SUBS     R0,R0,R2
   \   00000184   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000186   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   0000018A   0x54A8             STRB     R0,[R5, R2]
   2292                             break;
   2293                          }
   2294                        }
   2295                        //连续3行没有找到符合要求的行。
   2296                        if(i == 5) CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_15:
   \   0000018C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000018E   0x2905             CMP      R1,#+5
   \   00000190   0xF040 0x80B6      BNE.W    ??CenterLineGet_6
   \   00000194   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000196   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   0000019A   0x21FF             MOVS     R1,#+255
   \   0000019C   0x5429             STRB     R1,[R5, R0]
   \   0000019E   0xE0AF             B.N      ??CenterLineGet_6
   2297                      }        
   2298                      else
   2299                      {   //行数过高，不考虑这种情况。
   2300                          CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_12:
   \   000001A0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000001A6   0x21FF             MOVS     R1,#+255
   \   000001A8   0x5429             STRB     R1,[R5, R0]
   \   000001AA   0xE0A9             B.N      ??CenterLineGet_6
   2301                      }
   2302                    }
   2303                  }
   2304                  else
   2305                  {
   2306                    CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_8:
   \   000001AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000001B2   0x21FF             MOVS     R1,#+255
   \   000001B4   0x5429             STRB     R1,[R5, R0]
   \   000001B6   0xE0A3             B.N      ??CenterLineGet_6
   2307                  }
   2308                }
   2309                //该行右黑线提取失败，左黑线提取成功。
   2310                else if((templ != MaxValUint8) && (tempr == MaxValUint8))
   \                     ??CenterLineGet_7:
   \   000001B8   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   000001BA   0x2AFF             CMP      R2,#+255
   \   000001BC   0xF000 0x809B      BEQ.W    ??CenterLineGet_16
   \   000001C0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001C2   0x28FF             CMP      R0,#+255
   \   000001C4   0xF040 0x8097      BNE.W    ??CenterLineGet_16
   2311                {
   2312                  //根据左线来估计中心线的走向，前提是上一行的左黑线有有效值。
   2313                  if((row != CameraHight - 1)&&(BlackLeftLoc[row+1][0] != MaxValUint8))
   \   000001C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001CA   0x2D31             CMP      R5,#+49
   \   000001CC   0xF000 0x808D      BEQ.W    ??CenterLineGet_17
   \   000001D0   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001D2   0x2003             MOVS     R0,#+3
   \   000001D4   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   000001D8   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000001DC   0x78C0             LDRB     R0,[R0, #+3]
   \   000001DE   0x28FF             CMP      R0,#+255
   \   000001E0   0xF000 0x8083      BEQ.W    ??CenterLineGet_17
   2314                  {  //上一行的中心线有效。
   2315                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   000001E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000001EA   0x1828             ADDS     R0,R5,R0
   \   000001EC   0x7840             LDRB     R0,[R0, #+1]
   \   000001EE   0x28FF             CMP      R0,#+255
   \   000001F0   0xD012             BEQ.N    ??CenterLineGet_18
   2316                    {
   2317                      CenterLineLoc[row] = CenterLineLoc[row + 1] + templ - BlackLeftLoc[row+1][0];
   \   000001F2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000001F8   0x1828             ADDS     R0,R5,R0
   \   000001FA   0x7840             LDRB     R0,[R0, #+1]
   \   000001FC   0x1810             ADDS     R0,R2,R0
   \   000001FE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000200   0x2103             MOVS     R1,#+3
   \   00000202   0x.... 0x....      LDR.W    R2,??DataTable26_8
   \   00000206   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   0000020A   0x78C9             LDRB     R1,[R1, #+3]
   \   0000020C   0x1A40             SUBS     R0,R0,R1
   \   0000020E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000210   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000214   0x5468             STRB     R0,[R5, R1]
   \   00000216   0xE073             B.N      ??CenterLineGet_6
   2318                    }
   2319                    //上一行的中心线无效。
   2320                    //如果是近处的行，那就有可能是270度左右黑线错位的情况。
   2321                    else if(row > CameraHight - 3)
   \                     ??CenterLineGet_18:
   \   00000218   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000021A   0x2D30             CMP      R5,#+48
   \   0000021C   0xD325             BCC.N    ??CenterLineGet_19
   2322                    { 
   2323                      if(CenterLocStore != MaxValUint8)
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   00000222   0x7800             LDRB     R0,[R0, #+0]
   \   00000224   0x28FF             CMP      R0,#+255
   \   00000226   0xD00F             BEQ.N    ??CenterLineGet_20
   2324                      {
   2325                        CenterLineLoc[row] = BlackLeftLoc[row][0] + CenterLocStore;
   \   00000228   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000022A   0x2003             MOVS     R0,#+3
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000230   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000234   0x7800             LDRB     R0,[R0, #+0]
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \   0000023A   0x7809             LDRB     R1,[R1, #+0]
   \   0000023C   0x1808             ADDS     R0,R1,R0
   \   0000023E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000240   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000244   0x5468             STRB     R0,[R5, R1]
   \   00000246   0xE05B             B.N      ??CenterLineGet_6
   2326                      }
   2327                      else
   2328                      {
   2329                        CenterLineLoc[row] = BlackLeftLoc[row][0] + CenterLineHalfWidth[row];
   \                     ??CenterLineGet_20:
   \   00000248   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000024A   0x2003             MOVS     R0,#+3
   \   0000024C   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000250   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000254   0x7800             LDRB     R0,[R0, #+0]
   \   00000256   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000258   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \   0000025C   0x5C69             LDRB     R1,[R5, R1]
   \   0000025E   0x1808             ADDS     R0,R1,R0
   \   00000260   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000262   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000266   0x5468             STRB     R0,[R5, R1]
   \   00000268   0xE04A             B.N      ??CenterLineGet_6
   2330                      }
   2331                      //flag001 = 1; //flag001是标志位，用以防止开头几行的中心线不连续的情况。
   2332                    }
   2333                    else
   2334                    { //连续3行找符合条件的行
   2335                      if(row <= CameraHight - 5)
   \                     ??CenterLineGet_19:
   \   0000026A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000026C   0x2D2E             CMP      R5,#+46
   \   0000026E   0xD236             BCS.N    ??CenterLineGet_21
   2336                      {
   2337                        for(i = 2; i <= 4; i++)
   \   00000270   0x2102             MOVS     R1,#+2
   \   00000272   0xE000             B.N      ??CenterLineGet_22
   \                     ??CenterLineGet_23:
   \   00000274   0x1C49             ADDS     R1,R1,#+1
   \                     ??CenterLineGet_22:
   \   00000276   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000278   0x2905             CMP      R1,#+5
   \   0000027A   0xD227             BCS.N    ??CenterLineGet_24
   2338                        {
   2339                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackLeftLoc[row+i][0] != MaxValUint8))
   \   0000027C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000027E   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   00000282   0x.... 0x....      LDR.W    R3,??DataTable26_10
   \   00000286   0x5CC0             LDRB     R0,[R0, R3]
   \   00000288   0x28FF             CMP      R0,#+255
   \   0000028A   0xD0F3             BEQ.N    ??CenterLineGet_23
   \   0000028C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000028E   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   00000292   0x2303             MOVS     R3,#+3
   \   00000294   0x.... 0x....      LDR.W    R6,??DataTable26_8
   \   00000298   0xFB03 0x6000      MLA      R0,R3,R0,R6
   \   0000029C   0x7800             LDRB     R0,[R0, #+0]
   \   0000029E   0x28FF             CMP      R0,#+255
   \   000002A0   0xD0E8             BEQ.N    ??CenterLineGet_23
   2340                          { //找到了符合条件的行。
   2341                            CenterLineLoc[row] = CenterLineLoc[row+i] + templ - BlackLeftLoc[row+i][0];
   \   000002A2   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002A4   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   000002A8   0x.... 0x....      LDR.W    R3,??DataTable26_10
   \   000002AC   0x5CC0             LDRB     R0,[R0, R3]
   \   000002AE   0x1810             ADDS     R0,R2,R0
   \   000002B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002B2   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   000002B6   0x2303             MOVS     R3,#+3
   \   000002B8   0x.... 0x....      LDR.W    R6,??DataTable26_8
   \   000002BC   0xFB03 0x6202      MLA      R2,R3,R2,R6
   \   000002C0   0x7812             LDRB     R2,[R2, #+0]
   \   000002C2   0x1A80             SUBS     R0,R0,R2
   \   000002C4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002C6   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   000002CA   0x54A8             STRB     R0,[R5, R2]
   2342                            break;
   2343                          }
   2344                        }
   2345                        if(i == 5) CenterLineLoc[row] = MaxValUint8; ////连续3行没有找到符合条件的行.置无效值
   \                     ??CenterLineGet_24:
   \   000002CC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002CE   0x2905             CMP      R1,#+5
   \   000002D0   0xD116             BNE.N    ??CenterLineGet_6
   \   000002D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002D4   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000002D8   0x21FF             MOVS     R1,#+255
   \   000002DA   0x5429             STRB     R1,[R5, R0]
   \   000002DC   0xE010             B.N      ??CenterLineGet_6
   2346                      }
   2347                      else
   2348                      { //行数太高，不考虑这种情况。 
   2349                        CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_21:
   \   000002DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002E0   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000002E4   0x21FF             MOVS     R1,#+255
   \   000002E6   0x5429             STRB     R1,[R5, R0]
   \   000002E8   0xE00A             B.N      ??CenterLineGet_6
   2350                      }
   2351                    }
   2352                  }
   2353                  else
   2354                  {
   2355                    CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_17:
   \   000002EA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002EC   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000002F0   0x21FF             MOVS     R1,#+255
   \   000002F2   0x5429             STRB     R1,[R5, R0]
   \   000002F4   0xE004             B.N      ??CenterLineGet_6
   2356                  }
   2357                }
   2358                //该行左右线均提取失败。
   2359                else 
   2360                {
   2361                  CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_16:
   \   000002F6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002F8   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000002FC   0x21FF             MOVS     R1,#+255
   \   000002FE   0x5429             STRB     R1,[R5, R0]
   2362                }
   2363              if(CenterLineLoc[row] == MaxValUint8) 
   \                     ??CenterLineGet_6:
   \   00000300   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000302   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000306   0x5C28             LDRB     R0,[R5, R0]
   \   00000308   0x28FF             CMP      R0,#+255
   \   0000030A   0xD147             BNE.N    ??CenterLineGet_25
   2364              {
   2365                FailCount++;
   \   0000030C   0x1C64             ADDS     R4,R4,#+1
   2366                //对无效值的再处理。
   2367                tempmax = MinRe(BlackLeftHeadLine, BlackRightHeadLine);
   \   0000030E   0x.... 0x....      LDR.W    R0,??DataTable27
   \   00000312   0x7801             LDRB     R1,[R0, #+0]
   \   00000314   0x.... 0x....      LDR.W    R0,??DataTable27_1
   \   00000318   0x7800             LDRB     R0,[R0, #+0]
   \   0000031A   0x.... 0x....      BL       MinRe
   2368                //第一批条件，行数够远，前3行之外。
   2369                if(row <= CameraHight-3 && CenterLineLoc[row+1] != MaxValUint8 && CenterLineLoc[row+2] != MaxValUint8)
   \   0000031E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000320   0x2D30             CMP      R5,#+48
   \   00000322   0xD23B             BCS.N    ??CenterLineGet_25
   \   00000324   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000326   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000032A   0x1869             ADDS     R1,R5,R1
   \   0000032C   0x7849             LDRB     R1,[R1, #+1]
   \   0000032E   0x29FF             CMP      R1,#+255
   \   00000330   0xD034             BEQ.N    ??CenterLineGet_25
   \   00000332   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000334   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000338   0x1869             ADDS     R1,R5,R1
   \   0000033A   0x7889             LDRB     R1,[R1, #+2]
   \   0000033C   0x29FF             CMP      R1,#+255
   \   0000033E   0xD02D             BEQ.N    ??CenterLineGet_25
   2370                {
   2371                  //第二批条件，在左右线头之内，超过左右线头则不处理。
   2372                  if(row >= tempmax)
   \   00000340   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000342   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000344   0x4285             CMP      R5,R0
   \   00000346   0xD329             BCC.N    ??CenterLineGet_25
   2373                  {
   2374                    //第三批条件，补的黑线不超过左右边界。
   2375                    if(CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2] < 0
   2376                     ||CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2] > CameraRealWidth - 1)
   \   00000348   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000034A   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   0000034E   0x1828             ADDS     R0,R5,R0
   \   00000350   0x7840             LDRB     R0,[R0, #+1]
   \   00000352   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000354   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000358   0x1869             ADDS     R1,R5,R1
   \   0000035A   0x7849             LDRB     R1,[R1, #+1]
   \   0000035C   0xFA51 0xF080      UXTAB    R0,R1,R0
   \   00000360   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000362   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000366   0x1869             ADDS     R1,R5,R1
   \   00000368   0x7889             LDRB     R1,[R1, #+2]
   \   0000036A   0x1A40             SUBS     R0,R0,R1
   \   0000036C   0x1E00             SUBS     R0,R0,#+0
   \   0000036E   0x28FA             CMP      R0,#+250
   \   00000370   0xD214             BCS.N    ??CenterLineGet_25
   2377                    {           
   2378                    }
   2379                    else
   2380                    {
   2381                      //三批条件均满足
   2382                      CenterLineLoc[row] = CenterLineLoc[row+1] + CenterLineLoc[row+1] - CenterLineLoc[row+2];
   \   00000372   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000374   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000378   0x1828             ADDS     R0,R5,R0
   \   0000037A   0x7840             LDRB     R0,[R0, #+1]
   \   0000037C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000037E   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000382   0x1869             ADDS     R1,R5,R1
   \   00000384   0x7849             LDRB     R1,[R1, #+1]
   \   00000386   0x1808             ADDS     R0,R1,R0
   \   00000388   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000038A   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000038E   0x1869             ADDS     R1,R5,R1
   \   00000390   0x7889             LDRB     R1,[R1, #+2]
   \   00000392   0x1A40             SUBS     R0,R0,R1
   \   00000394   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000396   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000039A   0x5468             STRB     R0,[R5, R1]
   2383                    }
   2384                  }
   2385                  else
   2386                  {
   2387                  }
   2388                }
   2389                else
   2390                {
   2391                }
   2392              }
   2393              if(row == 0) break;
   \                     ??CenterLineGet_25:
   \   0000039C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000039E   0x2D00             CMP      R5,#+0
   \   000003A0   0xF47F 0xAE4A      BNE.W    ??CenterLineGet_4
   2394              }// end of for 
   2395              
   2396              if(FailCount >= CameraHight) return 0;
   \   000003A4   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000003A6   0x2C32             CMP      R4,#+50
   \   000003A8   0xD301             BCC.N    ??CenterLineGet_26
   \   000003AA   0x2000             MOVS     R0,#+0
   \   000003AC   0xE1CE             B.N      ??CenterLineGet_1
   2397              //中心线提取成功，记录线头，作为后面的单线线头。
   2398              if(row == 0) 
   \                     ??CenterLineGet_26:
   \   000003AE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000003B0   0x2D00             CMP      R5,#+0
   \   000003B2   0xD135             BNE.N    ??CenterLineGet_2
   2399              {
   2400                for(j = CameraHight - 1; ; j--)
   \   000003B4   0x2031             MOVS     R0,#+49
   \   000003B6   0xE000             B.N      ??CenterLineGet_27
   \                     ??CenterLineGet_28:
   \   000003B8   0x1E40             SUBS     R0,R0,#+1
   2401                { //最近的3行找线头。
   2402                  if(CenterLineLoc[j] != MaxValUint8 && BlackLeftLoc[j][0] != MaxValUint8 && BlackRightLoc[j][0] != MaxValUint8)
   \                     ??CenterLineGet_27:
   \   000003BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003BC   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000003C0   0x5C41             LDRB     R1,[R0, R1]
   \   000003C2   0x29FF             CMP      R1,#+255
   \   000003C4   0xD027             BEQ.N    ??CenterLineGet_29
   \   000003C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003C8   0x2103             MOVS     R1,#+3
   \   000003CA   0x.... 0x....      LDR.W    R2,??DataTable26_8
   \   000003CE   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   000003D2   0x7809             LDRB     R1,[R1, #+0]
   \   000003D4   0x29FF             CMP      R1,#+255
   \   000003D6   0xD01E             BEQ.N    ??CenterLineGet_29
   \   000003D8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003DA   0x2103             MOVS     R1,#+3
   \   000003DC   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   000003E0   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   000003E4   0x7809             LDRB     R1,[R1, #+0]
   \   000003E6   0x29FF             CMP      R1,#+255
   \   000003E8   0xD015             BEQ.N    ??CenterLineGet_29
   2403                  {
   2404                    CenterLocStore = (BlackRightLoc[j][0] - BlackLeftLoc[j][0]) / 2;
   \   000003EA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003EC   0x2103             MOVS     R1,#+3
   \   000003EE   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   000003F2   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   000003F6   0x7809             LDRB     R1,[R1, #+0]
   \   000003F8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000003FA   0x2203             MOVS     R2,#+3
   \   000003FC   0x.... 0x....      LDR.W    R3,??DataTable26_8
   \   00000400   0xFB02 0x3000      MLA      R0,R2,R0,R3
   \   00000404   0x7800             LDRB     R0,[R0, #+0]
   \   00000406   0x1A08             SUBS     R0,R1,R0
   \   00000408   0x2102             MOVS     R1,#+2
   \   0000040A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000040E   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \   00000412   0x7008             STRB     R0,[R1, #+0]
   2405                    break;
   \   00000414   0xE002             B.N      ??CenterLineGet_30
   2406                  }
   2407                  if(j <= CameraHight - 4)
   \                     ??CenterLineGet_29:
   \   00000416   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000418   0x282F             CMP      R0,#+47
   \   0000041A   0xD2CD             BCS.N    ??CenterLineGet_28
   2408                  {
   2409                    //CenterLocStore = MaxValUint8;
   2410                    break;
   2411                  }
   2412                }
   2413                return 1;
   \                     ??CenterLineGet_30:
   \   0000041C   0x2001             MOVS     R0,#+1
   \   0000041E   0xE195             B.N      ??CenterLineGet_1
   2414              }
   2415            } // end of if
   2416            
   2417            
   2418            
   2419            //左黑线提取成功，右黑线提取失败。就基本上按左线来估计中心线。
   2420            if((BlackLeftDone == 1) && (BlackRightDone == 0))
   \                     ??CenterLineGet_2:
   \   00000420   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   00000424   0x7800             LDRB     R0,[R0, #+0]
   \   00000426   0x2801             CMP      R0,#+1
   \   00000428   0xF040 0x80C5      BNE.W    ??CenterLineGet_31
   \   0000042C   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   00000430   0x7800             LDRB     R0,[R0, #+0]
   \   00000432   0x2800             CMP      R0,#+0
   \   00000434   0xF040 0x80BF      BNE.W    ??CenterLineGet_31
   2421            {
   2422              //找中心线的线头。
   2423              for(row = CameraHight - 1; row > CameraHight - BlackStep1Size; row --)
   \   00000438   0x2531             MOVS     R5,#+49
   \   0000043A   0xE005             B.N      ??CenterLineGet_32
   2424              {
   2425                //找左线有效值。 //原为连续两行找有效值，现改为一行。
   2426                if(BlackLeftLoc[row][0] != MaxValUint8)
   2427                {
   2428                  if(CenterLocStore != MaxValUint8)
   2429                  {
   2430                    CenterLineLoc[row] = BlackLeftLoc[row][0] + CenterLocStore;
   2431                  }
   2432                  else
   2433                  {
   2434                    CenterLineLoc[row] = BlackLeftLoc[row][0] + CenterLineHalfWidth[row];
   2435                  }
   2436                  break;
   2437                }
   2438                else
   2439                {
   2440                  CenterLineLoc[row] = MaxValUint8;
   \                     ??CenterLineGet_33:
   \   0000043C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000043E   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000442   0x21FF             MOVS     R1,#+255
   \   00000444   0x5429             STRB     R1,[R5, R0]
   2441                }
   \   00000446   0x1E6D             SUBS     R5,R5,#+1
   \                     ??CenterLineGet_32:
   \   00000448   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000044A   0x2D10             CMP      R5,#+16
   \   0000044C   0xD32D             BCC.N    ??CenterLineGet_34
   \   0000044E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000450   0x2003             MOVS     R0,#+3
   \   00000452   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000456   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000045A   0x7800             LDRB     R0,[R0, #+0]
   \   0000045C   0x28FF             CMP      R0,#+255
   \   0000045E   0xD0ED             BEQ.N    ??CenterLineGet_33
   \   00000460   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   00000464   0x7800             LDRB     R0,[R0, #+0]
   \   00000466   0x28FF             CMP      R0,#+255
   \   00000468   0xD00F             BEQ.N    ??CenterLineGet_35
   \   0000046A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000046C   0x2003             MOVS     R0,#+3
   \   0000046E   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000472   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000476   0x7800             LDRB     R0,[R0, #+0]
   \   00000478   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \   0000047C   0x7809             LDRB     R1,[R1, #+0]
   \   0000047E   0x1808             ADDS     R0,R1,R0
   \   00000480   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000482   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   00000486   0x5468             STRB     R0,[R5, R1]
   \   00000488   0xE00F             B.N      ??CenterLineGet_36
   \                     ??CenterLineGet_35:
   \   0000048A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000048C   0x2003             MOVS     R0,#+3
   \   0000048E   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   00000492   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   00000496   0x7800             LDRB     R0,[R0, #+0]
   \   00000498   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000049A   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \   0000049E   0x5C69             LDRB     R1,[R5, R1]
   \   000004A0   0x1808             ADDS     R0,R1,R0
   \   000004A2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004A4   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000004A8   0x5468             STRB     R0,[R5, R1]
   2442              }
   2443              //没有找到中心线线头，中心线提取失败。
   2444              if(row <= CameraHight - BlackStep1Size) return 0;
   \                     ??CenterLineGet_36:
   \                     ??CenterLineGet_34:
   \   000004AA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004AC   0x2D10             CMP      R5,#+16
   \   000004AE   0xD201             BCS.N    ??CenterLineGet_37
   \   000004B0   0x2000             MOVS     R0,#+0
   \   000004B2   0xE14B             B.N      ??CenterLineGet_1
   2445              
   2446              //找到线头，按照左线的趋势进行中心线的估计。
   2447              for(row --; ; row--)
   \                     ??CenterLineGet_37:
   \   000004B4   0x1E6D             SUBS     R5,R5,#+1
   \   000004B6   0xE000             B.N      ??CenterLineGet_38
   \                     ??CenterLineGet_39:
   \   000004B8   0x1E6D             SUBS     R5,R5,#+1
   2448              {
   2449                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGet_38:
   \   000004BA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004BC   0x2003             MOVS     R0,#+3
   \   000004BE   0x.... 0x....      LDR.W    R1,??DataTable26_8
   \   000004C2   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000004C6   0x7800             LDRB     R0,[R0, #+0]
   \   000004C8   0x28FF             CMP      R0,#+255
   \   000004CA   0xD067             BEQ.N    ??CenterLineGet_40
   2450                {   //上一行的中心线有效。
   2451                    if(CenterLineLoc[row+1] != MaxValUint8)
   \   000004CC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004CE   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000004D2   0x1828             ADDS     R0,R5,R0
   \   000004D4   0x7840             LDRB     R0,[R0, #+1]
   \   000004D6   0x28FF             CMP      R0,#+255
   \   000004D8   0xD019             BEQ.N    ??CenterLineGet_41
   2452                    {
   2453                      CenterLineLoc[row] = CenterLineLoc[row + 1] + BlackLeftLoc[row][0] - BlackLeftLoc[row+1][0];
   \   000004DA   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004DC   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000004E0   0x1828             ADDS     R0,R5,R0
   \   000004E2   0x7840             LDRB     R0,[R0, #+1]
   \   000004E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004E6   0x2103             MOVS     R1,#+3
   \   000004E8   0x.... 0x....      LDR.W    R2,??DataTable26_8
   \   000004EC   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   000004F0   0x7809             LDRB     R1,[R1, #+0]
   \   000004F2   0x1808             ADDS     R0,R1,R0
   \   000004F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000004F6   0x2103             MOVS     R1,#+3
   \   000004F8   0x.... 0x....      LDR.W    R2,??DataTable26_8
   \   000004FC   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   00000500   0x78C9             LDRB     R1,[R1, #+3]
   \   00000502   0x1A40             SUBS     R0,R0,R1
   \   00000504   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000506   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000050A   0x5468             STRB     R0,[R5, R1]
   \   0000050C   0xE04B             B.N      ??CenterLineGet_42
   2454                    }
   2455                    //上一行的中心线无效。
   2456                    else
   2457                    { //连续3行找符合条件的行
   2458                      if(row <= CameraHight - 5)
   \                     ??CenterLineGet_41:
   \   0000050E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000510   0x2D2E             CMP      R5,#+46
   \   00000512   0xD23D             BCS.N    ??CenterLineGet_43
   2459                      {
   2460                        for(i = 2; i <= 4; i++)
   \   00000514   0x2102             MOVS     R1,#+2
   \   00000516   0xE000             B.N      ??CenterLineGet_44
   \                     ??CenterLineGet_45:
   \   00000518   0x1C49             ADDS     R1,R1,#+1
   \                     ??CenterLineGet_44:
   \   0000051A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000051C   0x2905             CMP      R1,#+5
   \   0000051E   0xD22E             BCS.N    ??CenterLineGet_46
   2461                        {
   2462                          if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackLeftLoc[row+i][0] != MaxValUint8))
   \   00000520   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000522   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   00000526   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   0000052A   0x5C80             LDRB     R0,[R0, R2]
   \   0000052C   0x28FF             CMP      R0,#+255
   \   0000052E   0xD0F3             BEQ.N    ??CenterLineGet_45
   \   00000530   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000532   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   00000536   0x2203             MOVS     R2,#+3
   \   00000538   0x.... 0x....      LDR.W    R3,??DataTable26_8
   \   0000053C   0xFB02 0x3000      MLA      R0,R2,R0,R3
   \   00000540   0x7800             LDRB     R0,[R0, #+0]
   \   00000542   0x28FF             CMP      R0,#+255
   \   00000544   0xD0E8             BEQ.N    ??CenterLineGet_45
   2463                          { //找到了符合条件的行。
   2464                            CenterLineLoc[row] = CenterLineLoc[row+i] + BlackLeftLoc[row][0] - BlackLeftLoc[row+i][0];
   \   00000546   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000548   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   0000054C   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   00000550   0x5C80             LDRB     R0,[R0, R2]
   \   00000552   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000554   0x2203             MOVS     R2,#+3
   \   00000556   0x.... 0x....      LDR.W    R3,??DataTable26_8
   \   0000055A   0xFB02 0x3205      MLA      R2,R2,R5,R3
   \   0000055E   0x7812             LDRB     R2,[R2, #+0]
   \   00000560   0x1810             ADDS     R0,R2,R0
   \   00000562   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000564   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   00000568   0x2303             MOVS     R3,#+3
   \   0000056A   0x.... 0x....      LDR.W    R4,??DataTable26_8
   \   0000056E   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000572   0x7812             LDRB     R2,[R2, #+0]
   \   00000574   0x1A80             SUBS     R0,R0,R2
   \   00000576   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000578   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   0000057C   0x54A8             STRB     R0,[R5, R2]
   2465                            break;
   2466                          }
   2467                        }
   2468                        if(i == 5) CenterLineLoc[row] = MaxValUint8; ////连续3行没有找到符合条件的行.置无效值
   \                     ??CenterLineGet_46:
   \   0000057E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000580   0x2905             CMP      R1,#+5
   \   00000582   0xD110             BNE.N    ??CenterLineGet_42
   \   00000584   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000586   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   0000058A   0x21FF             MOVS     R1,#+255
   \   0000058C   0x5429             STRB     R1,[R5, R0]
   \   0000058E   0xE00A             B.N      ??CenterLineGet_42
   2469                      }
   2470                      else
   2471                      { //行数太高，不考虑这种情况。 
   2472                        CenterLineLoc[row] = MaxValUint8; //置无效值
   \                     ??CenterLineGet_43:
   \   00000590   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000592   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000596   0x21FF             MOVS     R1,#+255
   \   00000598   0x5429             STRB     R1,[R5, R0]
   \   0000059A   0xE004             B.N      ??CenterLineGet_42
   2473                      }
   2474                    }
   2475                }
   2476                else
   2477                {
   2478                  CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_40:
   \   0000059C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000059E   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000005A2   0x21FF             MOVS     R1,#+255
   \   000005A4   0x5429             STRB     R1,[R5, R0]
   2479                }
   2480                
   2481                if(row == 0) break;
   \                     ??CenterLineGet_42:
   \   000005A6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005A8   0x2D00             CMP      R5,#+0
   \   000005AA   0xD185             BNE.N    ??CenterLineGet_39
   2482              }       
   2483              if(row == 0) return 1;
   \   000005AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005AE   0x2D00             CMP      R5,#+0
   \   000005B0   0xD101             BNE.N    ??CenterLineGet_31
   \   000005B2   0x2001             MOVS     R0,#+1
   \   000005B4   0xE0CA             B.N      ??CenterLineGet_1
   2484            } // end of if
   2485            
   2486            //右黑线提取成功，左黑线提取失败。就基本上按右线来估计中心线。
   2487            if((BlackLeftDone == 0) && (BlackRightDone == 1))
   \                     ??CenterLineGet_31:
   \   000005B6   0x.... 0x....      LDR.W    R0,??DataTable26_1
   \   000005BA   0x7800             LDRB     R0,[R0, #+0]
   \   000005BC   0x2800             CMP      R0,#+0
   \   000005BE   0xF040 0x80C4      BNE.W    ??CenterLineGet_47
   \   000005C2   0x.... 0x....      LDR.W    R0,??DataTable26_2
   \   000005C6   0x7800             LDRB     R0,[R0, #+0]
   \   000005C8   0x2801             CMP      R0,#+1
   \   000005CA   0xF040 0x80BE      BNE.W    ??CenterLineGet_47
   2488            {
   2489              //找中心线的线头。
   2490              for(row = CameraHight - 1; row > CameraHight - BlackStep1Size; row --)
   \   000005CE   0x2531             MOVS     R5,#+49
   \   000005D0   0xE005             B.N      ??CenterLineGet_48
   2491              {
   2492                //找右线有效值。 //原为连续两行找有效值，现改为一行。
   2493                if(BlackRightLoc[row][0] != MaxValUint8)
   2494                {
   2495                  if(CenterLocStore != MaxValUint8)
   2496                  {
   2497                    CenterLineLoc[row] = BlackRightLoc[row][0] - CenterLocStore;
   2498                  }
   2499                  else
   2500                  {
   2501                    CenterLineLoc[row] = BlackRightLoc[row][0] - CenterLineHalfWidth[row];
   2502                  }
   2503                  break;
   2504                }
   2505                else
   2506                {
   2507                  CenterLineLoc[row] = MaxValUint8;
   \                     ??CenterLineGet_49:
   \   000005D2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005D4   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   000005D8   0x21FF             MOVS     R1,#+255
   \   000005DA   0x5429             STRB     R1,[R5, R0]
   2508                }
   \   000005DC   0x1E6D             SUBS     R5,R5,#+1
   \                     ??CenterLineGet_48:
   \   000005DE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005E0   0x2D10             CMP      R5,#+16
   \   000005E2   0xD32D             BCC.N    ??CenterLineGet_50
   \   000005E4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000005E6   0x2003             MOVS     R0,#+3
   \   000005E8   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   000005EC   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   000005F0   0x7800             LDRB     R0,[R0, #+0]
   \   000005F2   0x28FF             CMP      R0,#+255
   \   000005F4   0xD0ED             BEQ.N    ??CenterLineGet_49
   \   000005F6   0x.... 0x....      LDR.W    R0,??DataTable26_11
   \   000005FA   0x7800             LDRB     R0,[R0, #+0]
   \   000005FC   0x28FF             CMP      R0,#+255
   \   000005FE   0xD00F             BEQ.N    ??CenterLineGet_51
   \   00000600   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000602   0x2003             MOVS     R0,#+3
   \   00000604   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000608   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000060C   0x7800             LDRB     R0,[R0, #+0]
   \   0000060E   0x.... 0x....      LDR.W    R1,??DataTable26_11
   \   00000612   0x7809             LDRB     R1,[R1, #+0]
   \   00000614   0x1A40             SUBS     R0,R0,R1
   \   00000616   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000618   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000061C   0x5468             STRB     R0,[R5, R1]
   \   0000061E   0xE00F             B.N      ??CenterLineGet_52
   \                     ??CenterLineGet_51:
   \   00000620   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000622   0x2003             MOVS     R0,#+3
   \   00000624   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000628   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000062C   0x7800             LDRB     R0,[R0, #+0]
   \   0000062E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000630   0x.... 0x....      LDR.W    R1,??DataTable26_12
   \   00000634   0x5C69             LDRB     R1,[R5, R1]
   \   00000636   0x1A40             SUBS     R0,R0,R1
   \   00000638   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000063A   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   0000063E   0x5468             STRB     R0,[R5, R1]
   2509              }
   2510              //没有找到中心线线头，中心线提取失败。
   2511              if(row <= CameraHight - BlackStep1Size) return 0;
   \                     ??CenterLineGet_52:
   \                     ??CenterLineGet_50:
   \   00000640   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000642   0x2D10             CMP      R5,#+16
   \   00000644   0xD201             BCS.N    ??CenterLineGet_53
   \   00000646   0x2000             MOVS     R0,#+0
   \   00000648   0xE080             B.N      ??CenterLineGet_1
   2512              
   2513              //找到线头，按照左线的趋势进行中心线的估计。
   2514              for(row--; ; row--)
   \                     ??CenterLineGet_53:
   \   0000064A   0x1E6D             SUBS     R5,R5,#+1
   \   0000064C   0xE000             B.N      ??CenterLineGet_54
   \                     ??CenterLineGet_55:
   \   0000064E   0x1E6D             SUBS     R5,R5,#+1
   2515              {
   2516                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CenterLineGet_54:
   \   00000650   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000652   0x2003             MOVS     R0,#+3
   \   00000654   0x.... 0x....      LDR.W    R1,??DataTable26_9
   \   00000658   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000065C   0x7800             LDRB     R0,[R0, #+0]
   \   0000065E   0x28FF             CMP      R0,#+255
   \   00000660   0xD067             BEQ.N    ??CenterLineGet_56
   2517                {
   2518                  //前一行的中心点有效的情况。
   2519                  if(CenterLineLoc[row+1] != MaxValUint8)
   \   00000662   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000664   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000668   0x1828             ADDS     R0,R5,R0
   \   0000066A   0x7840             LDRB     R0,[R0, #+1]
   \   0000066C   0x28FF             CMP      R0,#+255
   \   0000066E   0xD019             BEQ.N    ??CenterLineGet_57
   2520                  {
   2521                    CenterLineLoc[row] = CenterLineLoc[row+1] + BlackRightLoc[row][0] - BlackRightLoc[row+1][0];
   \   00000670   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000672   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000676   0x1828             ADDS     R0,R5,R0
   \   00000678   0x7840             LDRB     R0,[R0, #+1]
   \   0000067A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000067C   0x2103             MOVS     R1,#+3
   \   0000067E   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   00000682   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   00000686   0x7809             LDRB     R1,[R1, #+0]
   \   00000688   0x1808             ADDS     R0,R1,R0
   \   0000068A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000068C   0x2103             MOVS     R1,#+3
   \   0000068E   0x.... 0x....      LDR.W    R2,??DataTable26_9
   \   00000692   0xFB01 0x2105      MLA      R1,R1,R5,R2
   \   00000696   0x78C9             LDRB     R1,[R1, #+3]
   \   00000698   0x1A40             SUBS     R0,R0,R1
   \   0000069A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000069C   0x.... 0x....      LDR.W    R1,??DataTable26_10
   \   000006A0   0x5468             STRB     R0,[R5, R1]
   \   000006A2   0xE04A             B.N      ??CenterLineGet_58
   2522                  }
   2523                  //前一行的中心点无效的情况。
   2524                  else
   2525                  { //首先行数要够小。
   2526                    if(row <= CameraHight - 5)
   \                     ??CenterLineGet_57:
   \   000006A4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006A6   0x2D2E             CMP      R5,#+46
   \   000006A8   0xD23D             BCS.N    ??CenterLineGet_59
   2527                    { //连续3行查找是否有中心线有效的行。
   2528                      for(i = 2; i <= 4; i++)
   \   000006AA   0x2102             MOVS     R1,#+2
   \   000006AC   0xE000             B.N      ??CenterLineGet_60
   \                     ??CenterLineGet_61:
   \   000006AE   0x1C49             ADDS     R1,R1,#+1
   \                     ??CenterLineGet_60:
   \   000006B0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006B2   0x2905             CMP      R1,#+5
   \   000006B4   0xD22E             BCS.N    ??CenterLineGet_62
   2529                      {
   2530                        if((CenterLineLoc[row+i] != MaxValUint8)&&(BlackRightLoc[row+i][0] != MaxValUint8))
   \   000006B6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006B8   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   000006BC   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   000006C0   0x5C80             LDRB     R0,[R0, R2]
   \   000006C2   0x28FF             CMP      R0,#+255
   \   000006C4   0xD0F3             BEQ.N    ??CenterLineGet_61
   \   000006C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006C8   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   000006CC   0x2203             MOVS     R2,#+3
   \   000006CE   0x.... 0x....      LDR.W    R3,??DataTable26_9
   \   000006D2   0xFB02 0x3000      MLA      R0,R2,R0,R3
   \   000006D6   0x7800             LDRB     R0,[R0, #+0]
   \   000006D8   0x28FF             CMP      R0,#+255
   \   000006DA   0xD0E8             BEQ.N    ??CenterLineGet_61
   2531                        {
   2532                          CenterLineLoc[row] = CenterLineLoc[row+i] + BlackRightLoc[row][0] - BlackRightLoc[row+i][0];
   \   000006DC   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006DE   0xFA51 0xF085      UXTAB    R0,R1,R5
   \   000006E2   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   000006E6   0x5C80             LDRB     R0,[R0, R2]
   \   000006E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000006EA   0x2203             MOVS     R2,#+3
   \   000006EC   0x.... 0x....      LDR.W    R3,??DataTable26_9
   \   000006F0   0xFB02 0x3205      MLA      R2,R2,R5,R3
   \   000006F4   0x7812             LDRB     R2,[R2, #+0]
   \   000006F6   0x1810             ADDS     R0,R2,R0
   \   000006F8   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000006FA   0xFA51 0xF285      UXTAB    R2,R1,R5
   \   000006FE   0x2303             MOVS     R3,#+3
   \   00000700   0x.... 0x....      LDR.W    R4,??DataTable26_9
   \   00000704   0xFB03 0x4202      MLA      R2,R3,R2,R4
   \   00000708   0x7812             LDRB     R2,[R2, #+0]
   \   0000070A   0x1A80             SUBS     R0,R0,R2
   \   0000070C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000070E   0x.... 0x....      LDR.W    R2,??DataTable26_10
   \   00000712   0x54A8             STRB     R0,[R5, R2]
   2533                          break;
   2534                        }
   2535                      }
   2536                      //连续3行没找到符合要求的行，置无效值。
   2537                      if(i == 5) CenterLineLoc[row] = MaxValUint8; 
   \                     ??CenterLineGet_62:
   \   00000714   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000716   0x2905             CMP      R1,#+5
   \   00000718   0xD10F             BNE.N    ??CenterLineGet_58
   \   0000071A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000071C   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   00000720   0x21FF             MOVS     R1,#+255
   \   00000722   0x5429             STRB     R1,[R5, R0]
   \   00000724   0xE009             B.N      ??CenterLineGet_58
   2538                    }
   2539                    //行数太高，处理不了。
   2540                    else
   2541                    {
   2542                      CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_59:
   \   00000726   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000728   0x.... 0x....      LDR.W    R0,??DataTable26_10
   \   0000072C   0x21FF             MOVS     R1,#+255
   \   0000072E   0x5429             STRB     R1,[R5, R0]
   \   00000730   0xE003             B.N      ??CenterLineGet_58
   2543                    }
   2544                  }
   2545                }
   2546                else
   2547                {
   2548                  CenterLineLoc[row] = MaxValUint8; //置无效值  
   \                     ??CenterLineGet_56:
   \   00000732   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000734   0x....             LDR.N    R0,??DataTable26_10
   \   00000736   0x21FF             MOVS     R1,#+255
   \   00000738   0x5429             STRB     R1,[R5, R0]
   2549                }
   2550                
   2551                if(row == 0) break;
   \                     ??CenterLineGet_58:
   \   0000073A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000073C   0x2D00             CMP      R5,#+0
   \   0000073E   0xD186             BNE.N    ??CenterLineGet_55
   2552              }       
   2553              if(row == 0) return 1;
   \   00000740   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000742   0x2D00             CMP      R5,#+0
   \   00000744   0xD101             BNE.N    ??CenterLineGet_47
   \   00000746   0x2001             MOVS     R0,#+1
   \   00000748   0xE000             B.N      ??CenterLineGet_1
   2554            } // end of if
   2555            
   2556            return 0; 
   \                     ??CenterLineGet_47:
   \   0000074A   0x2000             MOVS     R0,#+0
   \                     ??CenterLineGet_1:
   \   0000074C   0xBD70             POP      {R4-R6,PC}       ;; return
   2557          }
   2558          
   2559          //中心线补充处理，若到不了第25行，就补到第25行。超过250就置成250。

   \                                 In section .text, align 2, keep-with-next
   2560          uint8 CenterLineGetCom(void)
   2561          {
   2562            uint8 row;
   2563            
   2564            for(row = 0; ; row++)
   \                     CenterLineGetCom:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0xE000             B.N      ??CenterLineGetCom_0
   \                     ??CenterLineGetCom_1:
   \   00000004   0x1C40             ADDS     R0,R0,#+1
   2565            {
   2566              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CenterLineGetCom_0:
   \   00000006   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000008   0x....             LDR.N    R1,??DataTable26_10
   \   0000000A   0x5C41             LDRB     R1,[R0, R1]
   \   0000000C   0x29FF             CMP      R1,#+255
   \   0000000E   0xD0F9             BEQ.N    ??CenterLineGetCom_1
   2567              {
   2568                if(row < CenterKeyLine)
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable30
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD201             BCS.N    ??CenterLineGetCom_2
   2569                {
   2570                  break;
   \   0000001C   0xE041             B.N      ??CenterLineGetCom_3
   2571                }
   2572                else
   2573                {
   2574                  for(; ; row--)
   \                     ??CenterLineGetCom_4:
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   2575                  {
   2576                    if(CenterLineLoc[row] + CenterLineLoc[row] - CenterLineLoc[row+1] < 0)
   \                     ??CenterLineGetCom_2:
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x....             LDR.N    R1,??DataTable26_10
   \   00000024   0x5C41             LDRB     R1,[R0, R1]
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x....             LDR.N    R2,??DataTable26_10
   \   0000002A   0x5C82             LDRB     R2,[R0, R2]
   \   0000002C   0x1851             ADDS     R1,R2,R1
   \   0000002E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000030   0x....             LDR.N    R2,??DataTable26_10
   \   00000032   0x1882             ADDS     R2,R0,R2
   \   00000034   0x7852             LDRB     R2,[R2, #+1]
   \   00000036   0x1A89             SUBS     R1,R1,R2
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD506             BPL.N    ??CenterLineGetCom_5
   2577                    {
   2578                      CenterLineLoc[row-1] = 0;
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0x....             LDR.N    R1,??DataTable26_10
   \   00000040   0x1841             ADDS     R1,R0,R1
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0xF801 0x2C01      STRB     R2,[R1, #-1]
   \   00000048   0xE025             B.N      ??CenterLineGetCom_6
   2579                    }
   2580                    else if(CenterLineLoc[row] + CenterLineLoc[row] - CenterLineLoc[row+1] > CameraRealWidth - 1)
   \                     ??CenterLineGetCom_5:
   \   0000004A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004C   0x....             LDR.N    R1,??DataTable26_10
   \   0000004E   0x5C41             LDRB     R1,[R0, R1]
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x....             LDR.N    R2,??DataTable26_10
   \   00000054   0x5C82             LDRB     R2,[R0, R2]
   \   00000056   0x1851             ADDS     R1,R2,R1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x....             LDR.N    R2,??DataTable26_10
   \   0000005C   0x1882             ADDS     R2,R0,R2
   \   0000005E   0x7852             LDRB     R2,[R2, #+1]
   \   00000060   0x1A89             SUBS     R1,R1,R2
   \   00000062   0x29FA             CMP      R1,#+250
   \   00000064   0xDB06             BLT.N    ??CenterLineGetCom_7
   2581                    {
   2582                      CenterLineLoc[row-1] = CameraRealWidth - 1;
   \   00000066   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000068   0x....             LDR.N    R1,??DataTable26_10
   \   0000006A   0x1841             ADDS     R1,R0,R1
   \   0000006C   0x22F9             MOVS     R2,#+249
   \   0000006E   0xF801 0x2C01      STRB     R2,[R1, #-1]
   \   00000072   0xE010             B.N      ??CenterLineGetCom_6
   2583                    }
   2584                    else
   2585                    {
   2586                      CenterLineLoc[row-1] = CenterLineLoc[row] + CenterLineLoc[row] - CenterLineLoc[row+1];
   \                     ??CenterLineGetCom_7:
   \   00000074   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000076   0x....             LDR.N    R1,??DataTable26_10
   \   00000078   0x5C41             LDRB     R1,[R0, R1]
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0x....             LDR.N    R2,??DataTable26_10
   \   0000007E   0x5C82             LDRB     R2,[R0, R2]
   \   00000080   0x1851             ADDS     R1,R2,R1
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x....             LDR.N    R2,??DataTable26_10
   \   00000086   0x1882             ADDS     R2,R0,R2
   \   00000088   0x7852             LDRB     R2,[R2, #+1]
   \   0000008A   0x1A89             SUBS     R1,R1,R2
   \   0000008C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008E   0x....             LDR.N    R2,??DataTable26_10
   \   00000090   0x1882             ADDS     R2,R0,R2
   \   00000092   0xF802 0x1C01      STRB     R1,[R2, #-1]
   2587                    }
   2588                    if(row <= CenterKeyLine) break;          
   \                     ??CenterLineGetCom_6:
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable30
   \   0000009A   0x7809             LDRB     R1,[R1, #+0]
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x4281             CMP      R1,R0
   \   000000A0   0xD3BD             BCC.N    ??CenterLineGetCom_4
   2589                  }
   2590                  break;
   2591                }
   2592              }
   2593            }
   2594            
   2595            return 1;
   \                     ??CenterLineGetCom_3:
   \   000000A2   0x2001             MOVS     R0,#+1
   \   000000A4   0x4770             BX       LR               ;; return
   2596          }
   2597          
   2598          
   2599          
   2600          
   2601          
   2602          //图像重新赋值,行不变（行中DMA中变化，选取需要的行），列无法在DMA中变化，就在这里变化。
   2603          ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。

   \                                 In section .text, align 2, keep-with-next
   2604          void ImgPut(void)
   2605          {
   \                     ImgPut:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   2606              uint16 i, j, k, temp1, temp2;   
   2607              
   2608              temp1 = CameraWidth/2 - CameraRealWidth/2 - 1;
   \   00000002   0x2322             MOVS     R3,#+34
   2609              temp2 = CameraWidth/2 + CameraRealWidth/2 - 1;
   \   00000004   0xF44F 0x748E      MOV      R4,#+284
   2610              
   2611              for(i = 0; i < CameraHight; i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE017             B.N      ??ImgPut_0
   2612              {
   2613                k = 0;
   2614                for(j = temp1; j < temp2; j++)
   2615                {
   2616                  ImgNew[i][k] = ImgRaw[i][j];
   \                     ??ImgPut_1:
   \   0000000C   0xB292             UXTH     R2,R2            ;; ZeroExt  R2,R2,#+16,#+16
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x25FA             MOVS     R5,#+250
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable30_1
   \   00000016   0xFB05 0x6500      MLA      R5,R5,R0,R6
   \   0000001A   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   0000001C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001E   0xF44F 0x76A0      MOV      R6,#+320
   \   00000022   0x.... 0x....      LDR.W    R7,??DataTable30_2
   \   00000026   0xFB06 0x7600      MLA      R6,R6,R0,R7
   \   0000002A   0x5D8E             LDRB     R6,[R1, R6]
   \   0000002C   0x5556             STRB     R6,[R2, R5]
   2617                  k++;
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   2618                }
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \                     ??ImgPut_2:
   \   00000032   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000034   0xB2A4             UXTH     R4,R4            ;; ZeroExt  R4,R4,#+16,#+16
   \   00000036   0x42A1             CMP      R1,R4
   \   00000038   0xD3E8             BCC.N    ??ImgPut_1
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \                     ??ImgPut_0:
   \   0000003C   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000003E   0x2832             CMP      R0,#+50
   \   00000040   0xD202             BCS.N    ??ImgPut_3
   \   00000042   0x2200             MOVS     R2,#+0
   \   00000044   0x0019             MOVS     R1,R3
   \   00000046   0xE7F4             B.N      ??ImgPut_2
   2619              }
   2620          }
   \                     ??ImgPut_3:
   \   00000048   0xBCF0             POP      {R4-R7}
   \   0000004A   0x4770             BX       LR               ;; return
   2621          
   2622          
   2623          
   2624          
   2625          
   2626          //中心线离散度求取函数。自身的离散程度，和中心线的。

   \                                 In section .text, align 2, keep-with-next
   2627          void ErrorGet(void)
   2628          {
   \                     ErrorGet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   2629            uint8 row;
   2630            uint8 avg = 0;
   \   00000002   0x2700             MOVS     R7,#+0
   2631            float temp;
   2632            uint8 index;
   2633            //求取平均值
   2634            temp = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   2635            index = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   2636            for(row = CameraHight - 1; ; row--)
   \   00000008   0x2631             MOVS     R6,#+49
   \   0000000A   0xE000             B.N      ??ErrorGet_0
   \                     ??ErrorGet_1:
   \   0000000C   0x1E76             SUBS     R6,R6,#+1
   2637            {
   2638              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??ErrorGet_0:
   \   0000000E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000010   0x....             LDR.N    R0,??DataTable26_10
   \   00000012   0x5C30             LDRB     R0,[R6, R0]
   \   00000014   0x28FF             CMP      R0,#+255
   \   00000016   0xD009             BEQ.N    ??ErrorGet_2
   2639              {
   2640                temp += CenterLineLoc[row];
   \   00000018   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001A   0x....             LDR.N    R0,??DataTable26_10
   \   0000001C   0x5C30             LDRB     R0,[R6, R0]
   \   0000001E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000022   0x0021             MOVS     R1,R4
   \   00000024   0x.... 0x....      BL       __aeabi_fadd
   \   00000028   0x0004             MOVS     R4,R0
   2641                index++;
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   2642              }
   2643              if(row == 0) break;
   \                     ??ErrorGet_2:
   \   0000002C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD1EC             BNE.N    ??ErrorGet_1
   2644            }
   2645            avg = (uint8)(temp / index);
   \   00000032   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x.... 0x....      BL       __aeabi_ui2f
   \   0000003A   0x0001             MOVS     R1,R0
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000042   0x.... 0x....      BL       __aeabi_f2iz
   \   00000046   0x0007             MOVS     R7,R0
   2646            /*
   2647            //1. 先取线头
   2648            for(row = CameraHight - 1; ; row--)
   2649            {
   2650              if(CenterLineLoc[row] != MaxValUint8)
   2651              {
   2652                avg = CenterLineLoc[row];
   2653                break;
   2654              }
   2655              if(row == 0) break;
   2656            }
   2657            //2. 叠加求平均
   2658            for(row--; ; row--)
   2659            {
   2660              if(CenterLineLoc[row] != MaxValUint8)
   2661              {
   2662                avg = (avg + CenterLineLoc[row]) / 2;
   2663              }
   2664              if(row == 0) break;    
   2665            }
   2666            */
   2667            
   2668          
   2669            temp = 0;
   \   00000048   0x2400             MOVS     R4,#+0
   2670            index = 0;
   \   0000004A   0x2500             MOVS     R5,#+0
   2671            for(row = CameraHight - 1; ; row--)
   \   0000004C   0x2631             MOVS     R6,#+49
   \   0000004E   0xE000             B.N      ??ErrorGet_3
   \                     ??ErrorGet_4:
   \   00000050   0x1E76             SUBS     R6,R6,#+1
   2672            {
   2673              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??ErrorGet_3:
   \   00000052   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000054   0x....             LDR.N    R0,??DataTable26_10
   \   00000056   0x5C30             LDRB     R0,[R6, R0]
   \   00000058   0x28FF             CMP      R0,#+255
   \   0000005A   0xD00D             BEQ.N    ??ErrorGet_5
   2674              {
   2675                temp += AbsRe(CenterLineLoc[row], avg);
   \   0000005C   0x0039             MOVS     R1,R7
   \   0000005E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x....             LDR.N    R0,??DataTable26_10
   \   00000064   0x5C30             LDRB     R0,[R6, R0]
   \   00000066   0x.... 0x....      BL       AbsRe
   \   0000006A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000006E   0x0021             MOVS     R1,R4
   \   00000070   0x.... 0x....      BL       __aeabi_fadd
   \   00000074   0x0004             MOVS     R4,R0
   2676                index++;
   \   00000076   0x1C6D             ADDS     R5,R5,#+1
   2677              }
   2678              if(row == 0) break;
   \                     ??ErrorGet_5:
   \   00000078   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000007A   0x2E00             CMP      R6,#+0
   \   0000007C   0xD1E8             BNE.N    ??ErrorGet_4
   2679            }
   2680            ErrorGetSelf = (uint8)(temp / index);
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0x0028             MOVS     R0,R5
   \   00000082   0x.... 0x....      BL       __aeabi_ui2f
   \   00000086   0x0001             MOVS     R1,R0
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000008E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000092   0x.... 0x....      LDR.W    R1,??DataTable30_3
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   2681            ErrorGetCen = AbsRe(avg, PhyCenterCol);
   \   00000098   0x218C             MOVS     R1,#+140
   \   0000009A   0x0038             MOVS     R0,R7
   \   0000009C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009E   0x.... 0x....      BL       AbsRe
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable30_4
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
   2682            
   2683          }
   \   000000A8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2684          
   2685          
   2686          
   2687          //开根号运算
   2688          //本来传进来传出去都是uint16型的，但是我调用的时候只会用到uint8型的，且不会超出255.

   \                                 In section .text, align 2, keep-with-next
   2689          uint16 MathSqrt(uint16 x1)
   2690          {
   2691            uint8 ans = 0, p = 0x80;
   \                     MathSqrt:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x2280             MOVS     R2,#+128
   2692            uint16 x = x1;
   \   00000004   0xE00C             B.N      ??MathSqrt_0
   2693            
   2694            while(p!=0)
   2695            {
   2696              ans += p;
   \                     ??MathSqrt_1:
   \   00000006   0x1851             ADDS     R1,R2,R1
   2697              if(ans * ans > x) ans -=p;
   \   00000008   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xFB01 0xF301      MUL      R3,R1,R1
   \   00000012   0x4298             CMP      R0,R3
   \   00000014   0xDA00             BGE.N    ??MathSqrt_2
   \   00000016   0x1A89             SUBS     R1,R1,R2
   2698              p = (uint8)(p / 2);
   \                     ??MathSqrt_2:
   \   00000018   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001A   0x2302             MOVS     R3,#+2
   \   0000001C   0xFB92 0xF2F3      SDIV     R2,R2,R3
   2699            }
   \                     ??MathSqrt_0:
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD1EF             BNE.N    ??MathSqrt_1
   2700            return ans;  
   \   00000026   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000028   0x0008             MOVS     R0,R1
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x4770             BX       LR               ;; return
   2701          }
   2702          
   2703          //曲线的曲率求取，曲线向右拐（三点为顺时针方向分布），曲率为负，曲线向左拐（三点为逆时钟方向分布），曲率为正
   2704          //K = 4*SABC/AB/BC/AC

   \                                 In section .text, align 2, keep-with-next
   2705          int16 CurveGet(uint8 AX, uint8 AY, uint8 BX, uint8 BY, uint8 CX, uint8 CY)
   2706          {
   \                     CurveGet:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x469B             MOV      R11,R3
   \   0000000C   0x9C0A             LDR      R4,[SP, #+40]
   \   0000000E   0x9D0B             LDR      R5,[SP, #+44]
   2707            int16 SABC_temp; //三角形的面积，有正负。
   2708            int16 tempab, tempbc, tempac;
   2709            int16 AB, BC, AC; //三角形的边长，均为正。
   2710            //int16 K;        //曲率结果，有正负。
   2711            
   2712            SABC_temp = ((BX - AX) * (CY - AY) - (CX - AX) * (BY - AY));
   \   00000010   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000014   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000018   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   0000001C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000022   0xEBB5 0x010A      SUBS     R1,R5,R10
   \   00000026   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000002A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000002E   0xEBBB 0x020A      SUBS     R2,R11,R10
   \   00000032   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0xEBB9 0x0304      SUBS     R3,R9,R4
   \   0000003C   0x435A             MULS     R2,R3,R2
   \   0000003E   0xFB01 0x2600      MLA      R6,R1,R0,R2
   2713            
   2714            tempab = (BX - AX) * (BX - AX) + (BY - AY) * (BY - AY);
   \   00000042   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000046   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   0000004A   0xEBB8 0x0009      SUBS     R0,R8,R9
   \   0000004E   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   00000052   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   00000056   0xEBB8 0x0109      SUBS     R1,R8,R9
   \   0000005A   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000005E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000062   0xEBBB 0x020A      SUBS     R2,R11,R10
   \   00000066   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   0000006A   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   0000006E   0xEBBB 0x030A      SUBS     R3,R11,R10
   \   00000072   0x435A             MULS     R2,R3,R2
   \   00000074   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2715            if(tempab > 100) 
   \   00000078   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000007A   0x2865             CMP      R0,#+101
   \   0000007C   0xDB0A             BLT.N    ??CurveGet_0
   2716            {
   2717              AB = MathSqrt(tempab / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   0000007E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000080   0x2164             MOVS     R1,#+100
   \   00000082   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000086   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000088   0x.... 0x....      BL       MathSqrt
   \   0000008C   0x210A             MOVS     R1,#+10
   \   0000008E   0xFB01 0xF700      MUL      R7,R1,R0
   \   00000092   0xE003             B.N      ??CurveGet_1
   2718            }
   2719            else
   2720            {
   2721              AB = MathSqrt(tempab);
   \                     ??CurveGet_0:
   \   00000094   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000096   0x.... 0x....      BL       MathSqrt
   \   0000009A   0x0007             MOVS     R7,R0
   2722            }
   2723            
   2724            tempbc = (BX - CX) * (BX - CX) + (BY - CY) * (BY - CY);
   \                     ??CurveGet_1:
   \   0000009C   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000A0   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000A2   0xEBB8 0x0004      SUBS     R0,R8,R4
   \   000000A6   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   000000AA   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000AC   0xEBB8 0x0104      SUBS     R1,R8,R4
   \   000000B0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000B4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B6   0xEBBB 0x0205      SUBS     R2,R11,R5
   \   000000BA   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0xEBBB 0x0305      SUBS     R3,R11,R5
   \   000000C4   0x435A             MULS     R2,R3,R2
   \   000000C6   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2725            if(tempbc > 100) 
   \   000000CA   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000CC   0x2865             CMP      R0,#+101
   \   000000CE   0xDB0A             BLT.N    ??CurveGet_2
   2726            {
   2727              BC = MathSqrt(tempbc / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   000000D0   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   000000D2   0x2164             MOVS     R1,#+100
   \   000000D4   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   000000D8   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000DA   0x.... 0x....      BL       MathSqrt
   \   000000DE   0x210A             MOVS     R1,#+10
   \   000000E0   0xFB01 0xF800      MUL      R8,R1,R0
   \   000000E4   0xE003             B.N      ??CurveGet_3
   2728            }
   2729            else
   2730            {
   2731              BC = MathSqrt(tempbc);
   \                     ??CurveGet_2:
   \   000000E6   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000E8   0x.... 0x....      BL       MathSqrt
   \   000000EC   0x4680             MOV      R8,R0
   2732            }
   2733            
   2734            tempac = (CX - AX) * (CX - AX) + (CY - AY) * (CY - AY);
   \                     ??CurveGet_3:
   \   000000EE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000F0   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000F4   0xEBB4 0x0009      SUBS     R0,R4,R9
   \   000000F8   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000FA   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000FE   0xEBB4 0x0109      SUBS     R1,R4,R9
   \   00000102   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000104   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000108   0xEBB5 0x020A      SUBS     R2,R5,R10
   \   0000010C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010E   0xFA5F 0xFA8A      UXTB     R10,R10          ;; ZeroExt  R10,R10,#+24,#+24
   \   00000112   0xEBB5 0x030A      SUBS     R3,R5,R10
   \   00000116   0x435A             MULS     R2,R3,R2
   \   00000118   0xFB01 0x2000      MLA      R0,R1,R0,R2
   2735            if(tempac > 100) 
   \   0000011C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000011E   0x2865             CMP      R0,#+101
   \   00000120   0xDB09             BLT.N    ??CurveGet_4
   2736            {
   2737              AC = MathSqrt(tempac / 100) * 10; //失掉两位的精度，因为求根运算范围的限制。
   \   00000122   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000124   0x2164             MOVS     R1,#+100
   \   00000126   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000012A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000012C   0x.... 0x....      BL       MathSqrt
   \   00000130   0x210A             MOVS     R1,#+10
   \   00000132   0x4348             MULS     R0,R1,R0
   \   00000134   0xE002             B.N      ??CurveGet_5
   2738            }
   2739            else
   2740            {
   2741              AC = MathSqrt(tempac);
   \                     ??CurveGet_4:
   \   00000136   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000138   0x.... 0x....      BL       MathSqrt
   2742            }
   2743            
   2744            return (CurveGetCompen * SABC_temp / AB / BC / AC);
   \                     ??CurveGet_5:
   \   0000013C   0x.... 0x....      LDR.W    R1,??DataTable30_5
   \   00000140   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000144   0xB236             SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
   \   00000146   0x4371             MULS     R1,R6,R1
   \   00000148   0xB23F             SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
   \   0000014A   0xFB91 0xF1F7      SDIV     R1,R1,R7
   \   0000014E   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000152   0xFB91 0xF1F8      SDIV     R1,R1,R8
   \   00000156   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000158   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000015C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000015E   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2745          }
   2746          
   2747          
   2748          
   2749          //SABC的面积求取，顺时针则返回负值，逆时针则返回正值。
   2750          //以左下角为原点，向右为x轴正方向(0~249)，向上为y轴正方向(0~49)。

   \                                 In section .text, align 2, keep-with-next
   2751          int16 SABCGet(uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 x3, uint8 y3)
   2752          {
   \                     SABCGet:
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x9D02             LDR      R5,[SP, #+8]
   \   00000004   0x9C03             LDR      R4,[SP, #+12]
   2753            int16 SABC_temp;
   2754            
   2755            SABC_temp = ((x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1)) / 2;
   \   00000006   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000008   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000A   0x1A12             SUBS     R2,R2,R0
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000010   0x1A64             SUBS     R4,R4,R1
   \   00000012   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x1A59             SUBS     R1,R3,R1
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0x1B40             SUBS     R0,R0,R5
   \   0000001E   0xFB00 0xF001      MUL      R0,R0,R1
   \   00000022   0xFB04 0x0002      MLA      R0,R4,R2,R0
   \   00000026   0x2102             MOVS     R1,#+2
   \   00000028   0xFB90 0xF0F1      SDIV     R0,R0,R1
   2756            
   2757            return SABC_temp;
   \   0000002C   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
   2758          }
   2759          
   2760          
   2761          //曲率符号求取
   2762          //影响：CurveSL, CurveSC, CurveSR, 0无效，1正，2负
   2763          //      SABCL, SABCC, SABCR

   \                                 In section .text, align 2, keep-with-next
   2764          uint8 CurveSignGet(void)
   2765          {
   \                     CurveSignGet:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2766            uint8 row;
   2767            uint8 temp;
   2768            
   2769            //1. 中心线曲率符号求取
   2770            //曲率符号预先清零。
   2771            CurveLineChosenC1 = MaxValUint8;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   00000008   0x21FF             MOVS     R1,#+255
   \   0000000A   0x7001             STRB     R1,[R0, #+0]
   2772            CurveLineChosenC2 = MaxValUint8;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   00000010   0x21FF             MOVS     R1,#+255
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   2773            CurveLineChosenC3 = MaxValUint8;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable30_8
   \   00000018   0x21FF             MOVS     R1,#+255
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
   2774            
   2775            //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2776            for(row = 0; ; row++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE000             B.N      ??CurveSignGet_0
   \                     ??CurveSignGet_1:
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   2777            {
   2778              if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_0:
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x2830             CMP      R0,#+48
   \   00000026   0xD305             BCC.N    ??CurveSignGet_2
   2779              {
   2780                CurveLineChosenC1 = MaxValUint8;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   0000002C   0x21FF             MOVS     R1,#+255
   \   0000002E   0x7001             STRB     R1,[R0, #+0]
   2781                return 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xE1DD             B.N      ??CurveSignGet_3
   2782              }
   2783              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_2:
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable30_9
   \   0000003A   0x5C41             LDRB     R1,[R0, R1]
   \   0000003C   0x29FF             CMP      R1,#+255
   \   0000003E   0xD0EF             BEQ.N    ??CurveSignGet_1
   2784              {
   2785                CurveLineChosenC1 = row;
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable30_6
   \   00000044   0x7008             STRB     R0,[R1, #+0]
   2786                break;
   2787              }   
   2788            }
   2789            //把第1个有效值到CameraHight-1的距离分成2段。
   2790            temp = (CameraHight - 1 - row) / 2;
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2791            if(temp == 0) 
   \   00000052   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000054   0x2900             CMP      R1,#+0
   \   00000056   0xD105             BNE.N    ??CurveSignGet_4
   2792            {
   2793              CurveLineChosenC1 = MaxValUint8;
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0x7001             STRB     R1,[R0, #+0]
   2794              return 0;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0xE1C5             B.N      ??CurveSignGet_3
   2795            }
   2796            
   2797            //曲率基于的行2 CurveLineChosen2
   2798            for(row = CurveLineChosenC1 + temp; ; row++)
   \                     ??CurveSignGet_4:
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x1808             ADDS     R0,R1,R0
   \   0000006C   0xE000             B.N      ??CurveSignGet_5
   \                     ??CurveSignGet_6:
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   2799            {
   2800              if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_5:
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2831             CMP      R0,#+49
   \   00000074   0xD309             BCC.N    ??CurveSignGet_7
   2801              {
   2802                CurveLineChosenC1 = MaxValUint8;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   0000007A   0x21FF             MOVS     R1,#+255
   \   0000007C   0x7001             STRB     R1,[R0, #+0]
   2803                CurveLineChosenC2 = MaxValUint8;
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   00000082   0x21FF             MOVS     R1,#+255
   \   00000084   0x7001             STRB     R1,[R0, #+0]
   2804                return 0;
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE1B2             B.N      ??CurveSignGet_3
   2805              }
   2806              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_7:
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x.... 0x....      LDR.W    R2,??DataTable30_9
   \   00000090   0x5C82             LDRB     R2,[R0, R2]
   \   00000092   0x2AFF             CMP      R2,#+255
   \   00000094   0xD0EB             BEQ.N    ??CurveSignGet_6
   2807              {
   2808                CurveLineChosenC2 = row;
   \   00000096   0x.... 0x....      LDR.W    R2,??DataTable30_7
   \   0000009A   0x7010             STRB     R0,[R2, #+0]
   2809                break;
   2810              }
   2811            }
   2812            
   2813            //曲率基于的行3 CurveLineChosen3
   2814            for(row = CurveLineChosenC2 + temp; ; row++)
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   000000A0   0x7800             LDRB     R0,[R0, #+0]
   \   000000A2   0x1808             ADDS     R0,R1,R0
   \   000000A4   0xE000             B.N      ??CurveSignGet_8
   \                     ??CurveSignGet_9:
   \   000000A6   0x1C40             ADDS     R0,R0,#+1
   2815            {
   2816              if(row >= CameraHight) 
   \                     ??CurveSignGet_8:
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x2832             CMP      R0,#+50
   \   000000AC   0xD30D             BCC.N    ??CurveSignGet_10
   2817              {
   2818                CurveLineChosenC1 = MaxValUint8;
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   000000B2   0x21FF             MOVS     R1,#+255
   \   000000B4   0x7001             STRB     R1,[R0, #+0]
   2819                CurveLineChosenC2 = MaxValUint8;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   000000BA   0x21FF             MOVS     R1,#+255
   \   000000BC   0x7001             STRB     R1,[R0, #+0]
   2820                CurveLineChosenC3 = MaxValUint8;
   \   000000BE   0x.... 0x....      LDR.W    R0,??DataTable30_8
   \   000000C2   0x21FF             MOVS     R1,#+255
   \   000000C4   0x7001             STRB     R1,[R0, #+0]
   2821                return 0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0xE192             B.N      ??CurveSignGet_3
   2822              }
   2823              if(CenterLineLoc[row] != MaxValUint8)
   \                     ??CurveSignGet_10:
   \   000000CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable30_9
   \   000000D0   0x5C41             LDRB     R1,[R0, R1]
   \   000000D2   0x29FF             CMP      R1,#+255
   \   000000D4   0xD0E7             BEQ.N    ??CurveSignGet_9
   2824              {
   2825                CurveLineChosenC3 = row;
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable30_8
   \   000000DA   0x7008             STRB     R0,[R1, #+0]
   2826                break;
   2827              }
   2828            } 
   2829            //SABCC中心线曲率三角形面积的求取
   2830            //SABCC = SABCGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
   2831            //                CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
   2832            //                CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
   2833            //                );
   2834            CURVEC = CurveGet(CenterLineLoc[CurveLineChosenC1], CameraHight - 1 - CurveLineChosenC1,
   2835                             CenterLineLoc[CurveLineChosenC2], CameraHight - 1 - CurveLineChosenC2,
   2836                             CenterLineLoc[CurveLineChosenC3], CameraHight - 1 - CurveLineChosenC3
   2837                             );    
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable30_8
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x9001             STR      R0,[SP, #+4]
   \   000000EA   0x.... 0x....      LDR.W    R0,??DataTable30_8
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable30_9
   \   000000F4   0x5C40             LDRB     R0,[R0, R1]
   \   000000F6   0x9000             STR      R0,[SP, #+0]
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   00000102   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000104   0x.... 0x....      LDR.W    R0,??DataTable30_7
   \   00000108   0x7800             LDRB     R0,[R0, #+0]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable30_9
   \   0000010E   0x5C42             LDRB     R2,[R0, R1]
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   0000011A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable30_6
   \   00000120   0x7800             LDRB     R0,[R0, #+0]
   \   00000122   0x.... 0x....      LDR.W    R4,??DataTable30_9
   \   00000126   0x5D00             LDRB     R0,[R0, R4]
   \   00000128   0x.... 0x....      BL       CurveGet
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable30_10
   \   00000130   0x8008             STRH     R0,[R1, #+0]
   2838            
   2839            
   2840            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
   2841            if(BlackLeftDone == 1)
   \   00000132   0x.... 0x....      LDR.W    R0,??DataTable30_11
   \   00000136   0x7800             LDRB     R0,[R0, #+0]
   \   00000138   0x2801             CMP      R0,#+1
   \   0000013A   0xF040 0x80A9      BNE.W    ??CurveSignGet_11
   2842            {
   2843              //2. 左黑线曲率符号求取
   2844              //曲率符号预先清零。
   2845              CurveLineChosenL1 = MaxValUint8;
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   00000142   0x21FF             MOVS     R1,#+255
   \   00000144   0x7001             STRB     R1,[R0, #+0]
   2846              CurveLineChosenL2 = MaxValUint8;
   \   00000146   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   0000014A   0x21FF             MOVS     R1,#+255
   \   0000014C   0x7001             STRB     R1,[R0, #+0]
   2847              CurveLineChosenL3 = MaxValUint8;
   \   0000014E   0x.... 0x....      LDR.W    R0,??DataTable30_14
   \   00000152   0x21FF             MOVS     R1,#+255
   \   00000154   0x7001             STRB     R1,[R0, #+0]
   2848              
   2849              //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2850              for(row = 0; ; row++)
   \   00000156   0x2000             MOVS     R0,#+0
   \   00000158   0xE000             B.N      ??CurveSignGet_12
   \                     ??CurveSignGet_13:
   \   0000015A   0x1C40             ADDS     R0,R0,#+1
   2851              {
   2852                if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_12:
   \   0000015C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000015E   0x2830             CMP      R0,#+48
   \   00000160   0xD305             BCC.N    ??CurveSignGet_14
   2853                {
   2854                  CurveLineChosenL1 = MaxValUint8;
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   00000166   0x21FF             MOVS     R1,#+255
   \   00000168   0x7001             STRB     R1,[R0, #+0]
   2855                  return 0;
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0xE140             B.N      ??CurveSignGet_3
   2856                }
   2857                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_14:
   \   0000016E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000170   0x2103             MOVS     R1,#+3
   \   00000172   0x.... 0x....      LDR.W    R2,??DataTable30_15
   \   00000176   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000017A   0x7809             LDRB     R1,[R1, #+0]
   \   0000017C   0x29FF             CMP      R1,#+255
   \   0000017E   0xD0EC             BEQ.N    ??CurveSignGet_13
   2858                {
   2859                  CurveLineChosenL1 = row;
   \   00000180   0x.... 0x....      LDR.W    R1,??DataTable30_12
   \   00000184   0x7008             STRB     R0,[R1, #+0]
   2860                  break;
   2861                }   
   2862              }
   2863              //把第1个有效值到CameraHight-1的距离分成2段。
   2864              temp = (CameraHight - 1 - row) / 2;
   \   00000186   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000188   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   0000018C   0x2102             MOVS     R1,#+2
   \   0000018E   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2865              if(temp == 0) 
   \   00000192   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000194   0x2900             CMP      R1,#+0
   \   00000196   0xD105             BNE.N    ??CurveSignGet_15
   2866              {
   2867                CurveLineChosenL1 = MaxValUint8;
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   0000019C   0x21FF             MOVS     R1,#+255
   \   0000019E   0x7001             STRB     R1,[R0, #+0]
   2868                return 0;
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0xE125             B.N      ??CurveSignGet_3
   2869              }
   2870              
   2871              //曲率基于的行2 CurveLineChosen2
   2872              for(row = CurveLineChosenL1 + temp; ; row++)
   \                     ??CurveSignGet_15:
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   000001A8   0x7800             LDRB     R0,[R0, #+0]
   \   000001AA   0x1808             ADDS     R0,R1,R0
   \   000001AC   0xE000             B.N      ??CurveSignGet_16
   \                     ??CurveSignGet_17:
   \   000001AE   0x1C40             ADDS     R0,R0,#+1
   2873              {
   2874                if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_16:
   \   000001B0   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001B2   0x2831             CMP      R0,#+49
   \   000001B4   0xD309             BCC.N    ??CurveSignGet_18
   2875                {
   2876                  CurveLineChosenL1 = MaxValUint8;
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   000001BA   0x21FF             MOVS     R1,#+255
   \   000001BC   0x7001             STRB     R1,[R0, #+0]
   2877                  CurveLineChosenL2 = MaxValUint8;
   \   000001BE   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   000001C2   0x21FF             MOVS     R1,#+255
   \   000001C4   0x7001             STRB     R1,[R0, #+0]
   2878                  return 0;
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0xE112             B.N      ??CurveSignGet_3
   2879                }
   2880                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_18:
   \   000001CA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CC   0x2203             MOVS     R2,#+3
   \   000001CE   0x.... 0x....      LDR.W    R3,??DataTable30_15
   \   000001D2   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   000001D6   0x7812             LDRB     R2,[R2, #+0]
   \   000001D8   0x2AFF             CMP      R2,#+255
   \   000001DA   0xD0E8             BEQ.N    ??CurveSignGet_17
   2881                {
   2882                  CurveLineChosenL2 = row;
   \   000001DC   0x.... 0x....      LDR.W    R2,??DataTable30_13
   \   000001E0   0x7010             STRB     R0,[R2, #+0]
   2883                  break;
   2884                }
   2885              }
   2886              
   2887              //曲率基于的行3 CurveLineChosen3
   2888              for(row = CurveLineChosenL2 + temp; ; row++)
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   000001E6   0x7800             LDRB     R0,[R0, #+0]
   \   000001E8   0x1808             ADDS     R0,R1,R0
   \   000001EA   0xE000             B.N      ??CurveSignGet_19
   \                     ??CurveSignGet_20:
   \   000001EC   0x1C40             ADDS     R0,R0,#+1
   2889              {
   2890                if(row >= CameraHight) 
   \                     ??CurveSignGet_19:
   \   000001EE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001F0   0x2832             CMP      R0,#+50
   \   000001F2   0xD30D             BCC.N    ??CurveSignGet_21
   2891                {
   2892                  CurveLineChosenL1 = MaxValUint8;
   \   000001F4   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   000001F8   0x21FF             MOVS     R1,#+255
   \   000001FA   0x7001             STRB     R1,[R0, #+0]
   2893                  CurveLineChosenL2 = MaxValUint8;
   \   000001FC   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   00000200   0x21FF             MOVS     R1,#+255
   \   00000202   0x7001             STRB     R1,[R0, #+0]
   2894                  CurveLineChosenL3 = MaxValUint8;
   \   00000204   0x.... 0x....      LDR.W    R0,??DataTable30_14
   \   00000208   0x21FF             MOVS     R1,#+255
   \   0000020A   0x7001             STRB     R1,[R0, #+0]
   2895                  return 0;
   \   0000020C   0x2000             MOVS     R0,#+0
   \   0000020E   0xE0EF             B.N      ??CurveSignGet_3
   2896                }
   2897                if(BlackLeftLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_21:
   \   00000210   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000212   0x2103             MOVS     R1,#+3
   \   00000214   0x.... 0x....      LDR.W    R2,??DataTable30_15
   \   00000218   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000021C   0x7809             LDRB     R1,[R1, #+0]
   \   0000021E   0x29FF             CMP      R1,#+255
   \   00000220   0xD0E4             BEQ.N    ??CurveSignGet_20
   2898                {
   2899                  CurveLineChosenL3 = row;
   \   00000222   0x.... 0x....      LDR.W    R1,??DataTable30_14
   \   00000226   0x7008             STRB     R0,[R1, #+0]
   2900                  break;
   2901                }
   2902              }      
   2903              //SABCL左黑线曲率三角形面积的求取
   2904              //SABCL = SABCGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
   2905              //               BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
   2906              //               BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
   2907              //               );
   2908              CURVEL = CurveGet(BlackLeftLoc[CurveLineChosenL1][0], CameraHight - 1 - CurveLineChosenL1,
   2909                                BlackLeftLoc[CurveLineChosenL2][0], CameraHight - 1 - CurveLineChosenL2,
   2910                                BlackLeftLoc[CurveLineChosenL3][0], CameraHight - 1 - CurveLineChosenL3
   2911                                );
   \   00000228   0x.... 0x....      LDR.W    R0,??DataTable30_14
   \   0000022C   0x7800             LDRB     R0,[R0, #+0]
   \   0000022E   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   00000232   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000234   0x9001             STR      R0,[SP, #+4]
   \   00000236   0x.... 0x....      LDR.W    R0,??DataTable30_14
   \   0000023A   0x7800             LDRB     R0,[R0, #+0]
   \   0000023C   0x2103             MOVS     R1,#+3
   \   0000023E   0x.... 0x....      LDR.W    R2,??DataTable30_15
   \   00000242   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000246   0x7800             LDRB     R0,[R0, #+0]
   \   00000248   0x9000             STR      R0,[SP, #+0]
   \   0000024A   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   0000024E   0x7800             LDRB     R0,[R0, #+0]
   \   00000250   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   00000254   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000256   0x.... 0x....      LDR.W    R0,??DataTable30_13
   \   0000025A   0x7800             LDRB     R0,[R0, #+0]
   \   0000025C   0x2103             MOVS     R1,#+3
   \   0000025E   0x.... 0x....      LDR.W    R2,??DataTable30_15
   \   00000262   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   00000266   0x7802             LDRB     R2,[R0, #+0]
   \   00000268   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   0000026C   0x7800             LDRB     R0,[R0, #+0]
   \   0000026E   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   00000272   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000274   0x.... 0x....      LDR.W    R0,??DataTable30_12
   \   00000278   0x7800             LDRB     R0,[R0, #+0]
   \   0000027A   0x2403             MOVS     R4,#+3
   \   0000027C   0x.... 0x....      LDR.W    R5,??DataTable30_15
   \   00000280   0xFB04 0x5000      MLA      R0,R4,R0,R5
   \   00000284   0x7800             LDRB     R0,[R0, #+0]
   \   00000286   0x.... 0x....      BL       CurveGet
   \   0000028A   0x.... 0x....      LDR.W    R1,??DataTable30_16
   \   0000028E   0x8008             STRH     R0,[R1, #+0]
   2912              
   2913            }
   2914            
   2915            
   2916            //左右黑线有可能只有一边提取成功，若不成功，就不用费时间了。
   2917            if(BlackRightDone == 1)
   \                     ??CurveSignGet_11:
   \   00000290   0x.... 0x....      LDR.W    R0,??DataTable30_17
   \   00000294   0x7800             LDRB     R0,[R0, #+0]
   \   00000296   0x2801             CMP      R0,#+1
   \   00000298   0xF040 0x80A9      BNE.W    ??CurveSignGet_22
   2918            {
   2919              //3. 右黑线曲率符号求取
   2920              //曲率符号预先清零。
   2921              CurveLineChosenR1 = MaxValUint8;
   \   0000029C   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   000002A0   0x21FF             MOVS     R1,#+255
   \   000002A2   0x7001             STRB     R1,[R0, #+0]
   2922              CurveLineChosenR2 = MaxValUint8;
   \   000002A4   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   000002A8   0x21FF             MOVS     R1,#+255
   \   000002AA   0x7001             STRB     R1,[R0, #+0]
   2923              CurveLineChosenR3 = MaxValUint8;
   \   000002AC   0x.... 0x....      LDR.W    R0,??DataTable30_20
   \   000002B0   0x21FF             MOVS     R1,#+255
   \   000002B2   0x7001             STRB     R1,[R0, #+0]
   2924              
   2925              //曲率基于的行1 CurveLineChosen1，从上到下取第一个有效值。
   2926              for(row = 0; ; row++)
   \   000002B4   0x2000             MOVS     R0,#+0
   \   000002B6   0xE000             B.N      ??CurveSignGet_23
   \                     ??CurveSignGet_24:
   \   000002B8   0x1C40             ADDS     R0,R0,#+1
   2927              {
   2928                if(row >= CameraHight - 2) 
   \                     ??CurveSignGet_23:
   \   000002BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002BC   0x2830             CMP      R0,#+48
   \   000002BE   0xD305             BCC.N    ??CurveSignGet_25
   2929                {
   2930                  CurveLineChosenR1 = MaxValUint8;
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   000002C4   0x21FF             MOVS     R1,#+255
   \   000002C6   0x7001             STRB     R1,[R0, #+0]
   2931                  return 0;
   \   000002C8   0x2000             MOVS     R0,#+0
   \   000002CA   0xE091             B.N      ??CurveSignGet_3
   2932                }
   2933                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_25:
   \   000002CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002CE   0x2103             MOVS     R1,#+3
   \   000002D0   0x.... 0x....      LDR.W    R2,??DataTable30_21
   \   000002D4   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   000002D8   0x7809             LDRB     R1,[R1, #+0]
   \   000002DA   0x29FF             CMP      R1,#+255
   \   000002DC   0xD0EC             BEQ.N    ??CurveSignGet_24
   2934                {
   2935                  CurveLineChosenR1 = row;
   \   000002DE   0x.... 0x....      LDR.W    R1,??DataTable30_18
   \   000002E2   0x7008             STRB     R0,[R1, #+0]
   2936                  break;
   2937                }   
   2938              }
   2939              //把第1个有效值到CameraHight-1的距离分成2段。
   2940              temp = (CameraHight - 1 - row) / 2;
   \   000002E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000002E6   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   000002EA   0x2102             MOVS     R1,#+2
   \   000002EC   0xFB90 0xF1F1      SDIV     R1,R0,R1
   2941              if(temp == 0) 
   \   000002F0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000002F2   0x2900             CMP      R1,#+0
   \   000002F4   0xD105             BNE.N    ??CurveSignGet_26
   2942              {
   2943                CurveLineChosenR1 = MaxValUint8;
   \   000002F6   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   000002FA   0x21FF             MOVS     R1,#+255
   \   000002FC   0x7001             STRB     R1,[R0, #+0]
   2944                return 0;
   \   000002FE   0x2000             MOVS     R0,#+0
   \   00000300   0xE076             B.N      ??CurveSignGet_3
   2945              }
   2946              
   2947              //曲率基于的行2 CurveLineChosen2
   2948              for(row = CurveLineChosenR1 + temp; ; row++)
   \                     ??CurveSignGet_26:
   \   00000302   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   00000306   0x7800             LDRB     R0,[R0, #+0]
   \   00000308   0x1808             ADDS     R0,R1,R0
   \   0000030A   0xE000             B.N      ??CurveSignGet_27
   \                     ??CurveSignGet_28:
   \   0000030C   0x1C40             ADDS     R0,R0,#+1
   2949              {
   2950                if(row >= CameraHight - 1) 
   \                     ??CurveSignGet_27:
   \   0000030E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000310   0x2831             CMP      R0,#+49
   \   00000312   0xD309             BCC.N    ??CurveSignGet_29
   2951                {
   2952                  CurveLineChosenR1 = MaxValUint8;
   \   00000314   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   00000318   0x21FF             MOVS     R1,#+255
   \   0000031A   0x7001             STRB     R1,[R0, #+0]
   2953                  CurveLineChosenR2 = MaxValUint8;
   \   0000031C   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   00000320   0x21FF             MOVS     R1,#+255
   \   00000322   0x7001             STRB     R1,[R0, #+0]
   2954                  return 0;
   \   00000324   0x2000             MOVS     R0,#+0
   \   00000326   0xE063             B.N      ??CurveSignGet_3
   2955                }
   2956                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_29:
   \   00000328   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000032A   0x2203             MOVS     R2,#+3
   \   0000032C   0x.... 0x....      LDR.W    R3,??DataTable30_21
   \   00000330   0xFB02 0x3200      MLA      R2,R2,R0,R3
   \   00000334   0x7812             LDRB     R2,[R2, #+0]
   \   00000336   0x2AFF             CMP      R2,#+255
   \   00000338   0xD0E8             BEQ.N    ??CurveSignGet_28
   2957                {
   2958                  CurveLineChosenR2 = row;
   \   0000033A   0x.... 0x....      LDR.W    R2,??DataTable30_19
   \   0000033E   0x7010             STRB     R0,[R2, #+0]
   2959                  break;
   2960                }
   2961              }
   2962              
   2963              //曲率基于的行3 CurveLineChosen3
   2964              for(row = CurveLineChosenR2 + temp; ; row++)
   \   00000340   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   00000344   0x7800             LDRB     R0,[R0, #+0]
   \   00000346   0x1808             ADDS     R0,R1,R0
   \   00000348   0xE000             B.N      ??CurveSignGet_30
   \                     ??CurveSignGet_31:
   \   0000034A   0x1C40             ADDS     R0,R0,#+1
   2965              {
   2966                if(row >= CameraHight) 
   \                     ??CurveSignGet_30:
   \   0000034C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000034E   0x2832             CMP      R0,#+50
   \   00000350   0xD30D             BCC.N    ??CurveSignGet_32
   2967                {
   2968                  CurveLineChosenR1 = MaxValUint8;
   \   00000352   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   00000356   0x21FF             MOVS     R1,#+255
   \   00000358   0x7001             STRB     R1,[R0, #+0]
   2969                  CurveLineChosenR2 = MaxValUint8;
   \   0000035A   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   0000035E   0x21FF             MOVS     R1,#+255
   \   00000360   0x7001             STRB     R1,[R0, #+0]
   2970                  CurveLineChosenR3 = MaxValUint8;
   \   00000362   0x.... 0x....      LDR.W    R0,??DataTable30_20
   \   00000366   0x21FF             MOVS     R1,#+255
   \   00000368   0x7001             STRB     R1,[R0, #+0]
   2971                  return 0;
   \   0000036A   0x2000             MOVS     R0,#+0
   \   0000036C   0xE040             B.N      ??CurveSignGet_3
   2972                }
   2973                if(BlackRightLoc[row][0] != MaxValUint8)
   \                     ??CurveSignGet_32:
   \   0000036E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000370   0x2103             MOVS     R1,#+3
   \   00000372   0x.... 0x....      LDR.W    R2,??DataTable30_21
   \   00000376   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000037A   0x7809             LDRB     R1,[R1, #+0]
   \   0000037C   0x29FF             CMP      R1,#+255
   \   0000037E   0xD0E4             BEQ.N    ??CurveSignGet_31
   2974                {
   2975                  CurveLineChosenR3 = row;
   \   00000380   0x.... 0x....      LDR.W    R1,??DataTable30_20
   \   00000384   0x7008             STRB     R0,[R1, #+0]
   2976                  break;
   2977                }
   2978              }   
   2979              //SABCR右黑线曲率三角形面积的求取
   2980              //SABCR = SABCGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1, 
   2981              //                BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2, 
   2982              //                BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
   2983              //                );
   2984              CURVER = CurveGet(BlackRightLoc[CurveLineChosenR1][0], CameraHight - 1 - CurveLineChosenR1, 
   2985                                BlackRightLoc[CurveLineChosenR2][0], CameraHight - 1 - CurveLineChosenR2, 
   2986                                BlackRightLoc[CurveLineChosenR3][0], CameraHight - 1 - CurveLineChosenR3
   2987                                );
   \   00000386   0x.... 0x....      LDR.W    R0,??DataTable30_20
   \   0000038A   0x7800             LDRB     R0,[R0, #+0]
   \   0000038C   0xF1D0 0x0031      RSBS     R0,R0,#+49
   \   00000390   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000392   0x9001             STR      R0,[SP, #+4]
   \   00000394   0x.... 0x....      LDR.W    R0,??DataTable30_20
   \   00000398   0x7800             LDRB     R0,[R0, #+0]
   \   0000039A   0x2103             MOVS     R1,#+3
   \   0000039C   0x.... 0x....      LDR.W    R2,??DataTable30_21
   \   000003A0   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000003A4   0x7800             LDRB     R0,[R0, #+0]
   \   000003A6   0x9000             STR      R0,[SP, #+0]
   \   000003A8   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   000003AC   0x7800             LDRB     R0,[R0, #+0]
   \   000003AE   0xF1D0 0x0331      RSBS     R3,R0,#+49
   \   000003B2   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   000003B4   0x.... 0x....      LDR.W    R0,??DataTable30_19
   \   000003B8   0x7800             LDRB     R0,[R0, #+0]
   \   000003BA   0x2103             MOVS     R1,#+3
   \   000003BC   0x.... 0x....      LDR.W    R2,??DataTable30_21
   \   000003C0   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   000003C4   0x7802             LDRB     R2,[R0, #+0]
   \   000003C6   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   000003CA   0x7800             LDRB     R0,[R0, #+0]
   \   000003CC   0xF1D0 0x0131      RSBS     R1,R0,#+49
   \   000003D0   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000003D2   0x.... 0x....      LDR.W    R0,??DataTable30_18
   \   000003D6   0x7800             LDRB     R0,[R0, #+0]
   \   000003D8   0x2403             MOVS     R4,#+3
   \   000003DA   0x.... 0x....      LDR.W    R5,??DataTable30_21
   \   000003DE   0xFB04 0x5000      MLA      R0,R4,R0,R5
   \   000003E2   0x7800             LDRB     R0,[R0, #+0]
   \   000003E4   0x.... 0x....      BL       CurveGet
   \   000003E8   0x.... 0x....      LDR.W    R1,??DataTable30_22
   \   000003EC   0x8008             STRH     R0,[R1, #+0]
   2988               
   2989            }
   2990            
   2991            return 1;
   \                     ??CurveSignGet_22:
   \   000003EE   0x2001             MOVS     R0,#+1
   \                     ??CurveSignGet_3:
   \   000003F0   0xBD3E             POP      {R1-R5,PC}       ;; return
   2992            
   2993          }
   2994          
   2995          
   2996          //赛道类型判断
   2997          //======================================================================
   2998          //函数名：PathJudge
   2999          //功  能：赛道类型判断
   3000          //参  数：无
   3001          //返  回：1成功 0失败
   3002          //影  响：PathType
   3003          //说  明：1. 暂时只有直、左、右的判断。暂时只通过曲率三角形的面积来判断，后面估计要改成完整版的曲率求取公式。
   3004          //        2. PathType: 0未知 1直道 2左中 3右中 4左内 5左外 6右内 7右外
   3005          //             
   3006          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   3007          uint8 PathJudge(void)
   3008          {
   \                     PathJudge:
   \   00000000   0xB580             PUSH     {R7,LR}
   3009            //赛道类型PathType: 0未知 1直道 2左中 3右中 4左内 5左外 6右内 7右外
   3010            PathType = 0;
   \   00000002   0x....             LDR.N    R0,??DataTable30_23
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7001             STRB     R1,[R0, #+0]
   3011            //uint8 row;
   3012            
   3013            //ErrorGet();
   3014            
   3015            ////////////////////////////发现用SABC的方式来判断的话，有可能出现阈值变化很大的情况，估计后面还是得采用完整的曲率求取方法。
   3016            //曲率符号获取成功
   3017            if(CurveSignGet())
   \   00000008   0x.... 0x....      BL       CurveSignGet
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x80D3      BEQ.W    ??PathJudge_0
   3018            {
   3019              //不用判断中心线成功，到这里了肯定是成功的。
   3020              //左右黑线均提取成功，的情况。
   3021              if(BlackLeftDone == 1 && BlackRightDone == 1)
   \   00000012   0x....             LDR.N    R0,??DataTable30_11
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD14E             BNE.N    ??PathJudge_1
   \   0000001A   0x....             LDR.N    R0,??DataTable30_17
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD14A             BNE.N    ??PathJudge_1
   3022              { //全部逆时针，为左弯。而且是小车走在左弯道较为中心的情况。
   3023                if(CURVEL < 0 && CURVEC < 0 && CURVER < 0)
   \   00000022   0x....             LDR.N    R0,??DataTable30_16
   \   00000024   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD50D             BPL.N    ??PathJudge_2
   \   0000002C   0x....             LDR.N    R0,??DataTable30_10
   \   0000002E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD508             BPL.N    ??PathJudge_2
   \   00000036   0x....             LDR.N    R0,??DataTable30_22
   \   00000038   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD503             BPL.N    ??PathJudge_2
   3024                { 
   3025                  PathType = 2;
   \   00000040   0x....             LDR.N    R0,??DataTable30_23
   \   00000042   0x2102             MOVS     R1,#+2
   \   00000044   0x7001             STRB     R1,[R0, #+0]
   \   00000046   0xE037             B.N      ??PathJudge_1
   3026                }
   3027                //全部顺时针，为右弯。而且是小车走在右弯道较为中心的情况。
   3028                else if(CURVEL > 0 && CURVEC > 0 && CURVER > 0)
   \                     ??PathJudge_2:
   \   00000048   0x....             LDR.N    R0,??DataTable30_16
   \   0000004A   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xDB0D             BLT.N    ??PathJudge_3
   \   00000052   0x....             LDR.N    R0,??DataTable30_10
   \   00000054   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000058   0x2801             CMP      R0,#+1
   \   0000005A   0xDB08             BLT.N    ??PathJudge_3
   \   0000005C   0x....             LDR.N    R0,??DataTable30_22
   \   0000005E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000062   0x2801             CMP      R0,#+1
   \   00000064   0xDB03             BLT.N    ??PathJudge_3
   3029                {        
   3030                  PathType = 3;
   \   00000066   0x....             LDR.N    R0,??DataTable30_23
   \   00000068   0x2103             MOVS     R1,#+3
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
   \   0000006C   0xE024             B.N      ??PathJudge_1
   3031                }
   3032                else
   3033                {
   3034                  if(
   3035                    (AbsSelf(CURVEL) < PathStraightLimitL)
   3036                  &&(AbsSelf(CURVEC) < PathStraightLimitC)
   3037                  &&(AbsSelf(CURVER) < PathStraightLimitR)
   3038                    )
   \                     ??PathJudge_3:
   \   0000006E   0x....             LDR.N    R0,??DataTable30_16
   \   00000070   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000074   0x.... 0x....      BL       AbsSelf
   \   00000078   0x....             LDR.N    R1,??DataTable30_24
   \   0000007A   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xDA17             BGE.N    ??PathJudge_4
   \   00000082   0x....             LDR.N    R0,??DataTable30_10
   \   00000084   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000088   0x.... 0x....      BL       AbsSelf
   \   0000008C   0x....             LDR.N    R1,??DataTable30_25
   \   0000008E   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDA0D             BGE.N    ??PathJudge_4
   \   00000096   0x....             LDR.N    R0,??DataTable30_22
   \   00000098   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000009C   0x.... 0x....      BL       AbsSelf
   \   000000A0   0x....             LDR.N    R1,??DataTable30_26
   \   000000A2   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   000000A6   0x4288             CMP      R0,R1
   \   000000A8   0xDA03             BGE.N    ??PathJudge_4
   3039                  { //均小于阈值，为直道。
   3040                    PathType = 1;  
   \   000000AA   0x....             LDR.N    R0,??DataTable30_23
   \   000000AC   0x2101             MOVS     R1,#+1
   \   000000AE   0x7001             STRB     R1,[R0, #+0]
   \   000000B0   0xE002             B.N      ??PathJudge_1
   3041                  }
   3042                  else
   3043                  {
   3044                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_4:
   \   000000B2   0x....             LDR.N    R0,??DataTable30_23
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x7001             STRB     R1,[R0, #+0]
   3045                  }
   3046                }
   3047              }
   3048              
   3049              //左黑线提取失败，右黑线提取成功，的情况。
   3050              if(BlackLeftDone == 0 && BlackRightDone == 1)
   \                     ??PathJudge_1:
   \   000000B8   0x....             LDR.N    R0,??DataTable30_11
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD13A             BNE.N    ??PathJudge_5
   \   000000C0   0x....             LDR.N    R0,??DataTable30_17
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD136             BNE.N    ??PathJudge_5
   3051              { //左弯道，外道。
   3052                if(CURVEC < 0 && CURVER < 0)
   \   000000C8   0x....             LDR.N    R0,??DataTable30_10
   \   000000CA   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD508             BPL.N    ??PathJudge_6
   \   000000D2   0x....             LDR.N    R0,??DataTable30_22
   \   000000D4   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000D8   0x2800             CMP      R0,#+0
   \   000000DA   0xD503             BPL.N    ??PathJudge_6
   3053                {
   3054                  PathType = 5;
   \   000000DC   0x....             LDR.N    R0,??DataTable30_23
   \   000000DE   0x2105             MOVS     R1,#+5
   \   000000E0   0x7001             STRB     R1,[R0, #+0]
   \   000000E2   0xE028             B.N      ??PathJudge_5
   3055                }
   3056                //右弯道，内道。
   3057                else if(CURVEC > 0 && CURVER > 0)
   \                     ??PathJudge_6:
   \   000000E4   0x....             LDR.N    R0,??DataTable30_10
   \   000000E6   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000EA   0x2801             CMP      R0,#+1
   \   000000EC   0xDB08             BLT.N    ??PathJudge_7
   \   000000EE   0x....             LDR.N    R0,??DataTable30_22
   \   000000F0   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   000000F4   0x2801             CMP      R0,#+1
   \   000000F6   0xDB03             BLT.N    ??PathJudge_7
   3058                {
   3059                  PathType = 6;
   \   000000F8   0x....             LDR.N    R0,??DataTable30_23
   \   000000FA   0x2106             MOVS     R1,#+6
   \   000000FC   0x7001             STRB     R1,[R0, #+0]
   \   000000FE   0xE01A             B.N      ??PathJudge_5
   3060                }
   3061                else
   3062                {
   3063                  if(
   3064                    (AbsSelf(CURVEC) < PathStraightLimitC)
   3065                  &&(AbsSelf(CURVER) < PathStraightLimitR)
   3066                    )
   \                     ??PathJudge_7:
   \   00000100   0x....             LDR.N    R0,??DataTable30_10
   \   00000102   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000106   0x.... 0x....      BL       AbsSelf
   \   0000010A   0x....             LDR.N    R1,??DataTable30_25
   \   0000010C   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000110   0x4288             CMP      R0,R1
   \   00000112   0xDA0D             BGE.N    ??PathJudge_8
   \   00000114   0x....             LDR.N    R0,??DataTable30_22
   \   00000116   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000011A   0x.... 0x....      BL       AbsSelf
   \   0000011E   0x....             LDR.N    R1,??DataTable30_26
   \   00000120   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   00000124   0x4288             CMP      R0,R1
   \   00000126   0xDA03             BGE.N    ??PathJudge_8
   3067                  { //均小于阈值，为直道。
   3068                    PathType = 1;  
   \   00000128   0x....             LDR.N    R0,??DataTable30_23
   \   0000012A   0x2101             MOVS     R1,#+1
   \   0000012C   0x7001             STRB     R1,[R0, #+0]
   \   0000012E   0xE002             B.N      ??PathJudge_5
   3069                  }
   3070                  else
   3071                  {
   3072                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_8:
   \   00000130   0x....             LDR.N    R0,??DataTable30_23
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x7001             STRB     R1,[R0, #+0]
   3073                  }
   3074                }
   3075              }
   3076              
   3077              //右黑线提取失败，左黑线提取成功，的情况。
   3078              if(BlackLeftDone == 1 && BlackRightDone == 0)
   \                     ??PathJudge_5:
   \   00000136   0x....             LDR.N    R0,??DataTable30_11
   \   00000138   0x7800             LDRB     R0,[R0, #+0]
   \   0000013A   0x2801             CMP      R0,#+1
   \   0000013C   0xD13A             BNE.N    ??PathJudge_9
   \   0000013E   0x....             LDR.N    R0,??DataTable30_17
   \   00000140   0x7800             LDRB     R0,[R0, #+0]
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD136             BNE.N    ??PathJudge_9
   3079              { //左弯道，内道。
   3080                if(CURVEC < 0 && CURVEL < 0)
   \   00000146   0x....             LDR.N    R0,??DataTable30_10
   \   00000148   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD508             BPL.N    ??PathJudge_10
   \   00000150   0x....             LDR.N    R0,??DataTable30_16
   \   00000152   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD503             BPL.N    ??PathJudge_10
   3081                {
   3082                  PathType = 4;
   \   0000015A   0x....             LDR.N    R0,??DataTable30_23
   \   0000015C   0x2104             MOVS     R1,#+4
   \   0000015E   0x7001             STRB     R1,[R0, #+0]
   \   00000160   0xE028             B.N      ??PathJudge_9
   3083                }
   3084                //右弯道，外道。
   3085                else if(CURVEC > 0 && CURVEL > 0)
   \                     ??PathJudge_10:
   \   00000162   0x....             LDR.N    R0,??DataTable30_10
   \   00000164   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000168   0x2801             CMP      R0,#+1
   \   0000016A   0xDB08             BLT.N    ??PathJudge_11
   \   0000016C   0x....             LDR.N    R0,??DataTable30_16
   \   0000016E   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000172   0x2801             CMP      R0,#+1
   \   00000174   0xDB03             BLT.N    ??PathJudge_11
   3086                {
   3087                  PathType = 7;
   \   00000176   0x....             LDR.N    R0,??DataTable30_23
   \   00000178   0x2107             MOVS     R1,#+7
   \   0000017A   0x7001             STRB     R1,[R0, #+0]
   \   0000017C   0xE01A             B.N      ??PathJudge_9
   3088                }
   3089                else
   3090                {
   3091                  if(
   3092                    (AbsSelf(CURVEC) < PathStraightLimitC)
   3093                  &&(AbsSelf(CURVEL) < PathStraightLimitL)
   3094                    )
   \                     ??PathJudge_11:
   \   0000017E   0x....             LDR.N    R0,??DataTable30_10
   \   00000180   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000184   0x.... 0x....      BL       AbsSelf
   \   00000188   0x....             LDR.N    R1,??DataTable30_25
   \   0000018A   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   0000018E   0x4288             CMP      R0,R1
   \   00000190   0xDA0D             BGE.N    ??PathJudge_12
   \   00000192   0x....             LDR.N    R0,??DataTable30_16
   \   00000194   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000198   0x.... 0x....      BL       AbsSelf
   \   0000019C   0x....             LDR.N    R1,??DataTable30_24
   \   0000019E   0xF9B1 0x1000      LDRSH    R1,[R1, #+0]
   \   000001A2   0x4288             CMP      R0,R1
   \   000001A4   0xDA03             BGE.N    ??PathJudge_12
   3095                  { //均小于阈值，为直道。
   3096                    PathType = 1;  
   \   000001A6   0x....             LDR.N    R0,??DataTable30_23
   \   000001A8   0x2101             MOVS     R1,#+1
   \   000001AA   0x7001             STRB     R1,[R0, #+0]
   \   000001AC   0xE002             B.N      ??PathJudge_9
   3097                  }
   3098                  else
   3099                  {
   3100                    PathType = 0; //未知赛道类型。  
   \                     ??PathJudge_12:
   \   000001AE   0x....             LDR.N    R0,??DataTable30_23
   \   000001B0   0x2100             MOVS     R1,#+0
   \   000001B2   0x7001             STRB     R1,[R0, #+0]
   3101                  }
   3102                }
   3103              }
   3104              
   3105              return 1;
   \                     ??PathJudge_9:
   \   000001B4   0x2001             MOVS     R0,#+1
   \   000001B6   0xE003             B.N      ??PathJudge_13
   3106            }
   3107            //曲率符号获取失败
   3108            else
   3109            {
   3110              PathType = 0;  
   \                     ??PathJudge_0:
   \   000001B8   0x....             LDR.N    R0,??DataTable30_23
   \   000001BA   0x2100             MOVS     R1,#+0
   \   000001BC   0x7001             STRB     R1,[R0, #+0]
   3111              return 0;
   \   000001BE   0x2000             MOVS     R0,#+0
   \                     ??PathJudge_13:
   \   000001C0   0xBD02             POP      {R1,PC}          ;; return
   3112            }
   3113            
   3114          }
   3115          
   3116          
   3117          
   3118          
   3119          
   3120          //======================================================================
   3121          //函数名：ImagePro
   3122          //功  能：图像处理函数。图像尺寸缩减，黑线提取，中心线提取。
   3123          //参  数：无
   3124          //返  回：1成功 0失败
   3125          //影  响：
   3126          //说  明：1. 黑线提取失败后，不会执行中心线提取函数。返回失败。
   3127          //        2. 黑线提取失败后，后面的运动控制的参数不用更改，延用上一次的参数。
   3128          //             
   3129          //======================================================================

   \                                 In section .text, align 2, keep-with-next
   3130          uint8 ImagePro(void)
   3131          {
   \                     ImagePro:
   \   00000000   0xB580             PUSH     {R7,LR}
   3132              uint8 i;
   3133              //图像取需要的列，重新赋值是为了后面的编程方便。
   3134              ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。
   3135              ImgPut();
   \   00000002   0x.... 0x....      BL       ImgPut
   3136            
   3137              //ImageExtract(ImgSend, ImgStore, CameraSize);  
   3138          
   3139              
   3140              //发送图像存储数组到上位机
   3141              //SendImage(ImgNew);       
   3142              //黑线提取函数
   3143              if(!BlackGet())         ////////////////////////////如果黑线提取失败，这里最好给个灯来指示
   \   00000006   0x.... 0x....      BL       BlackGet
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD10D             BNE.N    ??ImagePro_0
   3144              {
   3145                  //uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
   3146                  CenterLineResult = 0;
   \   0000000E   0x....             LDR.N    R0,??DataTable30_27
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   3147                  PathType = 0;
   \   00000014   0x....             LDR.N    R0,??DataTable30_23
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x7001             STRB     R1,[R0, #+0]
   3148                  BlackLeftHeadLine = MaxValUint8;
   \   0000001A   0x....             LDR.N    R0,??DataTable30_28
   \   0000001C   0x21FF             MOVS     R1,#+255
   \   0000001E   0x7001             STRB     R1,[R0, #+0]
   3149                  BlackRightHeadLine = MaxValUint8;
   \   00000020   0x....             LDR.N    R0,??DataTable30_29
   \   00000022   0x21FF             MOVS     R1,#+255
   \   00000024   0x7001             STRB     R1,[R0, #+0]
   3150                  return 0;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0xE04D             B.N      ??ImagePro_1
   3151              }
   3152              else
   3153              { //黑线提取成功，找两边黑线的线头
   3154                //左线线头的查找
   3155                if(BlackLeftDone == 1)
   \                     ??ImagePro_0:
   \   0000002A   0x....             LDR.N    R0,??DataTable30_11
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD114             BNE.N    ??ImagePro_2
   3156                {
   3157                  for(i = 0; ; i++)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xE000             B.N      ??ImagePro_3
   \                     ??ImagePro_4:
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   3158                  {
   3159                    if(BlackLeftLoc[i][0] != MaxValUint8)
   \                     ??ImagePro_3:
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2103             MOVS     R1,#+3
   \   0000003C   0x....             LDR.N    R2,??DataTable30_15
   \   0000003E   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x29FF             CMP      R1,#+255
   \   00000046   0xD002             BEQ.N    ??ImagePro_5
   3160                    {
   3161                      BlackLeftHeadLine = i;
   \   00000048   0x....             LDR.N    R1,??DataTable30_28
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
   3162                      break;
   \   0000004C   0xE009             B.N      ??ImagePro_6
   3163                    }
   3164                    if(i == CameraHight - 1) 
   \                     ??ImagePro_5:
   \   0000004E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000050   0x2831             CMP      R0,#+49
   \   00000052   0xD1F0             BNE.N    ??ImagePro_4
   3165                    {
   3166                      BlackLeftHeadLine = MaxValUint8;
   \   00000054   0x....             LDR.N    R0,??DataTable30_28
   \   00000056   0x21FF             MOVS     R1,#+255
   \   00000058   0x7001             STRB     R1,[R0, #+0]
   3167                      break;
   \   0000005A   0xE002             B.N      ??ImagePro_6
   3168                    }
   3169                  }
   3170                }
   3171                else
   3172                {
   3173                  BlackLeftHeadLine = MaxValUint8;
   \                     ??ImagePro_2:
   \   0000005C   0x....             LDR.N    R0,??DataTable30_28
   \   0000005E   0x21FF             MOVS     R1,#+255
   \   00000060   0x7001             STRB     R1,[R0, #+0]
   3174                }
   3175                
   3176                //右线线头的查找
   3177                if(BlackRightDone == 1)
   \                     ??ImagePro_6:
   \   00000062   0x....             LDR.N    R0,??DataTable30_17
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD114             BNE.N    ??ImagePro_7
   3178                {
   3179                  for(i = 0; ; i++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0xE000             B.N      ??ImagePro_8
   \                     ??ImagePro_9:
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   3180                  {
   3181                    if(BlackRightLoc[i][0] != MaxValUint8)
   \                     ??ImagePro_8:
   \   00000070   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000072   0x2103             MOVS     R1,#+3
   \   00000074   0x....             LDR.N    R2,??DataTable30_21
   \   00000076   0xFB01 0x2100      MLA      R1,R1,R0,R2
   \   0000007A   0x7809             LDRB     R1,[R1, #+0]
   \   0000007C   0x29FF             CMP      R1,#+255
   \   0000007E   0xD002             BEQ.N    ??ImagePro_10
   3182                    {
   3183                      BlackRightHeadLine = i;
   \   00000080   0x....             LDR.N    R1,??DataTable30_29
   \   00000082   0x7008             STRB     R0,[R1, #+0]
   3184                      break;
   \   00000084   0xE009             B.N      ??ImagePro_11
   3185                    }
   3186                    if(i == CameraHight - 1) 
   \                     ??ImagePro_10:
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2831             CMP      R0,#+49
   \   0000008A   0xD1F0             BNE.N    ??ImagePro_9
   3187                    {
   3188                      BlackRightHeadLine = MaxValUint8;
   \   0000008C   0x....             LDR.N    R0,??DataTable30_29
   \   0000008E   0x21FF             MOVS     R1,#+255
   \   00000090   0x7001             STRB     R1,[R0, #+0]
   3189                      break;
   \   00000092   0xE002             B.N      ??ImagePro_11
   3190                    }
   3191                  }
   3192                }
   3193                else
   3194                {
   3195                  BlackRightHeadLine = MaxValUint8;
   \                     ??ImagePro_7:
   \   00000094   0x....             LDR.N    R0,??DataTable30_29
   \   00000096   0x21FF             MOVS     R1,#+255
   \   00000098   0x7001             STRB     R1,[R0, #+0]
   3196                }
   3197              }
   3198              
   3199              //中心线提取函数
   3200              CenterLineResult = 1;
   \                     ??ImagePro_11:
   \   0000009A   0x....             LDR.N    R0,??DataTable30_27
   \   0000009C   0x2101             MOVS     R1,#+1
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
   3201              if(!CenterLineGet())
   \   000000A0   0x.... 0x....      BL       CenterLineGet
   \   000000A4   0x2800             CMP      R0,#+0
   \   000000A6   0xD107             BNE.N    ??ImagePro_12
   3202              {
   3203                //uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
   3204                CenterLineResult = 0;
   \   000000A8   0x....             LDR.N    R0,??DataTable30_27
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x7001             STRB     R1,[R0, #+0]
   3205                PathType = 0;
   \   000000AE   0x....             LDR.N    R0,??DataTable30_23
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x7001             STRB     R1,[R0, #+0]
   3206                return 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0xE006             B.N      ??ImagePro_1
   3207              }
   3208              else
   3209              {
   3210                //CenterLineGetCom();  
   3211              }
   3212              
   3213              //赛道类型判断
   3214              //到这里时，中心线提取成功，左右黑线至少有一个提取成功。
   3215              if(!PathJudge())
   \                     ??ImagePro_12:
   \   000000B8   0x.... 0x....      BL       PathJudge
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD101             BNE.N    ??ImagePro_13
   3216              {      
   3217                //uart_sendN(UART0, (uint8 *)"\nPathJudge Failed!", 18);
   3218                return 0;
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0xE000             B.N      ??ImagePro_1
   3219              }    
   3220              //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
   3221              //SendCenterLineLoc(CenterLineLoc);
   3222             
   3223              
   3224              return 1;
   \                     ??ImagePro_13:
   \   000000C4   0x2001             MOVS     R0,#+1
   \                     ??ImagePro_1:
   \   000000C6   0xBD02             POP      {R1,PC}          ;; return
   3225          }
   3226          
   3227          

   \                                 In section .text, align 2, keep-with-next
   3228          uint8 ImageProSend(void)
   3229          {
   \                     ImageProSend:
   \   00000000   0xB580             PUSH     {R7,LR}
   3230              //图像取需要的列，重新赋值是为了后面的编程方便。
   3231              ///////////////////////////////////////////但这里需要用示波器测量一下时间，看是不是耗费了太多时间。
   3232              ImgPut();
   \   00000002   0x.... 0x....      BL       ImgPut
   3233            
   3234              //ImageExtract(ImgSend, ImgStore, CameraSize);  
   3235              /*
   3236              //黑线提取函数
   3237              if(!BlackGet())         ////////////////////////////如果黑线提取失败，这里最好给个灯来指示
   3238              {
   3239                  uart_sendN(UART0, (uint8 *)"\nBlackGet Failed!", 17);  
   3240                  return 0;
   3241              }
   3242              
   3243              //中心线提取函数
   3244              CenterLineResult = 1;
   3245              if(!CenterLineGet())
   3246              {
   3247                uart_sendN(UART0, (uint8 *)"\nCenterLineGet Failed!", 22); 
   3248                CenterLineResult = 0;
   3249                return 0;
   3250              }
   3251              
   3252              //PathJudge();
   3253          
   3254              */
   3255              //发送中心线数组，不用发送float型的数据，同样的处理可以由上位机完成。
   3256              //SendCenterLineLoc(CenterLineLoc);
   3257              
   3258              //发送图像存储数组到上位机
   3259              SendImage(ImgNew);      
   \   00000006   0x....             LDR.N    R0,??DataTable30_1
   \   00000008   0x.... 0x....      BL       SendImage
   3260              
   3261              return 1;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return
   3262          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     `?<Constant {0, 255, 1, 255}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     `?<Constant {0, 255, 1, 0}>`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     BlackLeftRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     BlackLeftRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     BlackLeftRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     `?<Constant "\\nError In BlackLeftCr...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x43790001         DC32     0x43790001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x437A0000         DC32     0x437a0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     BlackLeftCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     BlackLeftCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     BlackRightRealWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     BlackRightRealW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     BlackRightRealB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     LimitRightWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     LimitRightW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     LimitRightB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x........         DC32     `?<Constant "\\nError In BlackRightC...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   0x437A0001         DC32     0x437a0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   0x........         DC32     BlackRightCrossDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   0x........         DC32     BlackRightCrossTooLowLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_2:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_3:
   \   00000000   0x........         DC32     LimitLeftWB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_4:
   \   00000000   0x........         DC32     LimitLeftW

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_5:
   \   00000000   0x........         DC32     LimitLeftB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_6:
   \   00000000   0x........         DC32     BlackLeft3ResetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_7:
   \   00000000   0x........         DC32     BlackRight3ResetCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_8:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_9:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_10:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_11:
   \   00000000   0x........         DC32     CenterLocStore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_12:
   \   00000000   0x........         DC32     CenterLineHalfWidth

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   0x........         DC32     CenterKeyLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_1:
   \   00000000   0x........         DC32     ImgNew

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_2:
   \   00000000   0x........         DC32     ImgRaw

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_3:
   \   00000000   0x........         DC32     ErrorGetSelf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_4:
   \   00000000   0x........         DC32     ErrorGetCen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_5:
   \   00000000   0x........         DC32     CurveGetCompen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_6:
   \   00000000   0x........         DC32     CurveLineChosenC1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_7:
   \   00000000   0x........         DC32     CurveLineChosenC2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_8:
   \   00000000   0x........         DC32     CurveLineChosenC3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_9:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_10:
   \   00000000   0x........         DC32     CURVEC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_11:
   \   00000000   0x........         DC32     BlackLeftDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_12:
   \   00000000   0x........         DC32     CurveLineChosenL1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_13:
   \   00000000   0x........         DC32     CurveLineChosenL2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_14:
   \   00000000   0x........         DC32     CurveLineChosenL3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_15:
   \   00000000   0x........         DC32     BlackLeftLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_16:
   \   00000000   0x........         DC32     CURVEL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_17:
   \   00000000   0x........         DC32     BlackRightDone

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_18:
   \   00000000   0x........         DC32     CurveLineChosenR1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_19:
   \   00000000   0x........         DC32     CurveLineChosenR2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_20:
   \   00000000   0x........         DC32     CurveLineChosenR3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_21:
   \   00000000   0x........         DC32     BlackRightLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_22:
   \   00000000   0x........         DC32     CURVER

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_23:
   \   00000000   0x........         DC32     PathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_24:
   \   00000000   0x........         DC32     PathStraightLimitL

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_25:
   \   00000000   0x........         DC32     PathStraightLimitC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_26:
   \   00000000   0x........         DC32     PathStraightLimitR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_27:
   \   00000000   0x........         DC32     CenterLineResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_28:
   \   00000000   0x........         DC32     BlackLeftHeadLine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable30_29:
   \   00000000   0x........         DC32     BlackRightHeadLine

   \                                 In section .rodata, align 4
   \                     `?<Constant {0, 255, 1, 255}>`:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 255
   \              0x01 0xFF    

   \                                 In section .rodata, align 4
   \                     `?<Constant {0, 255, 1, 0}>`:
   \   00000000   0x00 0xFF          DC8 0, 255, 1, 0
   \              0x01 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nError In BlackLeftCr...">`:
   \   00000000   0x0A 0x45          DC8 "\012Error In BlackLeftCrossStep3!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x42 0x6C    
   \              0x61 0x63    
   \              0x6B 0x4C    
   \              0x65 0x66    
   \              0x74 0x43    
   \              0x72 0x6F    
   \              0x73 0x73    
   \              0x53 0x74    
   \              0x65 0x70    
   \              0x33 0x21    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "\\nError In BlackRightC...">`:
   \   00000000   0x0A 0x45          DC8 "\012Error In BlackRightCrossStep3!"
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x20 0x49    
   \              0x6E 0x20    
   \              0x42 0x6C    
   \              0x61 0x63    
   \              0x6B 0x52    
   \              0x69 0x67    
   \              0x68 0x74    
   \              0x43 0x72    
   \              0x6F 0x73    
   \              0x73 0x53    
   \              0x74 0x65    
   \              0x70 0x33    
   \              0x21 0x00    
   3263          
   3264          
   3265          
   3266          
   3267          
   3268          
   3269          
   3270          
   3271          
   3272          
   3273          
   3274          
   3275          
   3276          
   3277          
   3278          
   3279          
   3280          
   3281          
   3282          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  AbsRe
        0  AbsSelf
       16  BlackGet
             16 -> BlackGetLeft
             16 -> BlackGetRight
       40  BlackGetLeft
             40 -> BlackGetLeftStep1Scan
             40 -> BlackGetLeftStep2Win
             40 -> BlackLeftAgainForCross
             40 -> BlackLeftStep4BackLine
       24  BlackGetLeftStep1Edge
             24 -> AbsRe
             24 -> BlackLeftRealClear
       24  BlackGetLeftStep1Scan
             24 -> AbsRe
             24 -> BlackGetLeftStep1Edge
       16  BlackGetLeftStep2Win
             16 -> AbsRe
       40  BlackGetRight
             40 -> BlackGetRightStep1Scan
             40 -> BlackGetRightStep2Win
             40 -> BlackRightAgainForCross
             40 -> BlackRightStep4BackLine
       24  BlackGetRightStep1Edge
             24 -> AbsRe
             24 -> BlackRightRealClear
             24 -> MaxRe
             24 -> MinRe
       24  BlackGetRightStep1Scan
             24 -> AbsRe
             24 -> BlackGetRightStep1Edge
       16  BlackGetRightStep2Win
             16 -> AbsRe
       32  BlackLeftAgainForCross
             32 -> BlackGetLeftStep1Scan
             32 -> BlackGetLeftStep2Win
             32 -> BlackLeftCrossConfirm
             32 -> BlackLeftCrossStep3
       24  BlackLeftCrossConfirm
             24 -> LeastSquarea0
             24 -> LeastSquarea1
             24 -> __aeabi_cfcmple
             24 -> __aeabi_cfrcmple
             24 -> __aeabi_fadd
             24 -> __aeabi_fmul
             24 -> __aeabi_ui2f
       32  BlackLeftCrossStep3
             32 -> __aeabi_d2f
             32 -> __aeabi_dadd
             32 -> __aeabi_f2d
             32 -> __aeabi_f2iz
             32 -> __aeabi_fadd
             32 -> __aeabi_fdiv
             32 -> __aeabi_fmul
             32 -> __aeabi_fsub
             32 -> __aeabi_i2f
             32 -> __aeabi_ui2f
             32 -> uart_sendN
        0  BlackLeftRealClear
       24  BlackLeftStep4BackLine
             24 -> LeastSquarea0
             24 -> LeastSquarea1
             24 -> __aeabi_cfcmple
             24 -> __aeabi_cfrcmple
             24 -> __aeabi_f2iz
             24 -> __aeabi_fadd
             24 -> __aeabi_fmul
             24 -> __aeabi_ui2f
       32  BlackRightAgainForCross
             32 -> BlackGetRightStep1Scan
             32 -> BlackGetRightStep2Win
             32 -> BlackRightCrossConfirm
             32 -> BlackRightCrossStep3
       24  BlackRightCrossConfirm
             24 -> LeastSquarea0
             24 -> LeastSquarea1
             24 -> __aeabi_cfcmple
             24 -> __aeabi_cfrcmple
             24 -> __aeabi_fadd
             24 -> __aeabi_fmul
             24 -> __aeabi_ui2f
       32  BlackRightCrossStep3
             32 -> __aeabi_d2f
             32 -> __aeabi_dadd
             32 -> __aeabi_f2d
             32 -> __aeabi_f2iz
             32 -> __aeabi_fadd
             32 -> __aeabi_fdiv
             32 -> __aeabi_fmul
             32 -> __aeabi_fsub
             32 -> __aeabi_i2f
             32 -> __aeabi_ui2f
             32 -> uart_sendN
        0  BlackRightRealClear
       24  BlackRightStep4BackLine
             24 -> LeastSquarea0
             24 -> LeastSquarea1
             24 -> __aeabi_cfcmple
             24 -> __aeabi_cfrcmple
             24 -> __aeabi_f2iz
             24 -> __aeabi_fadd
             24 -> __aeabi_fmul
             24 -> __aeabi_ui2f
       16  CenterLineGet
             16 -> MinRe
        0  CenterLineGetCom
       40  CurveGet
             40 -> MathSqrt
       24  CurveSignGet
             24 -> CurveGet
       24  ErrorGet
             24 -> AbsRe
             24 -> __aeabi_f2iz
             24 -> __aeabi_fadd
             24 -> __aeabi_fdiv
             24 -> __aeabi_ui2f
        8  ImagePro
              8 -> BlackGet
              8 -> CenterLineGet
              8 -> ImgPut
              8 -> PathJudge
        8  ImageProSend
              8 -> ImgPut
              8 -> SendImage
       16  ImgPut
       32  LeastSquarea0
             32 -> __aeabi_fadd
             32 -> __aeabi_fdiv
             32 -> __aeabi_fmul
             32 -> __aeabi_fsub
             32 -> __aeabi_ui2f
       36  LeastSquarea1
             36 -> __aeabi_d2f
             36 -> __aeabi_ddiv
             36 -> __aeabi_dmul
             36 -> __aeabi_f2d
             36 -> __aeabi_fadd
             36 -> __aeabi_fmul
             36 -> __aeabi_fsub
             36 -> __aeabi_i2f
             36 -> __aeabi_ui2f
        0  MathSqrt
        0  MaxRe
        0  MinRe
        8  PathJudge
              8 -> AbsSelf
              8 -> CurveSignGet
        8  SABCGet
       16  SendCenterLineLoc
             16 -> uart_send1
             16 -> uart_sendN
       24  SendImage
             24 -> uart_send1
             24 -> uart_sendN


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "\nError In BlackLeftCr...">
      32  ?<Constant "\nError In BlackRightC...">
       4  ?<Constant {0, 255, 1, 0}>
       4  ?<Constant {0, 255, 1, 255}>
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable17
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_10
       4  ??DataTable26_11
       4  ??DataTable26_12
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable26_4
       4  ??DataTable26_5
       4  ??DataTable26_6
       4  ??DataTable26_7
       4  ??DataTable26_8
       4  ??DataTable26_9
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable30
       4  ??DataTable30_1
       4  ??DataTable30_10
       4  ??DataTable30_11
       4  ??DataTable30_12
       4  ??DataTable30_13
       4  ??DataTable30_14
       4  ??DataTable30_15
       4  ??DataTable30_16
       4  ??DataTable30_17
       4  ??DataTable30_18
       4  ??DataTable30_19
       4  ??DataTable30_2
       4  ??DataTable30_20
       4  ??DataTable30_21
       4  ??DataTable30_22
       4  ??DataTable30_23
       4  ??DataTable30_24
       4  ??DataTable30_25
       4  ??DataTable30_26
       4  ??DataTable30_27
       4  ??DataTable30_28
       4  ??DataTable30_29
       4  ??DataTable30_3
       4  ??DataTable30_4
       4  ??DataTable30_5
       4  ??DataTable30_6
       4  ??DataTable30_7
       4  ??DataTable30_8
       4  ??DataTable30_9
      20  AbsRe
      18  AbsSelf
     228  BlackGet
     670  BlackGetLeft
     744  BlackGetLeftStep1Edge
     264  BlackGetLeftStep1Scan
     428  BlackGetLeftStep2Win
     670  BlackGetRight
     794  BlackGetRightStep1Edge
     264  BlackGetRightStep1Scan
     404  BlackGetRightStep2Win
       1  BlackLeft3ResetCount
     316  BlackLeftAgainForCross
     154  BlackLeftCrossConfirm
       1  BlackLeftCrossDone
     370  BlackLeftCrossStep3
       1  BlackLeftCrossTooLowLine
       1  BlackLeftDone
       1  BlackLeftHeadLine
     152  BlackLeftLoc
       2  BlackLeftRealB
      50  BlackLeftRealClear
       2  BlackLeftRealW
       2  BlackLeftRealWB
     230  BlackLeftStep4BackLine
       1  BlackRight3ResetCount
     316  BlackRightAgainForCross
     152  BlackRightCrossConfirm
       1  BlackRightCrossDone
     374  BlackRightCrossStep3
       1  BlackRightCrossTooLowLine
       1  BlackRightDone
       1  BlackRightHeadLine
     152  BlackRightLoc
       2  BlackRightRealB
      50  BlackRightRealClear
       2  BlackRightRealW
       2  BlackRightRealWB
     230  BlackRightStep4BackLine
       2  CURVEC
       2  CURVEL
       2  CURVER
       1  CenterKeyLine
    1870  CenterLineGet
     166  CenterLineGetCom
      52  CenterLineHalfWidth
      52  CenterLineHalfWidth02
      52  CenterLineLoc
       1  CenterLineResult
       1  CenterLocStore
     354  CurveGet
       2  CurveGetCompen
       1  CurveLineChosenC1
       1  CurveLineChosenC2
       1  CurveLineChosenC3
       1  CurveLineChosenL1
       1  CurveLineChosenL2
       1  CurveLineChosenL3
       1  CurveLineChosenR1
       1  CurveLineChosenR2
       1  CurveLineChosenR3
    1010  CurveSignGet
     170  ErrorGet
       1  ErrorGetCen
       1  ErrorGetSelf
     200  ImagePro
      16  ImageProSend
   12500  ImgNew
      76  ImgPut
     136  LeastSquarea0
     248  LeastSquarea1
       1  LimitLeftB
       1  LimitLeftW
       1  LimitLeftWB
       1  LimitRightB
       1  LimitRightW
       1  LimitRightWB
      46  MathSqrt
      18  MaxRe
      18  MinRe
     450  PathJudge
       2  PathStraightLimitC
       2  PathStraightLimitL
       2  PathStraightLimitR
       1  PathType
       2  SABCC
      50  SABCGet
       2  SABCL
       2  SABCR
      52  SendCenterLineLoc
      74  SendImage

 
 12 896 bytes in section .bss
     23 bytes in section .data
    176 bytes in section .rodata
 12 008 bytes in section .text
 
 12 008 bytes of CODE  memory
    176 bytes of CONST memory
 12 919 bytes of DATA  memory

Errors: none
Warnings: none
