###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     06/Dec/2014  16:52:02 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C\ #
#                    RunControl.c                                             #
#    Command line =  "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C #
#                    \RunControl.c" -D IAR -D TWR_K60N512 -lCN                #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\" -lB       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\" -o        #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\Obj\" --no_cse   #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.3\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\" -I       #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\Component_ #
#                    H\" -I "D:\IAR_TEST\Sirius\Sirius                        #
#                    V2.3\src\Sources\H\Frame_H\" -I                          #
#                    "D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\H\Function_H #
#                    \" -I "D:\IAR_TEST\Sirius\Sirius                         #
#                    V2.3\src\Sources\H\SD_H\" -Ol --use_c++_inline           #
#    List file    =  D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\List\RunControl.l #
#                    st                                                       #
#    Object file  =  D:\IAR_TEST\Sirius\Sirius V2.3\bin\Ram\Obj\RunControl.o  #
#                                                                             #
#                                                                             #
###############################################################################

D:\IAR_TEST\Sirius\Sirius V2.3\src\Sources\C\Function_C\RunControl.c
      1          /******************************************************************************/
      2          /*******************************************************************************
      3            文件名：运动控制C文件RunControl.c
      4            功  能：偏差求取，PID反馈，控制电机，控制舵机。
      5            日  期：2014.11.15
      6            作  者：HJZ & YCR
      7            备  注：
      8          *******************************************************************************/
      9          /******************************************************************************/
     10          #include "RunControl.h"
     11          
     12          //偏差选取行对应的权重

   \                                 In section .rodata, align 4
     13          uint8 const DeviSelRowWeight[CameraHight] = 
   \                     DeviSelRowWeight:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000017   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   0000002E   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
     14          {
     15          0
     16          };
     17          

   \                                 In section .bss, align 2
     18          int16 DeviNow = 0;                  //当前偏差, 可以考虑换成float型
   \                     DeviNow:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     19          int16 DeviPre = 0;                  //先前偏差, 可以考虑换成float型
   \                     DeviPre:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
     20          uint8 DeviFlag = 0;                //偏差求取标志位，告诉程序这次应该写入第几个偏差。
   \                     DeviFlag:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
     21          uint8 DeviSelRow01 = 30;                //偏差求取时，选中的行号。
   \                     DeviSelRow01:
   \   00000000   0x1E               DC8 30

   \                                 In section .bss, align 1
     22          uint8 DeviSelRow02 = 0;                //偏差求取时，选中的行号。
   \                     DeviSelRow02:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     23          uint8 DeviRowChosen = 0;               //求取偏差时选取的行，若指定范围没选取到或者偏差过小，则置无效值。
   \                     DeviRowChosen:
   \   00000000                      DS8 1

   \                                 In section .data, align 2
     24          int16 DeviGoStraightLim = 3;          //偏差小于该值时，直走。
   \                     DeviGoStraightLim:
   \   00000000   0x0003             DC16 3
     25          

   \                                 In section .data, align 4
     26          float ServoKp = 4;                 //舵机PID的P参数
   \                     ServoKp:
   \   00000000   0x40800000         DC32 40800000H

   \                                 In section .data, align 4
     27          float ServoKd = 2;                 //舵机PID的D参数
   \                     ServoKd:
   \   00000000   0x40000000         DC32 40000000H

   \                                 In section .data, align 4
     28          float ServoK1 = 150;                 //舵机PID跟P参数有关的系数
   \                     ServoK1:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .data, align 2
     29          uint16 ServoPIDMax = 2039;             //舵机PID控制的最大值，右转
   \                     ServoPIDMax:
   \   00000000   0x07F7             DC16 2039

   \                                 In section .data, align 2
     30          uint16 ServoPIDMin = 1617;             //舵机PID控制的最小值，左转
   \                     ServoPIDMin:
   \   00000000   0x0651             DC16 1617

   \                                 In section .data, align 2
     31          uint16 ServoPIDCen = 1828;             //舵机PID控制的中心值，直走。
   \                     ServoPIDCen:
   \   00000000   0x0724             DC16 1828
     32          
     33          

   \                                 In section .data, align 4
     34          float MotorLeftKp = 1;             //左电机PID的P参数    
   \                     MotorLeftKp:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .data, align 4
     35          float MotorLeftKd = 1;             //左电机PID的D参数
   \                     MotorLeftKd:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .bss, align 2
     36          uint16 MotorLeftPIDMax;         //左电机PID控制的最大值
   \                     MotorLeftPIDMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     37          uint16 MotorLeftPIDMin;         //左电机PID控制的最小值
   \                     MotorLeftPIDMin:
   \   00000000                      DS8 2
     38          

   \                                 In section .data, align 4
     39          float MotorRightKp = 1;            //右电机PID的P参数     
   \                     MotorRightKp:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .data, align 4
     40          float MotorRightKd = 1;            //右电机PID的D参数
   \                     MotorRightKd:
   \   00000000   0x3F800000         DC32 3F800000H

   \                                 In section .bss, align 2
     41          uint16 MotorRightPIDMax;        //右电机PID控制的最大值
   \                     MotorRightPIDMax:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     42          uint16 MotorRightPIDMin;        //右电机PID控制的最小值
   \                     MotorRightPIDMin:
   \   00000000                      DS8 2
     43          
     44          
     45          
     46          /*
     47          //------------------------------------------------------------------------------
     48          //函数名：MotorControl
     49          //功  能：左右电机PWM驱动
     50          //参  数：motor_left为左电机PWM，motor_right为右电机PWM
     51          //返  回：无
     52          //说  明：PWM占空比计算方法CnV/MOD
     53          //------------------------------------------------------------------------------
     54          void MotorControl(int32 motor_left,int32 motor_right)
     55          {
     56          	//电机开关||摔倒，则关闭电机
     57          	if((!switch4) || fall_flag)
     58            {
     59          		FTM0_C4V=0;
     60          		FTM0_C5V=0;
     61          		FTM0_C6V=0;
     62          		FTM0_C7V=0;
     63          	}
     64            else
     65            {
     66              //电机死区消除
     67              if(motor_left>0)
     68                motor_left+=MOTOR_DEATH;
     69              else
     70                motor_left-=MOTOR_DEATH;
     71              if(motor_right>0)
     72                motor_right+=MOTOR_DEATH;
     73              else
     74                motor_right-=MOTOR_DEATH;
     75          
     76              //左电机PWM驱动
     77              if(motor_left>=0)
     78              {
     79                FTM0_C4V=0;
     80                FTM0_C5V=motor_left;
     81              }
     82              else
     83              {
     84          			FTM0_C5V=0;
     85                FTM0_C4V=-motor_left;
     86              }
     87              //右电机PWM驱动
     88              if(motor_right>=0)
     89              {
     90          			FTM0_C6V=motor_right;
     91                FTM0_C7V=0;
     92              }
     93              else
     94              {
     95          			FTM0_C7V=-motor_right;
     96                FTM0_C6V=0;
     97              }
     98          	}
     99          }
    100          
    101          */
    102          
    103          //======================================================================
    104          //函数名：DeviationGet
    105          //功  能：偏差、偏差变化率的计算
    106          //参  数：
    107          //返  回：1成功 0失败
    108          //影  响：
    109          //说  明：
    110          //      
    111          //             
    112          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    113          uint8 DeviationGet(void)
    114          {
    115            uint8 row;
    116            int16 tempDevi;
    117            
    118            for(row = DeviSelRow01 - 5; row < DeviSelRow01 + 15; row++)
   \                     DeviationGet:
   \   00000000   0x....             LDR.N    R0,??DataTable2
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x1F40             SUBS     R0,R0,#+5
   \   00000006   0xE000             B.N      ??DeviationGet_0
   \                     ??DeviationGet_1:
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \                     ??DeviationGet_0:
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x....             LDR.N    R2,??DataTable2
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0x320F             ADDS     R2,R2,#+15
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xDA1C             BGE.N    ??DeviationGet_2
    119            {
    120              if(CenterLineLoc[row] != MaxValUint8)
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0x....             LDR.N    R2,??DataTable2_1
   \   0000001A   0x5C82             LDRB     R2,[R0, R2]
   \   0000001C   0x2AFF             CMP      R2,#+255
   \   0000001E   0xD0F3             BEQ.N    ??DeviationGet_1
    121              { //指定范围内找到了有效行.
    122                tempDevi = CenterLineLoc[row] - PhyCenterCol;
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x....             LDR.N    R1,??DataTable2_1
   \   00000024   0x5C41             LDRB     R1,[R0, R1]
   \   00000026   0x398C             SUBS     R1,R1,#+140
    123                //若偏差过小，则将偏差置为0，选取行置0(选取范围不能包括0)。
    124                if((tempDevi < DeviGoStraightLim)&&(tempDevi > -DeviGoStraightLim))
   \   00000028   0x....             LDR.N    R2,??DataTable2_2
   \   0000002A   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   0000002E   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   00000030   0x4291             CMP      R1,R2
   \   00000032   0xDA0B             BGE.N    ??DeviationGet_3
   \   00000034   0x....             LDR.N    R2,??DataTable2_2
   \   00000036   0xF9B2 0x2000      LDRSH    R2,[R2, #+0]
   \   0000003A   0x4252             RSBS     R2,R2,#+0
   \   0000003C   0xB209             SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
   \   0000003E   0x428A             CMP      R2,R1
   \   00000040   0xDA04             BGE.N    ??DeviationGet_3
    125                {
    126                  tempDevi = 0;
   \   00000042   0x2100             MOVS     R1,#+0
    127                  DeviRowChosen = 0;
   \   00000044   0x....             LDR.N    R2,??DataTable2_3
   \   00000046   0x2300             MOVS     R3,#+0
   \   00000048   0x7013             STRB     R3,[R2, #+0]
   \   0000004A   0xE001             B.N      ??DeviationGet_4
    128                }
    129                //偏差够大，则偏差置更新，选取行更新。
    130                else
    131                {
    132                  DeviRowChosen = row;  
   \                     ??DeviationGet_3:
   \   0000004C   0x....             LDR.N    R2,??DataTable2_3
   \   0000004E   0x7010             STRB     R0,[R2, #+0]
    133                }
    134                    
    135                break;
    136              }
    137            }
    138            if(row >= DeviSelRow01 + 15)
   \                     ??DeviationGet_4:
   \                     ??DeviationGet_2:
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x....             LDR.N    R2,??DataTable2
   \   00000054   0x7812             LDRB     R2,[R2, #+0]
   \   00000056   0x320F             ADDS     R2,R2,#+15
   \   00000058   0x4290             CMP      R0,R2
   \   0000005A   0xDB05             BLT.N    ??DeviationGet_5
    139            { //指定范围里没有选取到有效行，则偏差保持原状，选取行置无效值。
    140              tempDevi = DeviPre;
   \   0000005C   0x....             LDR.N    R0,??DataTable2_4
   \   0000005E   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
    141              DeviRowChosen = MaxValUint8;    
   \   00000062   0x....             LDR.N    R0,??DataTable2_3
   \   00000064   0x22FF             MOVS     R2,#+255
   \   00000066   0x7002             STRB     R2,[R0, #+0]
    142            }
    143            
    144            DeviPre = DeviNow;
   \                     ??DeviationGet_5:
   \   00000068   0x....             LDR.N    R0,??DataTable2_4
   \   0000006A   0x....             LDR.N    R2,??DataTable2_5
   \   0000006C   0x8812             LDRH     R2,[R2, #+0]
   \   0000006E   0x8002             STRH     R2,[R0, #+0]
    145            DeviNow = tempDevi;
   \   00000070   0x....             LDR.N    R0,??DataTable2_5
   \   00000072   0x8001             STRH     R1,[R0, #+0]
    146            
    147            return 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x4770             BX       LR               ;; return
    148          }
    149          
    150          //舵机PID控制函数。

   \                                 In section .text, align 2, keep-with-next
    151          uint8 ServoPID(void)
    152          {
   \                     ServoPID:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    153            float temp;
    154            int16 temp1;
    155            
    156            temp1 = DeviNow - DeviPre;
   \   00000002   0x....             LDR.N    R0,??DataTable2_5
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x....             LDR.N    R1,??DataTable2_4
   \   00000008   0x8809             LDRH     R1,[R1, #+0]
   \   0000000A   0x1A44             SUBS     R4,R0,R1
    157            /*
    158            if(temp1 > 50) 
    159            {
    160              temp1 = 50;
    161            }
    162            else if(temp1 < -50)
    163            {
    164              temp1 = -50;
    165            }
    166            else
    167            {
    168            }
    169            */
    170            //ServoKp = DeviNow * DeviNow / ServoK1;
    171            
    172            temp = (ServoPIDMax + ServoPIDMin) / 2 - ServoKp * DeviNow - ServoKd * temp1;
   \   0000000C   0x....             LDR.N    R0,??DataTable2_6
   \   0000000E   0x8800             LDRH     R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable2_7
   \   00000012   0x8809             LDRH     R1,[R1, #+0]
   \   00000014   0xFA11 0xF080      UXTAH    R0,R1,R0
   \   00000018   0x2102             MOVS     R1,#+2
   \   0000001A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000001E   0x.... 0x....      BL       __aeabi_i2f
   \   00000022   0x0005             MOVS     R5,R0
   \   00000024   0x....             LDR.N    R0,??DataTable2_5
   \   00000026   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       __aeabi_i2f
   \   0000002E   0x....             LDR.N    R1,??DataTable2_8
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0x0028             MOVS     R0,R5
   \   0000003A   0x.... 0x....      BL       __aeabi_fsub
   \   0000003E   0x0005             MOVS     R5,R0
   \   00000040   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   00000042   0x0020             MOVS     R0,R4
   \   00000044   0x.... 0x....      BL       __aeabi_i2f
   \   00000048   0x....             LDR.N    R1,??DataTable2_9
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x.... 0x....      BL       __aeabi_fmul
   \   00000050   0x0001             MOVS     R1,R0
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0x.... 0x....      BL       __aeabi_fsub
   \   00000058   0x0004             MOVS     R4,R0
    173            if(temp > ServoPIDMax)
   \   0000005A   0x....             LDR.N    R0,??DataTable2_6
   \   0000005C   0x8800             LDRH     R0,[R0, #+0]
   \   0000005E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000068   0xD205             BCS.N    ??ServoPID_0
    174            {
    175              temp = ServoPIDMax;  
   \   0000006A   0x....             LDR.N    R0,??DataTable2_6
   \   0000006C   0x8800             LDRH     R0,[R0, #+0]
   \   0000006E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000072   0x0004             MOVS     R4,R0
   \   00000074   0xE00D             B.N      ??ServoPID_1
    176            }
    177            else if(temp < ServoPIDMin)
   \                     ??ServoPID_0:
   \   00000076   0x....             LDR.N    R0,??DataTable2_7
   \   00000078   0x8800             LDRH     R0,[R0, #+0]
   \   0000007A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000007E   0x0001             MOVS     R1,R0
   \   00000080   0x0020             MOVS     R0,R4
   \   00000082   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000086   0xD204             BCS.N    ??ServoPID_1
    178            {
    179              temp = ServoPIDMin;
   \   00000088   0x....             LDR.N    R0,??DataTable2_7
   \   0000008A   0x8800             LDRH     R0,[R0, #+0]
   \   0000008C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000090   0x0004             MOVS     R4,R0
    180            }
    181            else
    182            {    
    183            }
    184            
    185            ////////////////////////这里最好建一个函数，把temp更好地映射到FTM1_C0V中。
    186            FTM1_C0V = (uint16)temp;
   \                     ??ServoPID_1:
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x.... 0x....      BL       __aeabi_f2iz
   \   00000098   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000009A   0x....             LDR.N    R1,??DataTable2_10  ;; 0x40039010
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    187            
    188            
    189          
    190              
    191            return 1;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0xBD30             POP      {R4,R5,PC}       ;; return
    192          }
    193          
    194          
    195          //======================================================================
    196          //函数名：SportControl
    197          //功  能：运动控制。
    198          //参  数：无
    199          //返  回：无
    200          //影  响：
    201          //说  明：1. 若图像处理不成功，则延用上一次的控制数据。否则将更新。
    202          //      
    203          //             
    204          //======================================================================

   \                                 In section .text, align 2, keep-with-next
    205          void SportControl(uint8 ImageProFlag)
    206          {
   \                     SportControl:
   \   00000000   0xB510             PUSH     {R4,LR}
    207            uint8 tempD;
    208              if(ImageProFlag) 
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD004             BEQ.N    ??SportControl_0
    209              {
    210                //偏差求取
    211                tempD = DeviationGet();
   \   00000008   0x.... 0x....      BL       DeviationGet
   \   0000000C   0x0004             MOVS     R4,R0
    212                if(!tempD)
    213                {
    214                  //uart_sendN(UART0, (uint8 *)"\nDeviationGet Failed!", 21);  
    215                }
    216                
    217                //舵机PID控制
    218                if(!ServoPID())
   \   0000000E   0x.... 0x....      BL       ServoPID
    219                {
    220                  //uart_sendN(UART0, (uint8 *)"\nServoPID Failed!", 17);
    221                }
    222              }
    223              
    224              
    225              VirtualOutData[0] = DeviPre;
   \                     ??SportControl_0:
   \   00000012   0x....             LDR.N    R0,??DataTable2_4
   \   00000014   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       __aeabi_i2f
   \   0000001C   0x....             LDR.N    R1,??DataTable2_11
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    226              VirtualOutData[1] = DeviNow;
   \   00000020   0x....             LDR.N    R0,??DataTable2_5
   \   00000022   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000026   0x.... 0x....      BL       __aeabi_i2f
   \   0000002A   0x....             LDR.N    R1,??DataTable2_11
   \   0000002C   0x6048             STR      R0,[R1, #+4]
    227              VirtualOutData[2] = CenterLineLoc[25];   //BlackRightLoc[25][0]; //FTM1_C0V - ServoPIDMin;
   \   0000002E   0x....             LDR.N    R0,??DataTable2_1
   \   00000030   0x7E40             LDRB     R0,[R0, #+25]
   \   00000032   0x.... 0x....      BL       __aeabi_ui2f
   \   00000036   0x....             LDR.N    R1,??DataTable2_11
   \   00000038   0x6088             STR      R0,[R1, #+8]
    228              VirtualOutData[3] = DeviRowChosen;
   \   0000003A   0x....             LDR.N    R0,??DataTable2_3
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000042   0x....             LDR.N    R1,??DataTable2_11
   \   00000044   0x60C8             STR      R0,[R1, #+12]
    229              VirtualOutPut_Data();
   \   00000046   0x.... 0x....      BL       VirtualOutPut_Data
    230              
    231               
    232          }
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     DeviSelRow01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     CenterLineLoc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     DeviGoStraightLim

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     DeviRowChosen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     DeviPre

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x........         DC32     DeviNow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     ServoPIDMax

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x........         DC32     ServoPIDMin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x........         DC32     ServoKp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x........         DC32     ServoKd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40039010         DC32     0x40039010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x........         DC32     VirtualOutData
    233          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  DeviationGet
       12  ServoPID
             12 -> __aeabi_cfcmple
             12 -> __aeabi_f2iz
             12 -> __aeabi_fmul
             12 -> __aeabi_fsub
             12 -> __aeabi_i2f
             12 -> __aeabi_ui2f
        8  SportControl
              8 -> DeviationGet
              8 -> ServoPID
              8 -> VirtualOutPut_Data
              8 -> __aeabi_i2f
              8 -> __aeabi_ui2f


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       1  DeviFlag
       2  DeviGoStraightLim
       2  DeviNow
       2  DeviPre
       1  DeviRowChosen
       1  DeviSelRow01
       1  DeviSelRow02
      52  DeviSelRowWeight
     120  DeviationGet
       4  MotorLeftKd
       4  MotorLeftKp
       2  MotorLeftPIDMax
       2  MotorLeftPIDMin
       4  MotorRightKd
       4  MotorRightKp
       2  MotorRightPIDMax
       2  MotorRightPIDMin
       4  ServoK1
       4  ServoKd
       4  ServoKp
     162  ServoPID
       2  ServoPIDCen
       2  ServoPIDMax
       2  ServoPIDMin
      76  SportControl

 
  15 bytes in section .bss
  37 bytes in section .data
  52 bytes in section .rodata
 406 bytes in section .text
 
 406 bytes of CODE  memory
  52 bytes of CONST memory
  52 bytes of DATA  memory

Errors: none
Warnings: none
